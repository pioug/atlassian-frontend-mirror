<!-- API Report Version: 2.3 -->

## API Report File for "@atlaskit/media-client"

> Do not edit this file. This report is auto-generated using [API Extractor](https://api-extractor.com/).
> [Learn more about API reports](https://hello.atlassian.net/wiki/spaces/UR/pages/1825484529/Package+API+Reports)

### Table of contents

- [Main Entry Types](#main-entry-types)
- [Peer Dependencies](#peer-dependencies)

### Main Entry Types

<!--SECTION START: Main Entry Types-->

```ts
import { AsapBasedAuth } from '@atlaskit/media-core';
import { Auth } from '@atlaskit/media-core';
import { AuthContext } from '@atlaskit/media-core';
import { AuthProvider } from '@atlaskit/media-core';
import { ChunkinatorFile } from '@atlaskit/chunkinator';
import { ClientAltBasedAuth } from '@atlaskit/media-core';
import { FileStatus as FileStatus_2 } from '@atlaskit/media-common';
import { MediaApiConfig } from '@atlaskit/media-core';
import { MediaClientConfig } from '@atlaskit/media-core';
import { MediaFeatureFlags } from '@atlaskit/media-common';
import { MediaTraceContext } from '@atlaskit/media-common';
import { MediaType } from '@atlaskit/media-common';
import { default as React_2 } from 'react';
import { ReplaySubject } from 'rxjs/ReplaySubject';

// @public (undocumented)
export type AbortFunction = () => void;

// @public (undocumented)
export const addFileAttrsToUrl: (
  url: string,
  fileAttrs: MediaBlobUrlAttrs,
) => string;

// @public (undocumented)
export type AppendChunksToUploadRequestBody = {
  readonly chunks: string[];
  readonly hash?: string;
  readonly offset?: number;
};

// @public (undocumented)
export type Artifacts = {
  [name: string]: MediaArtifact;
};

// @public (undocumented)
type BaseFileState = {
  metadataTraceContext?: MediaTraceContext;
};

// @public
abstract class BaseMediaClientError<
    Attributes extends MediaClientErrorAttributes,
  >
  extends Error
  implements MediaClientError<Attributes>
{
  constructor(message: string);
  // (undocumented)
  abstract get attributes(): Attributes;
  // (undocumented)
  readonly message: string;
}

// @public (undocumented)
export const checkWebpSupport: () => Promise<boolean>;

// @public (undocumented)
export type ClientOptions = {
  readonly retryOptions?: Partial<RetryOptions>;
  readonly clientTimeout?: number;
};

// @public (undocumented)
type CompletionObserver = PartialObserver &
  Required<Pick<PartialObserver, 'complete'>>;

// @public (undocumented)
export interface CopyDestination extends MediaStoreCopyFileWithTokenParams {
  // (undocumented)
  authProvider: AuthProvider;
  // (undocumented)
  mediaStore?: MediaStore;
}

// @public (undocumented)
export interface CopyFileOptions {
  // (undocumented)
  mimeType?: string;
  // (undocumented)
  preview?: FilePreview | Promise<FilePreview>;
}

// @public (undocumented)
export interface CopySourceFile {
  // (undocumented)
  authProvider: AuthProvider;
  // (undocumented)
  collection?: string;
  // (undocumented)
  id: string;
}

// @public (undocumented)
export interface CreatedTouchedFile {
  // (undocumented)
  fileId: string;
  // (undocumented)
  uploadId: string;
}

// @public (undocumented)
export function createMediaSubject<T extends FileState>(
  initialState?: Error | T,
): ReplaySubject<T>;

// @public (undocumented)
export function createMediaSubscribable(
  item?: Error | FileState,
): MediaSubscribable;

// @public (undocumented)
export function createRequestErrorReason(
  statusCode: number,
): RequestErrorReason;

// @public (undocumented)
export function createUrl(
  url: string,
  { params, auth }: CreateUrlOptions,
): string;

// @public (undocumented)
export type CreateUrlOptions = {
  readonly params?: RequestParams;
  readonly auth?: Auth;
};

// @public (undocumented)
export type Dimensions = {
  width: number;
  height: number;
};

// @public (undocumented)
export interface EdgeData {
  // (undocumented)
  data: {
    clientId: string;
    token: string;
    baseUrl: string;
    expiresIn: number;
    iat: number;
  };
}

// @public (undocumented)
export interface EmptyFile {
  // (undocumented)
  readonly createdAt: number;
  // (undocumented)
  readonly id: string;
}

// @public (undocumented)
export interface ErrorFileState extends BaseFileState {
  // (undocumented)
  id: string;
  // (undocumented)
  message?: string;
  // (undocumented)
  occurrenceKey?: string;
  // (undocumented)
  status: 'error';
}

// @public (undocumented)
type ErrorObserver = PartialObserver & Required<Pick<PartialObserver, 'error'>>;

// @public (undocumented)
export type EventPayloadListener<
  M extends EventPayloadMap<P>,
  E extends keyof M,
  P = any,
> = (payload: M[E]) => void;

// @public (undocumented)
type EventPayloadMap<P> = {
  readonly [event: string]: P;
};

// @public (undocumented)
export type Executor = () => Promise<void>;

// @public (undocumented)
export interface ExternalImageIdentifier {
  // (undocumented)
  readonly dataURI: string;
  // (undocumented)
  readonly mediaItemType: 'external-image';
  // (undocumented)
  readonly name?: string;
}

// @public (undocumented)
type ExternalUploadPayload = {
  uploadableFileUpfrontIds: UploadableFileUpfrontIds;
  dimensions: Dimensions;
};

// @public (undocumented)
export interface FileDetails {
  // (undocumented)
  artifacts?: Artifacts;
  // (undocumented)
  createdAt?: number;
  // (undocumented)
  creationDate?: number;
  // (undocumented)
  id: string;
  // (undocumented)
  mediaType?: MediaType;
  // (undocumented)
  mimeType?: string;
  // (undocumented)
  name?: string;
  // (undocumented)
  processingStatus?: FileProcessingStatus;
  // (undocumented)
  size?: number;
}

// @public (undocumented)
export interface FileFetcher {
  // (undocumented)
  copyFile(
    source: CopySourceFile,
    destination: CopyDestination,
    options?: CopyFileOptions,
    traceContext?: MediaTraceContext,
  ): Promise<MediaFile>;
  // (undocumented)
  downloadBinary(
    id: string,
    name?: string,
    collectionName?: string,
  ): Promise<void>;
  // (undocumented)
  getArtifactURL(
    artifacts: MediaFileArtifacts,
    artifactName: keyof MediaFileArtifacts,
    collectionName?: string,
  ): Promise<string>;
  // (undocumented)
  getCurrentState(id: string, options?: GetFileOptions): Promise<FileState>;
  // (undocumented)
  getFileBinaryURL(id: string, collectionName?: string): Promise<string>;
  // (undocumented)
  getFileState(id: string, options?: GetFileOptions): MediaSubscribable;
  // (undocumented)
  touchFiles(
    descriptors: TouchFileDescriptor[],
    collection?: string,
    traceContext?: MediaTraceContext,
  ): Promise<TouchedFiles>;
  // (undocumented)
  upload(
    file: UploadableFile,
    controller?: UploadController,
    uploadableFileUpfrontIds?: UploadableFileUpfrontIds,
    traceContext?: MediaTraceContext,
  ): MediaSubscribable;
  // (undocumented)
  uploadExternal(
    url: string,
    collection?: string,
    traceContext?: MediaTraceContext,
  ): Promise<ExternalUploadPayload>;
}

// @public (undocumented)
export class FileFetcherError extends BaseMediaClientError<FileFetcherErrorAttributes> {
  constructor(
    reason: FileFetcherErrorReason,
    id: string,
    metadata?:
      | undefined
      | {
          readonly collectionName?: string | undefined;
          readonly occurrenceKey?: string | undefined;
        },
  );
  // (undocumented)
  get attributes(): {
    reason: FileFetcherErrorReason;
    id: string;
    collectionName: string | undefined;
    occurrenceKey: string | undefined;
  };
  // (undocumented)
  readonly id: string;
  // (undocumented)
  readonly metadata?:
    | undefined
    | {
        readonly collectionName?: string | undefined;
        readonly occurrenceKey?: string | undefined;
      };
  // (undocumented)
  readonly reason: FileFetcherErrorReason;
}

// @public (undocumented)
export type FileFetcherErrorAttributes = {
  readonly reason: FileFetcherErrorReason;
  readonly id: string;
  readonly metadata?: {
    readonly collectionName?: string;
    readonly occurrenceKey?: string;
  };
};

// @public (undocumented)
export type FileFetcherErrorReason =
  | 'emptyFileName'
  | 'emptyItems'
  | 'invalidFileId'
  | 'zeroVersionFile';

// @public (undocumented)
export class FileFetcherImpl implements FileFetcher {
  constructor(mediaStore: MediaStore);
  // (undocumented)
  copyFile(
    source: CopySourceFile,
    destination: CopyDestination,
    options?: CopyFileOptions,
    traceContext?: MediaTraceContext,
  ): Promise<MediaFile>;
  // (undocumented)
  downloadBinary(
    id: string,
    name?: string,
    collectionName?: string,
  ): Promise<void>;
  // (undocumented)
  getArtifactURL(
    artifacts: MediaFileArtifacts,
    artifactName: keyof MediaFileArtifacts,
    collectionName?: string,
  ): Promise<string>;
  // (undocumented)
  getCurrentState(id: string, options?: GetFileOptions): Promise<FileState>;
  // (undocumented)
  getFileBinaryURL(id: string, collectionName?: string): Promise<string>;
  // (undocumented)
  getFileState(id: string, options?: GetFileOptions): MediaSubscribable;
  // (undocumented)
  touchFiles(
    descriptors: TouchFileDescriptor[],
    collection?: string,
    traceContext?: MediaTraceContext,
  ): Promise<TouchedFiles>;
  // (undocumented)
  upload(
    file: UploadableFile,
    controller?: UploadController,
    uploadableFileUpfrontIds?: UploadableFileUpfrontIds,
    traceContext?: MediaTraceContext,
  ): MediaSubscribable;
  // (undocumented)
  uploadExternal(
    url: string,
    collection?: string,
    traceContext?: MediaTraceContext,
  ): Promise<ExternalUploadPayload>;
}

// @public (undocumented)
export interface FileIdentifier {
  // (undocumented)
  readonly collectionName?: string;
  // (undocumented)
  readonly id: string;
  // (undocumented)
  readonly mediaItemType: 'file';
  // (undocumented)
  readonly occurrenceKey?: string;
}

// @public (undocumented)
export interface FileItem {
  // (undocumented)
  details: FileDetails;
  // (undocumented)
  type: 'file';
}

// @public (undocumented)
export interface FilePreview {
  // (undocumented)
  origin?: 'local' | 'remote';
  // (undocumented)
  originalDimensions?: {
    width: number;
    height: number;
  };
  // (undocumented)
  value: Blob | string;
}

// @public (undocumented)
export type FileProcessingStatus =
  | 'failed'
  | 'pending'
  | 'running'
  | 'succeeded';

// @public (undocumented)
export type FileState =
  | ErrorFileState
  | ProcessedFileState
  | ProcessingFailedState
  | ProcessingFileState
  | UploadingFileState;

// @public (undocumented)
export type FileStatus = FileStatus_2;

// @public (undocumented)
export function fromObservable(
  observable: ReplaySubject<FileState>,
): MediaSubscribable;

// @public (undocumented)
export const getArtifactUrl: (
  artifacts: MediaFileArtifacts,
  prop: keyof MediaFileArtifacts,
) => string | undefined;

// @public (undocumented)
export const getAttrsFromUrl: (
  blobUrl: string,
) => MediaBlobUrlAttrs | undefined;

// @public (undocumented)
export const getDimensionsFromBlob: (
  mediaType: MediaType,
  blob: Blob,
) => Promise<Dimensions>;

// @public (undocumented)
export interface GetFileOptions {
  // (undocumented)
  collectionName?: string;
  // (undocumented)
  occurrenceKey?: string;
  // (undocumented)
  preview?: PreviewOptions;
}

// @public (undocumented)
export const getMediaClient: (
  mediaClientConfig: MediaClientConfig,
  featureFlags?: MediaFeatureFlags,
) => MediaClient;

// @public (undocumented)
export function getMediaClientErrorReason(
  err: Error,
): 'unknown' | MediaClientErrorReason;

// @public (undocumented)
export const getMediaEnvironment: () => string | undefined;

// @public (undocumented)
export const getMediaRegion: () => string | undefined;

// @public @deprecated (undocumented)
export const getMediaTypeFromMimeType: (mimeType: string) => MediaType;

// @public (undocumented)
export const globalMediaEventEmitter: {
  on<E extends keyof UploadEventPayloadMap>(
    event: E,
    listener: EventPayloadListener<UploadEventPayloadMap, E, any>,
  ): void;
  off<E_1 extends keyof UploadEventPayloadMap>(
    event: E_1,
    listener: EventPayloadListener<UploadEventPayloadMap, E_1, any>,
  ): void;
  emit<E_2 extends keyof UploadEventPayloadMap>(
    event: E_2,
    payload: UploadEventPayloadMap[E_2],
  ): boolean | undefined;
};

// @public (undocumented)
export type Identifier = ExternalImageIdentifier | FileIdentifier;

// @public (undocumented)
export interface ImageMetadata {
  // (undocumented)
  original?: ImageMetadataArtifact;
  // (undocumented)
  pending: boolean;
  // (undocumented)
  preview?: ImageMetadataArtifact;
}

// @public (undocumented)
export type ImageMetadataArtifact = {
  url?: string;
  width?: number;
  height?: number;
  size?: number;
};

// @public (undocumented)
export type ImageResizeMode = 'crop' | 'fit' | 'full-fit' | 'stretchy-fit';

// @public (undocumented)
export const imageResizeModeToFileImageMode: (
  resizeMode?: ImageResizeMode,
) => MediaStoreGetFileImageParams['mode'];

// @public (undocumented)
export function isAbortedRequestError(err: any): boolean;

// @public @deprecated (undocumented)
export const isAudioMimeTypeSupportedByServer: (mimeType: string) => boolean;

// @public (undocumented)
export const isDifferentIdentifier: (a: Identifier, b: Identifier) => boolean;

// @public @deprecated (undocumented)
export const isDocumentMimeTypeSupportedByBrowser: (
  mimeType: string,
) => boolean;

// @public @deprecated (undocumented)
export const isDocumentMimeTypeSupportedByServer: (mimeType: string) => boolean;

// @public (undocumented)
export const isErrorFileState: (
  fileState: FileState,
) => fileState is ErrorFileState;

// @public (undocumented)
export const isExternalImageIdentifier: (
  identifier: Identifier,
) => identifier is ExternalImageIdentifier;

// @public (undocumented)
export function isFileFetcherError(err: Error): err is FileFetcherError;

// @public (undocumented)
export const isFileIdentifier: (
  identifier: Identifier,
) => identifier is FileIdentifier;

// @public (undocumented)
export const isFinalFileState: (
  fileState: FileState,
) => fileState is ErrorFileState | ProcessedFileState | ProcessingFailedState;

// @public @deprecated (undocumented)
export const isImageMimeTypeSupportedByBrowser: (mimeType: string) => boolean;

// @public @deprecated (undocumented)
export const isImageMimeTypeSupportedByServer: (mimeType: string) => boolean;

// @public (undocumented)
export const isImageRemote: (
  imageUrl: string,
  windowOrigin?: string,
) => boolean;

// @public (undocumented)
export const isImageRepresentationReady: (fileState: FileState) => boolean;

// @public (undocumented)
export const isMediaBlobUrl: (url: string) => boolean;

// @public (undocumented)
export function isMediaClientError(error: any): error is MediaClientError<{
  reason: MediaClientErrorReason;
}>;

// @public (undocumented)
export function isMediaStoreError(err: Error): err is MediaStoreError;

// @public @deprecated (undocumented)
export const isMimeTypeSupportedByBrowser: (mimeType: string) => boolean;

// @public @deprecated (undocumented)
export const isMimeTypeSupportedByServer: (mimeType: string) => boolean;

// @public (undocumented)
export function isPollingError(err?: Error): err is PollingError;

// @public (undocumented)
export const isPreviewableFileState: (
  fileState: FileState,
) => fileState is (
  | ProcessedFileState
  | ProcessingFailedState
  | ProcessingFileState
  | UploadingFileState
) &
  PreviewableFileState;

// @public (undocumented)
export const isPreviewableType: (type: MediaType) => boolean;

// @public (undocumented)
export const isProcessedFileState: (
  fileState: FileState,
) => fileState is ProcessedFileState;

// @public (undocumented)
export const isProcessingFileState: (
  fileState: FileState,
) => fileState is ProcessingFileState;

// @public (undocumented)
export function isRateLimitedError(error: Error | undefined): boolean;

// @public (undocumented)
export function isRequestError(err: Error): err is RequestError;

// @public @deprecated (undocumented)
export const isUnknownMimeTypeSupportedByServer: (mimeType: string) => boolean;

// @public (undocumented)
export const isUploadingFileState: (
  fileState: FileState,
) => fileState is UploadingFileState;

// @public @deprecated (undocumented)
export const isVideoMimeTypeSupportedByServer: (mimeType: string) => boolean;

// @public (undocumented)
export interface ItemsPayload {
  // (undocumented)
  items: ResponseFileItem[];
}

// @public (undocumented)
export const mapMediaFileToFileState: (
  mediaFile: MediaStoreResponse<MediaFile>,
) => FileState;

// @public (undocumented)
export const mapMediaItemToFileState: (
  id: string,
  item: MediaItemDetails,
) => FileState;

// @public @deprecated (undocumented)
export function mapResponseToBlob(response: Response): Promise<Blob>;

// @public @deprecated (undocumented)
export function mapResponseToJson(response: Response): Promise<any>;

// @public @deprecated (undocumented)
export function mapResponseToVoid(): Promise<void>;

// @public (undocumented)
export const MAX_RESOLUTION = 4096;

// @public (undocumented)
export interface MediaArtifact {
  // (undocumented)
  processingStatus?: FileProcessingStatus;
  // (undocumented)
  url?: string;
}

// @public (undocumented)
export interface MediaBlobUrlAttrs {
  // (undocumented)
  alt?: string;
  // (undocumented)
  collection?: string;
  // (undocumented)
  contextId: string;
  // (undocumented)
  height?: number;
  // (undocumented)
  id: string;
  // (undocumented)
  mimeType?: string;
  // (undocumented)
  name?: string;
  // (undocumented)
  size?: number;
  // (undocumented)
  width?: number;
}

// @public (undocumented)
export type MediaChunksProbe = {
  readonly results: {
    readonly [etag: string]: {
      readonly exists: boolean;
    };
  };
};

// @public (undocumented)
export class MediaClient {
  constructor(
    mediaClientConfig: MediaClientConfig,
    featureFlags?: MediaFeatureFlags | undefined,
  );
  // (undocumented)
  readonly config: MediaClientConfig;
  // (undocumented)
  emit<E extends keyof UploadEventPayloadMap>(
    event: E,
    payload: UploadEventPayloadMap[E],
  ): boolean;
  // (undocumented)
  readonly featureFlags?: MediaFeatureFlags | undefined;
  // (undocumented)
  readonly file: FileFetcher;
  // (undocumented)
  getImage(
    id: string,
    params?: MediaStoreGetFileImageParams,
    controller?: AbortController,
    fetchMaxRes?: boolean,
    traceContext?: MediaTraceContext,
  ): Promise<Blob>;
  // (undocumented)
  getImageMetadata(
    id: string,
    params?: MediaStoreGetFileImageParams,
  ): Promise<ImageMetadata>;
  // (undocumented)
  getImageUrl(
    id: string,
    params?: MediaStoreGetFileImageParams,
  ): Promise<string>;
  // (undocumented)
  getImageUrlSync(id: string, params?: MediaStoreGetFileImageParams): string;
  // (undocumented)
  readonly mediaClientConfig: MediaClientConfig;
  // (undocumented)
  readonly mediaStore: MediaStore;
  // (undocumented)
  mobileUploadPromise(): Promise<MobileUpload>;
  // (undocumented)
  off<E extends keyof UploadEventPayloadMap>(
    event: E,
    listener: EventPayloadListener<UploadEventPayloadMap, E>,
  ): void;
  // (undocumented)
  on<E extends keyof UploadEventPayloadMap>(
    event: E,
    listener: EventPayloadListener<UploadEventPayloadMap, E>,
  ): void;
  // (undocumented)
  removeFileFromCollection(
    id: string,
    collectionName: string,
    occurrenceKey?: string,
    traceContext?: MediaTraceContext,
  ): Promise<void>;
  // (undocumented)
  readonly stargate: StargateClient;
}

// @public
export interface MediaClientError<Attributes extends MediaClientErrorAttributes>
  extends Error {
  // (undocumented)
  readonly attributes: Attributes;
}

// @public (undocumented)
export interface MediaClientErrorAttributes {
  // (undocumented)
  reason: MediaClientErrorReason;
}

// @public (undocumented)
export type MediaClientErrorReason =
  | 'authProviderTimedOut'
  | 'clientAbortedRequest'
  | 'clientOffline'
  | 'clientTimeoutRequest'
  | 'deprecatedEndpoint'
  | 'emptyAuth'
  | 'emptyFileName'
  | 'emptyItems'
  | 'failedAuthProvider'
  | 'fileSizeExceedsLimit'
  | 'invalidFileId'
  | 'missingInitialAuth'
  | 'pollingMaxAttemptsExceeded'
  | 'serverBadGateway'
  | 'serverBadRequest'
  | 'serverForbidden'
  | 'serverInternalError'
  | 'serverInvalidBody'
  | 'serverNotFound'
  | 'serverRateLimited'
  | 'serverUnauthorized'
  | 'serverUnexpectedError'
  | 'tokenExpired'
  | 'zeroVersionFile';

// @public (undocumented)
export type MediaFile = {
  readonly id: string;
  readonly mediaType: MediaType;
  readonly mimeType: string;
  readonly name: string;
  readonly processingStatus?: MediaFileProcessingStatus;
  readonly size: number;
  readonly artifacts: MediaFileArtifacts;
  readonly representations: MediaRepresentations;
  readonly createdAt?: number;
  readonly metadataTraceContext?: MediaTraceContext;
};

// @public (undocumented)
export type MediaFileArtifact = {
  readonly url: string;
  readonly processingStatus: MediaFileProcessingStatus;
};

// @public (undocumented)
export interface MediaFileArtifacts {
  // (undocumented)
  'audio.mp3'?: MediaFileArtifact;
  // (undocumented)
  'document.pdf'?: MediaFileArtifact;
  // (undocumented)
  'image.jpg'?: MediaFileArtifact;
  // (undocumented)
  'image.png'?: MediaFileArtifact;
  // (undocumented)
  'thumb.jpg'?: MediaFileArtifact;
  // (undocumented)
  'video_1280.mp4'?: MediaFileArtifact;
  // (undocumented)
  'video_640.mp4'?: MediaFileArtifact;
}

// @public (undocumented)
export type MediaFileProcessingStatus = 'failed' | 'pending' | 'succeeded';

// @public (undocumented)
export type MediaItemDetails = {
  readonly mediaType: MediaType;
  readonly mimeType: string;
  readonly name: string;
  readonly processingStatus: MediaFileProcessingStatus;
  readonly size: number;
  readonly artifacts: MediaFileArtifacts;
  readonly representations: MediaRepresentations;
  readonly createdAt?: number;
  readonly metadataTraceContext?: MediaTraceContext;
};

// @public (undocumented)
export type MediaItemType = 'external-image' | 'file';

// @public (undocumented)
export type MediaObserver =
  | ((value: FileState) => void)
  | CompletionObserver
  | ErrorObserver
  | NextObserver;

// @public (undocumented)
export type MediaRepresentations = {
  image?: Object;
};

// @public (undocumented)
export class MediaStore {
  constructor(
    config: MediaApiConfig,
    featureFlags?: MediaFeatureFlags | undefined,
  );
  // (undocumented)
  appendChunksToUpload(
    uploadId: string,
    body: AppendChunksToUploadRequestBody,
    collectionName?: string,
    traceContext?: MediaTraceContext,
  ): Promise<void>;
  // (undocumented)
  copyFileWithToken(
    body: MediaStoreCopyFileWithTokenBody,
    params: MediaStoreCopyFileWithTokenParams,
    traceContext?: MediaTraceContext,
  ): Promise<MediaStoreResponse<MediaFile>>;
  // (undocumented)
  createFileFromUpload(
    body: MediaStoreCreateFileFromUploadBody,
    params?: MediaStoreCreateFileFromUploadParams,
    traceContext?: MediaTraceContext,
  ): Promise<MediaStoreResponse<MediaFile>>;
  // (undocumented)
  createUpload(
    createUpTo?: number,
    collectionName?: string,
    traceContext?: MediaTraceContext,
  ): Promise<MediaStoreResponse<MediaUpload[]>>;
  // (undocumented)
  readonly featureFlags?: MediaFeatureFlags | undefined;
  // (undocumented)
  getArtifactURL(
    artifacts: MediaFileArtifacts,
    artifactName: keyof MediaFileArtifacts,
    collectionName?: string,
  ): Promise<string>;
  // (undocumented)
  getFile(
    fileId: string,
    params?: MediaStoreGetFileParams,
    traceContext?: MediaTraceContext,
  ): Promise<MediaStoreResponse<MediaFile>>;
  // (undocumented)
  getFileBinaryURL(id: string, collectionName?: string): Promise<string>;
  // (undocumented)
  getFileImageURL(
    id: string,
    params?: MediaStoreGetFileImageParams,
  ): Promise<string>;
  // (undocumented)
  getFileImageURLSync(
    id: string,
    params?: MediaStoreGetFileImageParams,
  ): string;
  // (undocumented)
  getImage(
    id: string,
    params?: MediaStoreGetFileImageParams,
    controller?: AbortController,
    fetchMaxRes?: boolean,
    traceContext?: MediaTraceContext,
  ): Promise<Blob>;
  // (undocumented)
  getImageMetadata(
    id: string,
    params?: MediaStoreGetFileImageParams,
    traceContext?: MediaTraceContext,
  ): Promise<{
    metadata: ImageMetadata;
  }>;
  // (undocumented)
  getItems(
    ids: string[],
    collectionName?: string,
    traceContext?: MediaTraceContext,
  ): Promise<MediaStoreResponse<ItemsPayload>>;
  // (undocumented)
  getRejectedResponseFromDescriptor(
    descriptor: TouchFileDescriptor,
    limit: number,
  ): RejectedTouchFile;
  // (undocumented)
  probeChunks(
    chunks: string[],
    uploadId: string,
    collectionName?: string,
    traceContext?: MediaTraceContext,
  ): Promise<MediaStoreResponse<MediaChunksProbe>>;
  // (undocumented)
  removeCollectionFile(
    id: string,
    collectionName: string,
    occurrenceKey?: string,
    traceContext?: MediaTraceContext,
  ): Promise<void>;
  // (undocumented)
  request(
    path: string,
    options?: MediaStoreRequestOptions,
    controller?: AbortController,
  ): Promise<Response>;
  // (undocumented)
  resolveAuth: (authContext?: AuthContext) => Promise<Auth>;
  // (undocumented)
  resolveInitialAuth: () => Auth;
  // (undocumented)
  touchFiles(
    body: MediaStoreTouchFileBody,
    params?: MediaStoreTouchFileParams,
    traceContext?: MediaTraceContext,
  ): Promise<MediaStoreResponse<TouchedFiles>>;
  // (undocumented)
  uploadChunk(
    etag: string,
    blob: Blob,
    uploadId: string,
    partNumber: number,
    collectionName?: string,
    traceContext?: MediaTraceContext,
  ): Promise<void>;
}

// @public (undocumented)
export type MediaStoreCopyFileWithTokenBody = {
  sourceFile: SourceFile;
};

// @public (undocumented)
export type MediaStoreCopyFileWithTokenParams = {
  readonly collection?: string;
  readonly replaceFileId?: string;
  readonly occurrenceKey?: string;
};

// @public (undocumented)
export type MediaStoreCreateFileFromBinaryParams = {
  readonly replaceFileId?: string;
  readonly collection?: string;
  readonly occurrenceKey?: string;
  readonly expireAfter?: number;
  readonly skipConversions?: boolean;
  readonly name?: string;
};

// @public (undocumented)
export type MediaStoreCreateFileFromUploadBody = {
  readonly uploadId: string;
  readonly name?: string;
  readonly mimeType?: string;
  readonly conditions?: MediaStoreCreateFileFromUploadConditions;
};

// @public (undocumented)
export type MediaStoreCreateFileFromUploadConditions = {
  readonly hash?: string;
  readonly size?: number;
};

// @public (undocumented)
export type MediaStoreCreateFileFromUploadParams = {
  readonly collection?: string;
  readonly occurrenceKey?: string;
  readonly expireAfter?: number;
  readonly replaceFileId?: string;
  readonly skipConversions?: boolean;
};

// @public (undocumented)
export type MediaStoreCreateFileParams = {
  readonly occurrenceKey?: string;
  readonly collection?: string;
};

// @public (undocumented)
export class MediaStoreError extends BaseMediaClientError<MediaStoreErrorAttributes> {
  constructor(reason: MediaStoreErrorReason, innerError?: Error | undefined);
  // (undocumented)
  get attributes(): {
    reason: MediaStoreErrorReason;
    innerError: Error | undefined;
  };
  // (undocumented)
  readonly innerError?: Error | undefined;
  // (undocumented)
  readonly reason: MediaStoreErrorReason;
}

// @public (undocumented)
export type MediaStoreErrorAttributes = {
  readonly reason: MediaStoreErrorReason;
  readonly innerError?: Error;
};

// @public (undocumented)
export type MediaStoreErrorReason =
  | 'authProviderTimedOut'
  | 'emptyAuth'
  | 'failedAuthProvider'
  | 'missingInitialAuth'
  | 'tokenExpired';

// @public (undocumented)
export type MediaStoreGetFileImageParams = {
  readonly allowAnimated?: boolean;
  readonly version?: number;
  readonly collection?: string;
  readonly width?: number;
  readonly height?: number;
  readonly mode?: 'crop' | 'fit' | 'full-fit';
  readonly upscale?: boolean;
  readonly 'max-age'?: number;
};

// @public (undocumented)
export type MediaStoreGetFileParams = {
  readonly version?: number;
  readonly collection?: string;
};

// @public (undocumented)
export type MediaStoreRequestOptions = RequestMetadata & {
  readonly method?: RequestMethod;
  readonly authContext?: AuthContext;
  readonly params?: RequestParams;
  readonly headers?: RequestHeaders;
  readonly body?: any;
  readonly clientOptions?: ClientOptions;
  readonly traceContext?: MediaTraceContext;
};

// @public (undocumented)
export interface MediaStoreResponse<Data> {
  // (undocumented)
  readonly data: Data;
}

// @public (undocumented)
export interface MediaStoreTouchFileBody {
  // (undocumented)
  descriptors: TouchFileDescriptor[];
}

// @public (undocumented)
export interface MediaStoreTouchFileParams {
  // (undocumented)
  readonly collection?: string;
}

// @public (undocumented)
export type MediaSubscribable = {
  subscribe(observer?: MediaObserver): MediaSubscription;
};

// @public (undocumented)
export type MediaSubscription = {
  unsubscribe: () => void;
};

export { MediaType };

// @public (undocumented)
export type MediaUpload = {
  readonly id: string;
  readonly created: number;
  readonly expires: number;
};

// @public (undocumented)
export interface MediaViewedEventPayload {
  // (undocumented)
  fileId: string;
  // (undocumented)
  isUserCollection?: boolean;
  // (undocumented)
  viewingLevel: 'download' | 'full' | 'minimal';
}

// @public (undocumented)
export interface MobileUpload {
  // (undocumented)
  notifyUploadEnd(event: MobileUploadEndEvent): void;
  // (undocumented)
  notifyUploadError(event: MobileUploadErrorEvent): void;
  // (undocumented)
  notifyUploadProgress(event: MobileUploadProgressEvent): void;
  // (undocumented)
  notifyUploadStart(event: MobileUploadStartEvent): void;
}

// @public (undocumented)
export type MobileUploadEndEvent = {
  fileId: string;
};

// @public (undocumented)
export type MobileUploadErrorEvent = {
  fileId: string;
  message: string;
};

// @public (undocumented)
export type MobileUploadProgressEvent = {
  fileId: string;
  progress: number;
};

// @public (undocumented)
export type MobileUploadStartEvent = {
  fileId: string;
  collectionName?: string;
  occurrenceKey?: string;
  fileName: string;
  fileSize: number;
  fileMimetype: string;
  preview?: FilePreview;
  createdAt?: number;
};

// @public (undocumented)
type NextObserver = PartialObserver & Required<Pick<PartialObserver, 'next'>>;

// @public (undocumented)
export type NonErrorFileState = Exclude<FileState, ErrorFileState>;

// @public (undocumented)
export const objectToQueryString: (json: {
  [key: string]: boolean | null | number | string | undefined;
}) => string;

// @public (undocumented)
type PartialObserver = {
  next?: (value: FileState) => void;
  error?: (err: any) => void;
  complete?: () => void;
};

// @public (undocumented)
export class PollingError extends BaseMediaClientError<PollingErrorAttributes> {
  constructor(reason: PollingErrorReason, attempts: number);
  // (undocumented)
  readonly attempts: number;
  // (undocumented)
  get attributes(): {
    reason: 'pollingMaxAttemptsExceeded';
    attempts: number;
  };
  // (undocumented)
  readonly reason: PollingErrorReason;
}

// @public (undocumented)
export type PollingErrorAttributes = {
  readonly reason: PollingErrorReason;
  readonly attempts: number;
  readonly innerError?: Error;
};

// @public (undocumented)
export type PollingErrorReason = 'pollingMaxAttemptsExceeded';

// @public
export class PollingFunction {
  constructor(options?: Partial<PollingOptions>);
  // (undocumented)
  attempt: number;
  // (undocumented)
  cancel(): void;
  // (undocumented)
  execute(executor: Executor): Promise<void>;
  // (undocumented)
  getIntervalMsForIteration(iteration: number): number;
  // (undocumented)
  next(): void;
  // (undocumented)
  onError?: (error: Error) => void;
  // (undocumented)
  options: PollingOptions;
  // (undocumented)
  poll_intervalMs: number;
  // (undocumented)
  shouldIterate: boolean;
  // (undocumented)
  timeoutId: number;
}

// @public (undocumented)
interface PollingOptions {
  // (undocumented)
  poll_backoffFactor: number;
  // (undocumented)
  poll_intervalMs: number;
  // (undocumented)
  poll_maxAttempts: number;
  // (undocumented)
  poll_maxIntervalMs: number;
}

// @public (undocumented)
export interface PreviewableFileState {
  // (undocumented)
  preview: FilePreview | Promise<FilePreview>;
}

// @public (undocumented)
export interface PreviewOptions {}

// @public (undocumented)
export interface ProcessedFileState extends BaseFileState {
  // (undocumented)
  artifacts: MediaFileArtifacts;
  // (undocumented)
  createdAt?: number;
  // (undocumented)
  id: string;
  // (undocumented)
  mediaType: MediaType;
  // (undocumented)
  mimeType: string;
  // (undocumented)
  name: string;
  // (undocumented)
  occurrenceKey?: string;
  // (undocumented)
  preview?: FilePreview | Promise<FilePreview>;
  // (undocumented)
  representations?: MediaRepresentations;
  // (undocumented)
  size: number;
  // (undocumented)
  status: 'processed';
}

// @public (undocumented)
export interface ProcessingFailedState extends BaseFileState {
  // (undocumented)
  artifacts: Object;
  // (undocumented)
  createdAt?: number;
  // (undocumented)
  id: string;
  // (undocumented)
  mediaType: MediaType;
  // (undocumented)
  mimeType: string;
  // (undocumented)
  name: string;
  // (undocumented)
  occurrenceKey?: string;
  // (undocumented)
  preview?: FilePreview | Promise<FilePreview>;
  // (undocumented)
  representations?: MediaRepresentations;
  // (undocumented)
  size: number;
  // (undocumented)
  status: 'failed-processing';
}

// @public (undocumented)
export interface ProcessingFileState extends BaseFileState {
  // (undocumented)
  artifacts?: MediaFileArtifacts;
  // (undocumented)
  createdAt?: number;
  // (undocumented)
  id: string;
  // (undocumented)
  mediaType: MediaType;
  // (undocumented)
  mimeType: string;
  // (undocumented)
  name: string;
  // (undocumented)
  occurrenceKey?: string;
  // (undocumented)
  preview?: FilePreview | Promise<FilePreview>;
  // (undocumented)
  representations?: MediaRepresentations;
  // (undocumented)
  size: number;
  // (undocumented)
  status: 'processing';
}

// @public (undocumented)
export const RECENTS_COLLECTION = 'recents';

// @public (undocumented)
interface RejectedTouchFile {
  // (undocumented)
  error: RejectionError;
  // (undocumented)
  fileId: string;
}

// @public (undocumented)
type RejectionError = {
  code: 'ExceedMaxFileSizeLimit';
  title: string;
  href: string;
  limit: number;
  size: number;
};

// @public (undocumented)
export function request(
  url: string,
  options?: RequestOptions,
  controller?: AbortController,
): Promise<Response>;

// @public (undocumented)
export class RequestError extends BaseMediaClientError<RequestErrorAttributes> {
  constructor(
    reason: RequestErrorReason,
    metadata?: RequestErrorMetadata | undefined,
    innerError?: Error | undefined,
  );
  // (undocumented)
  get attributes(): {
    reason: RequestErrorReason;
    method: RequestMethod | undefined;
    endpoint: string | undefined;
    mediaRegion: string | undefined;
    mediaEnv: string | undefined;
    attempts: number | undefined;
    clientExhaustedRetries: boolean | undefined;
    statusCode: number | undefined;
    innerError: Error | undefined;
  };
  // (undocumented)
  readonly innerError?: Error | undefined;
  // (undocumented)
  readonly metadata?: RequestErrorMetadata | undefined;
  // (undocumented)
  readonly reason: RequestErrorReason;
}

// @public (undocumented)
export type RequestErrorAttributes = RequestErrorMetadata & {
  readonly reason: RequestErrorReason;
};

// @public (undocumented)
export type RequestErrorMetadata = RequestMetadata & {
  readonly attempts?: number;
  readonly clientExhaustedRetries?: boolean;
  readonly statusCode?: number;
};

// @public (undocumented)
export type RequestErrorReason =
  | 'clientAbortedRequest'
  | 'clientOffline'
  | 'clientTimeoutRequest'
  | 'serverBadGateway'
  | 'serverBadRequest'
  | 'serverForbidden'
  | 'serverInternalError'
  | 'serverInvalidBody'
  | 'serverNotFound'
  | 'serverRateLimited'
  | 'serverUnauthorized'
  | 'serverUnexpectedError';

// @public (undocumented)
export type RequestHeaders = {
  [key: string]: string;
};

// @public (undocumented)
export type RequestMetadata = {
  readonly method?: RequestMethod;
  readonly endpoint?: string;
  readonly mediaRegion?: string;
  readonly mediaEnv?: string;
  readonly traceContext?: MediaTraceContext;
};

// @public (undocumented)
export type RequestMethod = 'DELETE' | 'GET' | 'POST' | 'PUT';

// @public (undocumented)
export type RequestOptions = RequestMetadata & {
  readonly auth?: Auth;
  readonly traceContext?: Required<MediaTraceContext>;
  readonly params?: RequestParams;
  readonly headers?: RequestHeaders;
  readonly body?: any;
  readonly clientOptions?: ClientOptions;
};

// @public (undocumented)
export type RequestParams = {
  [key: string]: any;
};

// @public (undocumented)
export interface ResponseFileItem {
  // (undocumented)
  collection?: string;
  // (undocumented)
  details: MediaItemDetails;
  // (undocumented)
  id: string;
  // (undocumented)
  metadataTraceContext?: MediaTraceContext;
  // (undocumented)
  type: 'file';
}

// @public (undocumented)
export type RetryOptions = {
  readonly startTimeoutInMs: number;
  readonly maxAttempts: number;
  readonly factor: number;
};

// @public (undocumented)
export const safeUnsubscribe: (subscription: MediaSubscription) => void;

// @public (undocumented)
export interface SourceFile {
  // (undocumented)
  collection?: string;
  // (undocumented)
  id: string;
  // (undocumented)
  owner: AsapBasedAuth | ClientAltBasedAuth;
  // (undocumented)
  version?: number;
}

// @public (undocumented)
export class StargateClient {
  constructor(baseUrl: string | undefined);
  // (undocumented)
  fetchToken(clientId: string): Promise<EdgeData>;
  // (undocumented)
  isTokenExpired(token: EdgeData): boolean;
}

// @public (undocumented)
export type TouchedFiles = {
  created: CreatedTouchedFile[];
  rejected?: RejectedTouchFile[];
};

// @public (undocumented)
export interface TouchFileDescriptor {
  // (undocumented)
  collection?: string;
  // (undocumented)
  deletable?: boolean;
  // (undocumented)
  expireAfter?: number;
  // (undocumented)
  fileId: string;
  // (undocumented)
  occurrenceKey?: string;
  // (undocumented)
  size?: number;
}

// @public (undocumented)
export type UploadableFile = {
  content: ChunkinatorFile;
  name?: string;
  mimeType?: string;
  collection?: string;
  size?: number;
};

// @public (undocumented)
export type UploadableFileUpfrontIds = {
  id: string;
  deferredUploadId: Promise<string>;
  occurrenceKey?: string;
};

// @public (undocumented)
export class UploadController {
  constructor();
  // (undocumented)
  abort(): void;
  // (undocumented)
  abortFunction?: AbortFunction;
  // (undocumented)
  setAbort(abortFunction: AbortFunction): void;
}

// @public (undocumented)
export type UploadEventPayloadMap = {
  'file-added': FileState;
  'media-viewed': MediaViewedEventPayload;
};

// @public (undocumented)
export const uploadFile: (
  file: UploadableFile,
  store: MediaStore,
  uploadableFileUpfrontIds: UploadableFileUpfrontIds,
  callbacks?: UploadFileCallbacks,
  traceContext?: MediaTraceContext,
) => UploadFileResult;

// @public (undocumented)
export type UploadFileCallbacks = {
  onProgress: (progress: number) => void;
  onUploadFinish: (error?: any) => void;
};

// @public (undocumented)
export interface UploadFileResult {
  // (undocumented)
  cancel: () => void;
}

// @public (undocumented)
export interface UploadingFileState extends BaseFileState {
  // (undocumented)
  createdAt?: number;
  // (undocumented)
  id: string;
  // (undocumented)
  mediaType: MediaType;
  // (undocumented)
  mimeType: string;
  // (undocumented)
  name: string;
  // (undocumented)
  occurrenceKey?: string;
  // (undocumented)
  preview?: FilePreview | Promise<FilePreview>;
  // (undocumented)
  progress: number;
  // (undocumented)
  size: number;
  // (undocumented)
  status: 'uploading';
}

// @public (undocumented)
export interface WithMediaClient {
  // (undocumented)
  identifier?: Identifier;
  // (undocumented)
  mediaClient: MediaClient;
}

// @public (undocumented)
export const withMediaClient: WithMediaClientFunction;

// @public (undocumented)
export interface WithMediaClientConfig {
  // (undocumented)
  mediaClientConfig: MediaClientConfig;
}

// @public (undocumented)
export type WithMediaClientConfigProps<P extends WithMediaClient> = Omit<
  P,
  'mediaClient'
> &
  WithMediaClientConfig;

// @public (undocumented)
export type WithMediaClientFunction = <P extends WithMediaClient>(
  Component: React_2.ComponentType<P>,
  featureFlags?: MediaFeatureFlags,
) => React_2.ComponentType<WithMediaClientConfigProps<P>>;

// (No @packageDocumentation comment for this package)
```

<!--SECTION END: Main Entry Types-->

### Peer Dependencies

<!--SECTION START: Peer Dependencies-->

```json
{
  "@atlaskit/media-core": "^34.1.2",
  "@emotion/react": "^11.7.1",
  "enzyme": ">=3.10.0",
  "react": "^16.8.0"
}
```

<!--SECTION END: Peer Dependencies-->
