## API Report File for "@atlaskit/media-client"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import { AsapBasedAuth } from '@atlaskit/media-core';
import { Auth } from '@atlaskit/media-core';
import { AuthContext } from '@atlaskit/media-core';
import { AuthProvider } from '@atlaskit/media-core';
import { ChunkinatorFile } from '@atlaskit/chunkinator';
import { ClientAltBasedAuth } from '@atlaskit/media-core';
import { FileStatus as FileStatus_2 } from '@atlaskit/media-common';
import { LRUCache } from 'lru-fast';
import { MediaApiConfig } from '@atlaskit/media-core';
import { MediaClientConfig } from '@atlaskit/media-core';
import { MediaFeatureFlags } from '@atlaskit/media-common';
import { MediaType } from '@atlaskit/media-common';
import { default as React_2 } from 'react';
import { ReplaySubject } from 'rxjs/ReplaySubject';

// @public (undocumented)
export type AbortFunction = () => void;

// @public (undocumented)
export const addFileAttrsToUrl: (
  url: string,
  fileAttrs: MediaBlobUrlAttrs,
) => string;

// @public (undocumented)
export type AppendChunksToUploadRequestBody = {
  readonly chunks: string[];
  readonly hash?: string;
  readonly offset?: number;
};

// @public (undocumented)
export type Artifacts = {
  [name: string]: MediaArtifact;
};

// @public (undocumented)
export const checkWebpSupport: () => Promise<boolean>;

// @public (undocumented)
export type ClientOptions = {
  readonly retryOptions?: Partial<RetryOptions>;
  readonly clientTimeout?: number;
};

// @public (undocumented)
export class CollectionFetcher {
  constructor(mediaStore: MediaStore);
  // (undocumented)
  getItems(
    collectionName: string,
    params?: MediaStoreGetCollectionItemsParams,
  ): MediaSubscribable<MediaCollectionItem[]>;
  // (undocumented)
  loadNextPage(
    collectionName: string,
    params?: MediaStoreGetCollectionItemsParams,
  ): Promise<void>;
  // (undocumented)
  readonly mediaStore: MediaStore;
  // (undocumented)
  removeFile(
    id: string,
    collectionName: string,
    occurrenceKey?: string,
  ): Promise<void>;
}

// @public (undocumented)
export interface CopyDestination extends MediaStoreCopyFileWithTokenParams {
  // (undocumented)
  authProvider: AuthProvider;
  // (undocumented)
  mediaStore?: MediaStore;
}

// @public (undocumented)
export interface CopyFileOptions {
  // (undocumented)
  mimeType?: string;
  // (undocumented)
  preview?: FilePreview | Promise<FilePreview>;
}

// @public (undocumented)
export interface CopySourceFile {
  // (undocumented)
  authProvider: AuthProvider;
  // (undocumented)
  collection?: string;
  // (undocumented)
  id: string;
}

// @public (undocumented)
export interface CreatedTouchedFile {
  // (undocumented)
  fileId: string;
  // (undocumented)
  uploadId: string;
}

// @public (undocumented)
export function createMediaSubject<T extends MediaSubscribableItem>(
  initialState?: T | Error,
): ReplaySubject<T>;

// @public (undocumented)
export function createMediaSubscribable<T extends MediaSubscribableItem>(
  mediaSubscribableItem?: T | Error,
): MediaSubscribable<T>;

// @public (undocumented)
export function createUrl(
  url: string,
  { params, auth }: CreateUrlOptions,
): string;

// @public (undocumented)
export type CreateUrlOptions = {
  readonly params?: RequestParams;
  readonly auth?: Auth;
};

// @public (undocumented)
export type Dimensions = {
  width: number;
  height: number;
};

// @public (undocumented)
export interface EdgeData {
  // (undocumented)
  data: {
    clientId: string;
    token: string;
    baseUrl: string;
    expiresIn: number;
    iat: number;
  };
}

// @public (undocumented)
export interface EmptyFile {
  // (undocumented)
  readonly createdAt: number;
  // (undocumented)
  readonly id: string;
}

// @public (undocumented)
export interface ErrorFileState {
  // (undocumented)
  id: string;
  // (undocumented)
  message?: string;
  // (undocumented)
  occurrenceKey?: string;
  // (undocumented)
  status: 'error';
}

// @public (undocumented)
export type EventPayloadListener<
  M extends EventPayloadMap<P>,
  E extends keyof M,
  P = any
> = (payload: M[E]) => void;

// @public (undocumented)
export type Executor = () => Promise<void>;

// @public (undocumented)
export interface ExternalImageIdentifier {
  // (undocumented)
  readonly dataURI: string;
  // (undocumented)
  readonly mediaItemType: 'external-image';
  // (undocumented)
  readonly name?: string;
}

// @public (undocumented)
export interface FileDetails {
  // (undocumented)
  artifacts?: Artifacts;
  // (undocumented)
  createdAt?: number;
  // (undocumented)
  creationDate?: number;
  // (undocumented)
  id: string;
  // (undocumented)
  mediaType?: MediaType;
  // (undocumented)
  mimeType?: string;
  // (undocumented)
  name?: string;
  // (undocumented)
  processingStatus?: FileProcessingStatus;
  // (undocumented)
  size?: number;
}

// @public (undocumented)
export interface FileFetcher {
  // (undocumented)
  copyFile(
    source: CopySourceFile,
    destination: CopyDestination,
    options?: CopyFileOptions,
  ): Promise<MediaFile>;
  // (undocumented)
  downloadBinary(
    id: string,
    name?: string,
    collectionName?: string,
  ): Promise<void>;
  // (undocumented)
  getArtifactURL(
    artifacts: MediaFileArtifacts,
    artifactName: keyof MediaFileArtifacts,
    collectionName?: string,
  ): Promise<string>;
  // (undocumented)
  getCurrentState(id: string, options?: GetFileOptions): Promise<FileState>;
  // (undocumented)
  getFileBinaryURL(id: string, collectionName?: string): Promise<string>;
  // (undocumented)
  getFileState(
    id: string,
    options?: GetFileOptions,
  ): MediaSubscribable<FileState>;
  // (undocumented)
  touchFiles(
    descriptors: TouchFileDescriptor[],
    collection?: string,
  ): Promise<TouchedFiles>;
  // (undocumented)
  upload(
    file: UploadableFile,
    controller?: UploadController,
    uploadableFileUpfrontIds?: UploadableFileUpfrontIds,
  ): MediaSubscribable<FileState>;
  // (undocumented)
  uploadExternal(
    url: string,
    collection?: string,
  ): Promise<ExternalUploadPayload>;
}

// @public (undocumented)
export class FileFetcherError extends BaseMediaClientError<
  FileFetcherErrorAttributes
> {
  constructor(
    reason: FileFetcherErrorReason,
    id: string,
    metadata?:
      | {
          readonly collectionName?: string | undefined;
          readonly occurrenceKey?: string | undefined;
        }
      | undefined,
  );
  // (undocumented)
  get attributes(): {
    reason: FileFetcherErrorReason;
    id: string;
    collectionName: string | undefined;
    occurrenceKey: string | undefined;
  };
  // (undocumented)
  readonly id: string;
  // (undocumented)
  readonly metadata?:
    | {
        readonly collectionName?: string | undefined;
        readonly occurrenceKey?: string | undefined;
      }
    | undefined;
  // (undocumented)
  readonly reason: FileFetcherErrorReason;
}

// @public (undocumented)
export type FileFetcherErrorAttributes = {
  readonly reason: FileFetcherErrorReason;
  readonly id: string;
  readonly metadata?: {
    readonly collectionName?: string;
    readonly occurrenceKey?: string;
  };
};

// @public (undocumented)
export type FileFetcherErrorReason =
  | 'invalidFileId'
  | 'emptyItems'
  | 'zeroVersionFile';

// @public (undocumented)
export class FileFetcherImpl implements FileFetcher {
  constructor(mediaStore: MediaStore);
  // (undocumented)
  copyFile(
    source: CopySourceFile,
    destination: CopyDestination,
    options?: CopyFileOptions,
  ): Promise<MediaFile>;
  // (undocumented)
  downloadBinary(
    id: string,
    name?: string,
    collectionName?: string,
  ): Promise<void>;
  // (undocumented)
  getArtifactURL(
    artifacts: MediaFileArtifacts,
    artifactName: keyof MediaFileArtifacts,
    collectionName?: string,
  ): Promise<string>;
  // (undocumented)
  getCurrentState(id: string, options?: GetFileOptions): Promise<FileState>;
  // (undocumented)
  getFileBinaryURL(id: string, collectionName?: string): Promise<string>;
  // (undocumented)
  getFileState(
    id: string,
    options?: GetFileOptions,
  ): MediaSubscribable<FileState>;
  // (undocumented)
  touchFiles(
    descriptors: TouchFileDescriptor[],
    collection?: string,
  ): Promise<TouchedFiles>;
  // (undocumented)
  upload(
    file: UploadableFile,
    controller?: UploadController,
    uploadableFileUpfrontIds?: UploadableFileUpfrontIds,
  ): MediaSubscribable<FileState>;
  // (undocumented)
  uploadExternal(
    url: string,
    collection?: string,
  ): Promise<ExternalUploadPayload>;
}

// @public (undocumented)
export interface FileIdentifier {
  // (undocumented)
  readonly collectionName?: string;
  // (undocumented)
  readonly id: string;
  // (undocumented)
  readonly mediaItemType: 'file';
  // (undocumented)
  readonly occurrenceKey?: string;
}

// @public (undocumented)
export interface FileItem {
  // (undocumented)
  details: FileDetails;
  // (undocumented)
  type: 'file';
}

// @public (undocumented)
export interface FilePreview {
  // (undocumented)
  origin?: 'local' | 'remote';
  // (undocumented)
  originalDimensions?: {
    width: number;
    height: number;
  };
  // (undocumented)
  value: Blob | string;
}

// @public (undocumented)
export type FileProcessingStatus =
  | 'pending'
  | 'running'
  | 'succeeded'
  | 'failed';

// @public (undocumented)
export type FileState =
  | UploadingFileState
  | ProcessingFileState
  | ProcessedFileState
  | ErrorFileState
  | ProcessingFailedState;

// @public (undocumented)
export type FileStatus = FileStatus_2;

// @public (undocumented)
export const getArtifactUrl: (
  artifacts: MediaFileArtifacts,
  prop: keyof MediaFileArtifacts,
) => string | undefined;

// @public (undocumented)
export const getAttrsFromUrl: (
  blobUrl: string,
) => MediaBlobUrlAttrs | undefined;

// @public (undocumented)
export const getDimensionsFromBlob: (
  mediaType: MediaType,
  blob: Blob,
) => Promise<Dimensions>;

// @public (undocumented)
export interface GetFileOptions {
  // (undocumented)
  collectionName?: string;
  // (undocumented)
  occurrenceKey?: string;
  // (undocumented)
  preview?: PreviewOptions;
}

// @public (undocumented)
export const getMediaClient: (
  mediaClientConfig: MediaClientConfig,
  featureFlags?: MediaFeatureFlags | undefined,
) => MediaClient;

// @public (undocumented)
export function getMediaClientErrorReason(
  err: Error,
): MediaClientErrorReason | 'unknown';

// @public (undocumented)
export const getMediaEnvironment: () => string | undefined;

// @public (undocumented)
export const getMediaRegion: () => string | undefined;

// @public @deprecated (undocumented)
export const getMediaTypeFromMimeType: (mimeType: string) => MediaType;

// @public (undocumented)
export const globalMediaEventEmitter: {
  on<E extends keyof UploadEventPayloadMap>(
    event: E,
    listener: EventPayloadListener<UploadEventPayloadMap, E, any>,
  ): void;
  off<E_1 extends keyof UploadEventPayloadMap>(
    event: E_1,
    listener: EventPayloadListener<UploadEventPayloadMap, E_1, any>,
  ): void;
  emit<E_2 extends keyof UploadEventPayloadMap>(
    event: E_2,
    payload: UploadEventPayloadMap[E_2],
  ): boolean | undefined;
};

// @public (undocumented)
export type Identifier = FileIdentifier | ExternalImageIdentifier;

// @public (undocumented)
export interface ImageMetadata {
  // (undocumented)
  original?: ImageMetadataArtifact;
  // (undocumented)
  pending: boolean;
  // (undocumented)
  preview?: ImageMetadataArtifact;
}

// @public (undocumented)
export type ImageMetadataArtifact = {
  url?: string;
  width?: number;
  height?: number;
  size?: number;
};

// @public (undocumented)
export type ImageResizeMode = 'crop' | 'fit' | 'full-fit' | 'stretchy-fit';

// @public (undocumented)
export const imageResizeModeToFileImageMode: (
  resizeMode?: ImageResizeMode | undefined,
) => MediaStoreGetFileImageParams['mode'];

// @public (undocumented)
export function isAbortedRequestError(err: any): boolean;

// @public @deprecated (undocumented)
export const isAudioMimeTypeSupportedByServer: (mimeType: string) => boolean;

// @public (undocumented)
export const isDifferentIdentifier: (a: Identifier, b: Identifier) => boolean;

// @public @deprecated (undocumented)
export const isDocumentMimeTypeSupportedByBrowser: (
  mimeType: string,
) => boolean;

// @public @deprecated (undocumented)
export const isDocumentMimeTypeSupportedByServer: (mimeType: string) => boolean;

// @public (undocumented)
export const isErrorFileState: (
  fileState: FileState,
) => fileState is ErrorFileState;

// @public (undocumented)
export const isExternalImageIdentifier: (
  identifier: Identifier,
) => identifier is ExternalImageIdentifier;

// @public (undocumented)
export function isFileFetcherError(err: Error): err is FileFetcherError;

// @public (undocumented)
export const isFileIdentifier: (
  identifier: Identifier,
) => identifier is FileIdentifier;

// @public (undocumented)
export const isFinalFileState: (
  fileState: FileState,
) => fileState is ProcessedFileState | ProcessingFailedState | ErrorFileState;

// @public @deprecated (undocumented)
export const isImageMimeTypeSupportedByBrowser: (mimeType: string) => boolean;

// @public @deprecated (undocumented)
export const isImageMimeTypeSupportedByServer: (mimeType: string) => boolean;

// @public (undocumented)
export const isImageRemote: (
  imageUrl: string,
  windowOrigin?: string,
) => boolean;

// @public (undocumented)
export const isImageRepresentationReady: (fileState: FileState) => boolean;

// @public (undocumented)
export const isMediaBlobUrl: (url: string) => boolean;

// @public (undocumented)
export function isMediaClientError(
  error: any,
): error is MediaClientError<{
  reason: MediaClientErrorReason;
}>;

// @public (undocumented)
export const isMediaCollectionItemFullDetails: (
  mediaCollectionItem: MediaCollectionItemDetails,
) => mediaCollectionItem is MediaCollectionItemFullDetails;

// @public (undocumented)
export function isMediaStoreError(err: Error): err is MediaStoreError;

// @public @deprecated (undocumented)
export const isMimeTypeSupportedByBrowser: (mimeType: string) => boolean;

// @public @deprecated (undocumented)
export const isMimeTypeSupportedByServer: (mimeType: string) => boolean;

// @public (undocumented)
export function isPollingError(err?: Error): err is PollingError;

// @public (undocumented)
export const isPreviewableFileState: (
  fileState: FileState,
) => fileState is (
  | UploadingFileState
  | ProcessingFileState
  | ProcessedFileState
  | ProcessingFailedState
) &
  PreviewableFileState;

// @public (undocumented)
export const isPreviewableType: (
  type: MediaType,
  featureFlags?: MediaFeatureFlags | undefined,
) => boolean;

// @public (undocumented)
export const isProcessedFileState: (
  fileState: FileState,
) => fileState is ProcessedFileState;

// @public (undocumented)
export const isProcessingFileState: (
  fileState: FileState,
) => fileState is ProcessingFileState;

// @public (undocumented)
export function isRateLimitedError(error: Error | undefined): boolean;

// @public (undocumented)
export function isRequestError(err: Error): err is RequestError;

// @public @deprecated (undocumented)
export const isUnknownMimeTypeSupportedByServer: (mimeType: string) => boolean;

// @public (undocumented)
export const isUploadingFileState: (
  fileState: FileState,
) => fileState is UploadingFileState;

// @public @deprecated (undocumented)
export const isVideoMimeTypeSupportedByServer: (mimeType: string) => boolean;

// @public (undocumented)
export interface ItemsPayload {
  // (undocumented)
  items: ResponseFileItem[];
}

// @public (undocumented)
export const mapMediaFileToFileState: (
  mediaFile: MediaStoreResponse<MediaFile>,
) => FileState;

// @public (undocumented)
export const mapMediaItemToFileState: (
  id: string,
  item: MediaCollectionItemFullDetails,
) => FileState;

// @public @deprecated (undocumented)
export function mapResponseToBlob(response: Response): Promise<Blob>;

// @public @deprecated (undocumented)
export function mapResponseToJson(response: Response): Promise<any>;

// @public @deprecated (undocumented)
export function mapResponseToVoid(): Promise<void>;

// @public (undocumented)
export const MAX_RESOLUTION = 4096;

// @public (undocumented)
export interface MediaArtifact {
  // (undocumented)
  processingStatus?: FileProcessingStatus;
  // (undocumented)
  url?: string;
}

// @public (undocumented)
export interface MediaBlobUrlAttrs {
  // (undocumented)
  alt?: string;
  // (undocumented)
  collection?: string;
  // (undocumented)
  contextId: string;
  // (undocumented)
  height?: number;
  // (undocumented)
  id: string;
  // (undocumented)
  mimeType?: string;
  // (undocumented)
  name?: string;
  // (undocumented)
  size?: number;
  // (undocumented)
  width?: number;
}

// @public (undocumented)
export type MediaChunksProbe = {
  readonly results: {
    readonly [etag: string]: {
      readonly exists: boolean;
    };
  };
};

// @public (undocumented)
export class MediaClient {
  constructor(
    mediaClientConfig: MediaClientConfig,
    featureFlags?: MediaFeatureFlags | undefined,
  );
  // (undocumented)
  readonly collection: CollectionFetcher;
  // (undocumented)
  readonly config: MediaClientConfig;
  // (undocumented)
  emit<E extends keyof UploadEventPayloadMap>(
    event: E,
    payload: UploadEventPayloadMap[E],
  ): boolean;
  // (undocumented)
  readonly featureFlags?: MediaFeatureFlags | undefined;
  // (undocumented)
  readonly file: FileFetcher;
  // (undocumented)
  getImage(
    id: string,
    params?: MediaStoreGetFileImageParams,
    controller?: AbortController,
    fetchMaxRes?: boolean,
  ): Promise<Blob>;
  // (undocumented)
  getImageMetadata(
    id: string,
    params?: MediaStoreGetFileImageParams,
  ): Promise<ImageMetadata>;
  // (undocumented)
  getImageUrl(
    id: string,
    params?: MediaStoreGetFileImageParams,
  ): Promise<string>;
  // (undocumented)
  getImageUrlSync(id: string, params?: MediaStoreGetFileImageParams): string;
  // (undocumented)
  readonly mediaClientConfig: MediaClientConfig;
  // (undocumented)
  readonly mediaStore: MediaStore;
  // (undocumented)
  mobileUploadPromise(): Promise<MobileUpload>;
  // (undocumented)
  off<E extends keyof UploadEventPayloadMap>(
    event: E,
    listener: EventPayloadListener<UploadEventPayloadMap, E>,
  ): void;
  // (undocumented)
  on<E extends keyof UploadEventPayloadMap>(
    event: E,
    listener: EventPayloadListener<UploadEventPayloadMap, E>,
  ): void;
  // (undocumented)
  readonly stargate: StargateClient;
}

// @public
export interface MediaClientError<Attributes extends MediaClientErrorAttributes>
  extends Error {
  // (undocumented)
  readonly attributes: Attributes;
}

// @public (undocumented)
export interface MediaClientErrorAttributes {
  // (undocumented)
  reason: MediaClientErrorReason;
}

// @public (undocumented)
export type MediaClientErrorReason =
  | 'clientOffline'
  | 'clientAbortedRequest'
  | 'clientTimeoutRequest'
  | 'serverInvalidBody'
  | 'serverBadRequest'
  | 'serverUnauthorized'
  | 'serverForbidden'
  | 'serverNotFound'
  | 'serverRateLimited'
  | 'serverInternalError'
  | 'serverBadGateway'
  | 'serverUnexpectedError'
  | 'failedAuthProvider'
  | 'tokenExpired'
  | 'missingInitialAuth'
  | 'emptyAuth'
  | 'authProviderTimedOut'
  | 'invalidFileId'
  | 'emptyItems'
  | 'zeroVersionFile'
  | 'pollingMaxAttemptsExceeded'
  | 'fileSizeExceedsLimit';

// @public (undocumented)
export type MediaCollection = {
  readonly name: string;
  readonly createdAt: number;
};

// @public (undocumented)
export type MediaCollectionItem = {
  readonly id: string;
  readonly insertedAt: number;
  readonly occurrenceKey: string;
  readonly details: MediaCollectionItemDetails;
};

// @public (undocumented)
export type MediaCollectionItemDetails =
  | MediaCollectionItemMinimalDetails
  | MediaCollectionItemFullDetails;

// @public (undocumented)
export type MediaCollectionItemFullDetails = {
  readonly mediaType: MediaType;
  readonly mimeType: string;
  readonly name: string;
  readonly processingStatus: MediaFileProcessingStatus;
  readonly size: number;
  readonly artifacts: MediaFileArtifacts;
  readonly representations: MediaRepresentations;
  readonly createdAt?: number;
};

// @public (undocumented)
export type MediaCollectionItemMinimalDetails = {
  readonly name: string;
  readonly size: number;
};

// @public (undocumented)
export type MediaCollectionItems = {
  readonly contents: MediaCollectionItem[];
  readonly nextInclusiveStartKey?: string;
};

// @public (undocumented)
export type MediaFile = {
  readonly id: string;
  readonly mediaType: MediaType;
  readonly mimeType: string;
  readonly name: string;
  readonly processingStatus?: MediaFileProcessingStatus;
  readonly size: number;
  readonly artifacts: MediaFileArtifacts;
  readonly representations: MediaRepresentations;
  readonly createdAt?: number;
};

// @public (undocumented)
export type MediaFileArtifact = {
  readonly url: string;
  readonly processingStatus: MediaFileProcessingStatus;
};

// @public (undocumented)
export interface MediaFileArtifacts {
  // (undocumented)
  'audio.mp3'?: MediaFileArtifact;
  // (undocumented)
  'document.pdf'?: MediaFileArtifact;
  // (undocumented)
  'video_1280.mp4'?: MediaFileArtifact;
  // (undocumented)
  'video_640.mp4'?: MediaFileArtifact;
}

// @public (undocumented)
export type MediaFileProcessingStatus = 'pending' | 'succeeded' | 'failed';

// @public (undocumented)
export type MediaItemType = 'file' | 'external-image';

// @public (undocumented)
export type MediaObserver<T extends MediaSubscribableItem> =
  | NextObserver<T>
  | ErrorObserver<T>
  | CompletionObserver<T>
  | ((value: T) => void);

// @public (undocumented)
export type MediaRepresentations = {
  image?: Object;
};

// @public (undocumented)
export class MediaStore {
  constructor(
    config: MediaApiConfig,
    featureFlags?: MediaFeatureFlags | undefined,
  );
  // (undocumented)
  appendChunksToUpload(
    uploadId: string,
    body: AppendChunksToUploadRequestBody,
    collectionName?: string,
  ): Promise<void>;
  // (undocumented)
  copyFileWithToken(
    body: MediaStoreCopyFileWithTokenBody,
    params: MediaStoreCopyFileWithTokenParams,
  ): Promise<MediaStoreResponse<MediaFile>>;
  // (undocumented)
  createFileFromUpload(
    body: MediaStoreCreateFileFromUploadBody,
    params?: MediaStoreCreateFileFromUploadParams,
  ): Promise<MediaStoreResponse<MediaFile>>;
  // (undocumented)
  createUpload(
    createUpTo?: number,
    collectionName?: string,
  ): Promise<MediaStoreResponse<MediaUpload[]>>;
  // (undocumented)
  readonly featureFlags?: MediaFeatureFlags | undefined;
  // (undocumented)
  getArtifactURL(
    artifacts: MediaFileArtifacts,
    artifactName: keyof MediaFileArtifacts,
    collectionName?: string,
  ): Promise<string>;
  // (undocumented)
  getCollectionItems(
    collectionName: string,
    params?: MediaStoreGetCollectionItemsParams,
  ): Promise<MediaStoreResponse<MediaCollectionItems>>;
  // (undocumented)
  getFile(
    fileId: string,
    params?: MediaStoreGetFileParams,
  ): Promise<MediaStoreResponse<MediaFile>>;
  // (undocumented)
  getFileBinaryURL(id: string, collectionName?: string): Promise<string>;
  // (undocumented)
  getFileImageURL(
    id: string,
    params?: MediaStoreGetFileImageParams,
  ): Promise<string>;
  // (undocumented)
  getFileImageURLSync(
    id: string,
    params?: MediaStoreGetFileImageParams,
  ): string;
  // (undocumented)
  getImage(
    id: string,
    params?: MediaStoreGetFileImageParams,
    controller?: AbortController,
    fetchMaxRes?: boolean,
  ): Promise<Blob>;
  // (undocumented)
  getImageMetadata(
    id: string,
    params?: MediaStoreGetFileImageParams,
  ): Promise<{
    metadata: ImageMetadata;
  }>;
  // (undocumented)
  getItems(
    ids: string[],
    collectionName?: string,
  ): Promise<MediaStoreResponse<ItemsPayload>>;
  // (undocumented)
  probeChunks(
    chunks: string[],
    {
      collectionName,
      uploadId,
    }?: {
      collectionName?: string;
      uploadId?: string;
    },
  ): Promise<MediaStoreResponse<MediaChunksProbe>>;
  // (undocumented)
  removeCollectionFile(
    id: string,
    collectionName: string,
    occurrenceKey?: string,
  ): Promise<void>;
  // (undocumented)
  request(
    path: string,
    options?: MediaStoreRequestOptions,
    controller?: AbortController,
  ): Promise<Response>;
  // (undocumented)
  resolveAuth: (authContext?: AuthContext | undefined) => Promise<Auth>;
  // (undocumented)
  resolveInitialAuth: () => Auth;
  // (undocumented)
  touchFiles(
    body: MediaStoreTouchFileBody,
    params?: MediaStoreTouchFileParams,
  ): Promise<MediaStoreResponse<TouchedFiles>>;
  // (undocumented)
  uploadChunk(
    etag: string,
    blob: Blob,
    {
      collectionName,
      uploadId,
      partNumber,
    }?: {
      collectionName?: string;
      uploadId?: string;
      partNumber?: number;
    },
  ): Promise<void>;
}

// @public (undocumented)
export type MediaStoreCopyFileWithTokenBody = {
  sourceFile: SourceFile;
};

// @public (undocumented)
export type MediaStoreCopyFileWithTokenParams = {
  readonly collection?: string;
  readonly replaceFileId?: string;
  readonly occurrenceKey?: string;
};

// @public (undocumented)
export type MediaStoreCreateFileFromBinaryParams = {
  readonly replaceFileId?: string;
  readonly collection?: string;
  readonly occurrenceKey?: string;
  readonly expireAfter?: number;
  readonly skipConversions?: boolean;
  readonly name?: string;
};

// @public (undocumented)
export type MediaStoreCreateFileFromUploadBody = {
  readonly uploadId: string;
  readonly name?: string;
  readonly mimeType?: string;
  readonly conditions?: MediaStoreCreateFileFromUploadConditions;
};

// @public (undocumented)
export type MediaStoreCreateFileFromUploadConditions = {
  readonly hash: string;
  readonly size: number;
};

// @public (undocumented)
export type MediaStoreCreateFileFromUploadParams = {
  readonly collection?: string;
  readonly occurrenceKey?: string;
  readonly expireAfter?: number;
  readonly replaceFileId?: string;
  readonly skipConversions?: boolean;
};

// @public (undocumented)
export type MediaStoreCreateFileParams = {
  readonly occurrenceKey?: string;
  readonly collection?: string;
};

// @public (undocumented)
export class MediaStoreError extends BaseMediaClientError<
  MediaStoreErrorAttributes
> {
  constructor(reason: MediaStoreErrorReason, innerError?: Error | undefined);
  // (undocumented)
  get attributes(): {
    reason: MediaStoreErrorReason;
    innerError: Error | undefined;
  };
  // (undocumented)
  readonly innerError?: Error | undefined;
  // (undocumented)
  readonly reason: MediaStoreErrorReason;
}

// @public (undocumented)
export type MediaStoreErrorAttributes = {
  readonly reason: MediaStoreErrorReason;
  readonly innerError?: Error;
};

// @public (undocumented)
export type MediaStoreErrorReason =
  | 'failedAuthProvider'
  | 'tokenExpired'
  | 'missingInitialAuth'
  | 'emptyAuth'
  | 'authProviderTimedOut';

// @public (undocumented)
export type MediaStoreGetCollectionItemsParams = {
  readonly limit?: number;
  readonly inclusiveStartKey?: string;
  readonly sortDirection?: 'asc' | 'desc';
  readonly details?: 'minimal' | 'full';
};

// @public (undocumented)
export type MediaStoreGetFileImageParams = {
  readonly allowAnimated?: boolean;
  readonly version?: number;
  readonly collection?: string;
  readonly width?: number;
  readonly height?: number;
  readonly mode?: 'fit' | 'full-fit' | 'crop';
  readonly upscale?: boolean;
  readonly 'max-age'?: number;
};

// @public (undocumented)
export type MediaStoreGetFileParams = {
  readonly version?: number;
  readonly collection?: string;
};

// @public (undocumented)
export type MediaStoreRequestOptions = RequestMetadata & {
  readonly method?: RequestMethod;
  readonly authContext?: AuthContext;
  readonly params?: RequestParams;
  readonly headers?: RequestHeaders;
  readonly body?: any;
  readonly clientOptions?: ClientOptions;
};

// @public (undocumented)
export interface MediaStoreResponse<Data> {
  // (undocumented)
  readonly data: Data;
}

// @public (undocumented)
export interface MediaStoreTouchFileBody {
  // (undocumented)
  descriptors: TouchFileDescriptor[];
}

// @public (undocumented)
export interface MediaStoreTouchFileParams {
  // (undocumented)
  readonly collection?: string;
}

// @public (undocumented)
export type MediaSubscribable<T extends MediaSubscribableItem> = {
  subscribe(observer?: MediaObserver<T>): MediaSubscription;
};

// @public (undocumented)
export type MediaSubscribableItem = FileState | MediaCollectionItem[];

// @public (undocumented)
export type MediaSubscription = {
  unsubscribe: () => void;
};

export { MediaType };

// @public (undocumented)
export type MediaUpload = {
  readonly id: string;
  readonly created: number;
  readonly expires: number;
};

// @public (undocumented)
export interface MediaViewedEventPayload {
  // (undocumented)
  fileId: string;
  // (undocumented)
  isUserCollection?: boolean;
  // (undocumented)
  viewingLevel: 'minimal' | 'full' | 'download';
}

// @public (undocumented)
export type MobileUploadEndEvent = {
  fileId: string;
};

// @public (undocumented)
export type MobileUploadErrorEvent = {
  fileId: string;
  message: string;
};

// @public (undocumented)
export type MobileUploadProgressEvent = {
  fileId: string;
  progress: number;
};

// @public (undocumented)
export type MobileUploadStartEvent = {
  fileId: string;
  collectionName?: string;
  occurrenceKey?: string;
  fileName: string;
  fileSize: number;
  fileMimetype: string;
  preview?: FilePreview;
  createdAt?: number;
};

// @public (undocumented)
export type NonErrorFileState = Exclude<FileState, ErrorFileState>;

// @public (undocumented)
export const objectToQueryString: (json: {
  [key: string]: string | number | boolean | null | undefined;
}) => string;

// @public (undocumented)
export class PollingError extends BaseMediaClientError<PollingErrorAttributes> {
  constructor(reason: PollingErrorReason, attempts: number);
  // (undocumented)
  readonly attempts: number;
  // (undocumented)
  get attributes(): {
    reason: 'pollingMaxAttemptsExceeded';
    attempts: number;
  };
  // (undocumented)
  readonly reason: PollingErrorReason;
}

// @public (undocumented)
export type PollingErrorAttributes = {
  readonly reason: PollingErrorReason;
  readonly attempts: number;
  readonly innerError?: Error;
};

// @public (undocumented)
export type PollingErrorReason = 'pollingMaxAttemptsExceeded';

// @public
export class PollingFunction {
  constructor(options?: Partial<PollingOptions>);
  // (undocumented)
  attempt: number;
  // (undocumented)
  cancel(): void;
  // (undocumented)
  execute(executor: Executor): Promise<void>;
  // (undocumented)
  getIntervalMsForIteration(iteration: number): number;
  // (undocumented)
  next(): void;
  // (undocumented)
  onError?: (error: Error) => void;
  // (undocumented)
  options: PollingOptions;
  // (undocumented)
  poll_intervalMs: number;
  // (undocumented)
  shouldIterate: boolean;
  // (undocumented)
  timeoutId: number;
}

// @public (undocumented)
export interface PreviewableFileState {
  // (undocumented)
  preview: FilePreview | Promise<FilePreview>;
}

// @public (undocumented)
export interface PreviewOptions {}

// @public (undocumented)
export interface ProcessedFileState {
  // (undocumented)
  artifacts: MediaFileArtifacts;
  // (undocumented)
  createdAt?: number;
  // (undocumented)
  id: string;
  // (undocumented)
  mediaType: MediaType;
  // (undocumented)
  mimeType: string;
  // (undocumented)
  name: string;
  // (undocumented)
  occurrenceKey?: string;
  // (undocumented)
  preview?: FilePreview | Promise<FilePreview>;
  // (undocumented)
  representations?: MediaRepresentations;
  // (undocumented)
  size: number;
  // (undocumented)
  status: 'processed';
}

// @public (undocumented)
export interface ProcessingFailedState {
  // (undocumented)
  artifacts: Object;
  // (undocumented)
  createdAt?: number;
  // (undocumented)
  id: string;
  // (undocumented)
  mediaType: MediaType;
  // (undocumented)
  mimeType: string;
  // (undocumented)
  name: string;
  // (undocumented)
  occurrenceKey?: string;
  // (undocumented)
  preview?: FilePreview | Promise<FilePreview>;
  // (undocumented)
  representations?: MediaRepresentations;
  // (undocumented)
  size: number;
  // (undocumented)
  status: 'failed-processing';
}

// @public (undocumented)
export interface ProcessingFileState {
  // (undocumented)
  artifacts?: MediaFileArtifacts;
  // (undocumented)
  createdAt?: number;
  // (undocumented)
  id: string;
  // (undocumented)
  mediaType: MediaType;
  // (undocumented)
  mimeType: string;
  // (undocumented)
  name: string;
  // (undocumented)
  occurrenceKey?: string;
  // (undocumented)
  preview?: FilePreview | Promise<FilePreview>;
  // (undocumented)
  representations?: MediaRepresentations;
  // (undocumented)
  size: number;
  // (undocumented)
  status: 'processing';
}

// @public (undocumented)
export const RECENTS_COLLECTION = 'recents';

// @public (undocumented)
export function request(
  url: string,
  options?: RequestOptions,
  controller?: AbortController,
): Promise<Response>;

// @public (undocumented)
export class RequestError extends BaseMediaClientError<RequestErrorAttributes> {
  constructor(
    reason: RequestErrorReason,
    metadata?: RequestErrorMetadata | undefined,
    innerError?: Error | undefined,
  );
  // (undocumented)
  get attributes(): {
    reason: RequestErrorReason;
    method: RequestMethod | undefined;
    endpoint: string | undefined;
    mediaRegion: string | undefined;
    mediaEnv: string | undefined;
    attempts: number | undefined;
    clientExhaustedRetries: boolean | undefined;
    statusCode: number | undefined;
    innerError: Error | undefined;
  };
  // (undocumented)
  readonly innerError?: Error | undefined;
  // (undocumented)
  readonly metadata?: RequestErrorMetadata | undefined;
  // (undocumented)
  readonly reason: RequestErrorReason;
}

// @public (undocumented)
export type RequestErrorAttributes = RequestErrorMetadata & {
  readonly reason: RequestErrorReason;
};

// @public (undocumented)
export type RequestErrorMetadata = RequestMetadata & {
  readonly attempts?: number;
  readonly clientExhaustedRetries?: boolean;
  readonly statusCode?: number;
};

// @public (undocumented)
export type RequestErrorReason =
  | 'clientOffline'
  | 'clientAbortedRequest'
  | 'clientTimeoutRequest'
  | 'serverInvalidBody'
  | 'serverBadRequest'
  | 'serverUnauthorized'
  | 'serverForbidden'
  | 'serverNotFound'
  | 'serverRateLimited'
  | 'serverInternalError'
  | 'serverBadGateway'
  | 'serverUnexpectedError';

// @public (undocumented)
export type RequestHeaders = {
  [key: string]: string;
};

// @public (undocumented)
export type RequestMetadata = {
  readonly method?: RequestMethod;
  readonly endpoint?: string;
  readonly mediaRegion?: string;
  readonly mediaEnv?: string;
};

// @public (undocumented)
export type RequestMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';

// @public (undocumented)
export type RequestOptions = RequestMetadata & {
  readonly auth?: Auth;
  readonly params?: RequestParams;
  readonly headers?: RequestHeaders;
  readonly body?: any;
  readonly clientOptions?: ClientOptions;
};

// @public (undocumented)
export type RequestParams = {
  [key: string]: any;
};

// @public (undocumented)
export interface ResponseFileItem {
  // (undocumented)
  collection?: string;
  // (undocumented)
  details: MediaCollectionItemFullDetails;
  // (undocumented)
  id: string;
  // (undocumented)
  type: 'file';
}

// @public (undocumented)
export type RetryOptions = {
  readonly startTimeoutInMs: number;
  readonly maxAttempts: number;
  readonly factor: number;
};

// @public (undocumented)
export const safeUnsubscribe: (subscription: MediaSubscription) => void;

// @public (undocumented)
export interface SourceFile {
  // (undocumented)
  collection?: string;
  // (undocumented)
  id: string;
  // (undocumented)
  owner: ClientAltBasedAuth | AsapBasedAuth;
  // (undocumented)
  version?: number;
}

// @public (undocumented)
export class StargateClient {
  constructor(baseUrl: string | undefined);
  // (undocumented)
  fetchToken(clientId: string): Promise<EdgeData>;
  // (undocumented)
  isTokenExpired(token: EdgeData): boolean;
}

// @public (undocumented)
export class StreamsCache<T> {
  constructor(streams: LRUCache<string, ReplaySubject<T>>);
  // (undocumented)
  get(id: string): ReplaySubject<T> | undefined;
  // (undocumented)
  getOrInsert(id: string, callback: () => ReplaySubject<T>): ReplaySubject<T>;
  // (undocumented)
  has(id: string): boolean;
  // (undocumented)
  remove(id: string): void;
  // (undocumented)
  removeAll(): void;
  // (undocumented)
  set(id: string, stream: ReplaySubject<T>): void;
  // (undocumented)
  get size(): number;
}

// @public (undocumented)
export type TouchedFiles = {
  created: CreatedTouchedFile[];
};

// @public (undocumented)
export interface TouchFileDescriptor {
  // (undocumented)
  collection?: string;
  // (undocumented)
  deletable?: boolean;
  // (undocumented)
  expireAfter?: number;
  // (undocumented)
  fileId: string;
  // (undocumented)
  occurrenceKey?: string;
}

// @public (undocumented)
export type UploadableFile = {
  content: ChunkinatorFile;
  name?: string;
  mimeType?: string;
  collection?: string;
};

// @public (undocumented)
export type UploadableFileUpfrontIds = {
  id: string;
  deferredUploadId: Promise<string>;
  occurrenceKey?: string;
};

// @public (undocumented)
export class UploadController {
  constructor();
  // (undocumented)
  abort(): void;
  // (undocumented)
  abortFunction?: AbortFunction;
  // (undocumented)
  setAbort(abortFunction: AbortFunction): void;
}

// @public (undocumented)
export type UploadEventPayloadMap = {
  'file-added': FileState;
  'media-viewed': MediaViewedEventPayload;
};

// @public (undocumented)
export const uploadFile: (
  file: UploadableFile,
  store: MediaStore,
  uploadableFileUpfrontIds: UploadableFileUpfrontIds,
  callbacks?: UploadFileCallbacks | undefined,
) => UploadFileResult;

// @public (undocumented)
export type UploadFileCallbacks = {
  onProgress: (progress: number) => void;
  onUploadFinish: (error?: any) => void;
};

// @public (undocumented)
export interface UploadFileResult {
  // (undocumented)
  cancel: () => void;
}

// @public (undocumented)
export interface UploadingFileState {
  // (undocumented)
  createdAt?: number;
  // (undocumented)
  id: string;
  // (undocumented)
  mediaType: MediaType;
  // (undocumented)
  mimeType: string;
  // (undocumented)
  name: string;
  // (undocumented)
  occurrenceKey?: string;
  // (undocumented)
  preview?: FilePreview | Promise<FilePreview>;
  // (undocumented)
  progress: number;
  // (undocumented)
  size: number;
  // (undocumented)
  status: 'uploading';
}

// @public (undocumented)
export interface WithMediaClient {
  // (undocumented)
  identifier?: Identifier;
  // (undocumented)
  mediaClient: MediaClient;
}

// @public (undocumented)
export const withMediaClient: WithMediaClientFunction;

// @public (undocumented)
export interface WithMediaClientConfig {
  // (undocumented)
  mediaClientConfig: MediaClientConfig;
}

// @public (undocumented)
export type WithMediaClientConfigProps<P extends WithMediaClient> = Omit<
  P,
  'mediaClient'
> &
  WithMediaClientConfig;

// @public (undocumented)
export type WithMediaClientFunction = <P extends WithMediaClient>(
  Component: React_2.ComponentType<P>,
  featureFlags?: MediaFeatureFlags,
) => React_2.ComponentType<WithMediaClientConfigProps<P>>;

// (No @packageDocumentation comment for this package)
```
