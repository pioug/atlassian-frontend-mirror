import { fg } from '@atlaskit/platform-feature-flags';

import type { AssetsConfig, InteractionMetrics, InteractionType } from '../common';

let config: Config | undefined;

export interface AdditionalData {
	[key: string]:
		| null
		| string
		| number
		| boolean
		| undefined
		| AdditionalData
		| Record<string, AdditionalData>
		| Array<AdditionalData>;
}

interface InteractionMetricsConfig {
	readonly enabled?: boolean;
	readonly rates?: Rates;
	readonly kind?: Record<InteractionType, number>;
}

export interface SSRTiming {
	label: string;
	data: {
		startTime: number;
		duration: number;
	};
}

type Capability = 'feature_flag_access' | 'react_profiler';
type InteractionKind = 'page_load' | 'transition' | 'press' | 'typing' | 'legacy' | 'hover';
type UFONameOverride = {
	readonly [ufoName: string]: {
		readonly [metricKey: string]: string;
	};
};
type ResourceType = 'script' | 'link' | 'fetch' | 'xmlhttprequest';

type SelectorConfig = {
	id: boolean;
	testId: boolean;
	role: boolean;
	className: boolean;
	dataVC?: boolean;
};

type SegmentThreshold = {
	readonly [key: string]: number;
};

type Rates = {
	readonly [key: string]: number;
};

export type TTVCRevision = 'fy25.01' | 'fy25.02' | 'fy25.03' | 'fy26.04' | 'next';
export const DEFAULT_TTVC_REVISION = 'fy25.03';

export const UNKNOWN_INTERACTION_RATE = 1000;

export type ReactHydrationStats = {
	/**
	 * Indicates if hydration of SSR content failed, so React switching to client-side rendering and re-rendered from scratch.
	 */
	successful: boolean;
	/**
	 * The total number of hydration errors reported from {@code hydrateRoot#onRecoverableError}.
	 */
	warningCount?: number;
	/**
	 * The depth in the React component tree of the shallowest warning.
	 */
	minWarningComponentDepth?: number;
	/**
	 * The depth in the React component tree of the deepest warning.
	 */
	maxWarningComponentDepth?: number;
	/**
	 * The ratio of DOM nodes preserved during hydration (between 0 and 1).
	 */
	preservationRatio?: number;
};

// Defensively typed, since this is directly user-editable
// and they could delete empty members
export type Config = {
	readonly enabled?: boolean;
	readonly interactionTimeout?: Record<string, number>;
	readonly minorInteractions?: string[];
	readonly doNotAbortActivePressInteraction?: string[];
	readonly doNotAbortActivePressInteractionOnTransition?: string[];
	readonly finishInteractionOnTransition?: string[];
	readonly awaitBM3TTI?: string[];
	readonly ufoNameOverrides?: UFONameOverride;
	readonly namePrefix?: string;
	readonly segmentPrefix?: string;
	readonly rates?: Rates;
	readonly rules?: readonly {
		readonly test?: string;
		readonly rate?: number;
	}[];
	readonly killswitch?: readonly string[];
	/**
	 * @private
	 * @deprecated - remove on FG cleanup of platform_ufo_remove_deprecated_config_fields
	 */
	readonly killswitchNestedSegments?: boolean;
	readonly typingMethod?: string;
	/**
	 * @private
	 * @deprecated - remove on FG cleanup of platform_ufo_remove_deprecated_config_fields
	 */
	readonly capability?: Record<Capability, number>;
	readonly kind?: Record<InteractionKind, number>;
	readonly allowedResources?: Array<ResourceType>;
	readonly allowedResourcesParams?: Array<string>;
	readonly autoGeneratedRate?: number;
	readonly product: string;
	/**
	 * The Event Population is intended for segmenting traffic based on
	 * overrides/segments used in Statsig for targeting.
	 * ie. "customer-test", "internal-test", "release-tracks", "experiment-population"
	 *
	 * See https://console.statsig.com/LqivKg6ADZZaGczRfBKfX/dynamic_configs/cc_ufo_group
	 * for an example dynamic config powering the Confluence population.
	 */
	readonly population?: string;
	readonly region: string;
	readonly additionalPayloadData?: (interaction: InteractionMetrics) => AdditionalData;
	readonly ssr?: {
		readonly getSSRTimings?: () => SSRTiming[];
		readonly getSSRDoneTime?: () => number | undefined;
		readonly enableNativeTracing?: boolean
	};
	readonly assetsConfig?: AssetsConfig;
	readonly enableBetterPageVisibilityApi?: boolean;
	readonly segmentsThreshold?: SegmentThreshold;
	readonly vc?: {
		readonly enabled?: boolean;
		readonly heatmapSize?: number;
		readonly oldDomUpdates?: boolean;
		readonly devToolsEnabled?: boolean;
		readonly selectorConfig?: SelectorConfig;
		readonly ssr?: boolean;
		readonly ssrWhitelist?: string[];
		readonly ssrEnablePageLayoutPlaceholder?: boolean;
		readonly includeSSRInV3?: boolean;
		readonly stopVCAtInteractionFinish?: boolean;
		readonly includeSSRRatio?: boolean;
		/**
		 * The revisions of TTVC that will be calculated
		 * - `all` is the TTVC revisions that are used on a product level
		 * - `byExperience` is the version that is used on an experience level.
		 *   Note that an entry in the `byExperience` config should only be a SUBSET of the `all` config,
		 *   i.e. every element for all `byExperience` entry configs should exist in the `all` config
		 */
		readonly enabledVCRevisions?: {
			all: readonly TTVCRevision[];
			byExperience?: Record<string, readonly TTVCRevision[]>;
		};
	};
	readonly postInteractionLog?: {
		readonly enabled?: boolean;
		readonly rates?: Rates;
		readonly kind?: Record<InteractionType, number>;
	};
	readonly experimentalInteractionMetrics?: {
		readonly enabled?: boolean;
		readonly rates?: Rates;
		readonly kind?: Record<InteractionType, number>;
	};
	/**
	 * Option to enable terminal error tracking
	 */
	readonly terminalErrors?: {
		readonly enabled?: boolean;
	};
	/**
	 * @private
	 * @deprecated - to be removed on next major version
	 */
	readonly enableSegmentHighlighting?: boolean;
	readonly enableAdditionalPerformanceMarks?: boolean;
	/**
	 * @private
	 * @deprecated - remove on FG cleanup of platform_ufo_remove_deprecated_config_fields
	 */
	readonly shouldCalculateLighthouseMetricsFromTTAI?: boolean;
	readonly timeWindowForLateMutationsInMilliseconds?: number;
	readonly manuallyTrackReactProfilerMounts?: boolean;
	/**
	 * Callback for consumers to provide React hydration stats after React has finished.
	 * Return {@code null} if hydration was not attempted or if we do not want to report any stats.
	 */
	readonly getReactHydrationStats?: (() => ReactHydrationStats | undefined) | undefined;
	/**
	 * Whether ttvc with 3p measurement is enabled and sent new event for experiences with sample rates
	 */
	readonly extraInteractionMetrics?: InteractionMetricsConfig;

	/**
	 * Option to enable an additional metric to track search page load times with SAIN ignored
	 */
	readonly extraSearchPageInteraction?: {
		readonly enabled: boolean;
		readonly searchPageMetricName: string;
		readonly searchPageRoute: string;
	};
	readonly enableVCRawDataRates?: {
		readonly enabled?: boolean;
		readonly rates?: Rates;
		readonly kind?: Record<InteractionType, number>;
	};
};

export function setUFOConfig(newConfig: Config): void {
	// Handle edge cases with `enabledVCRevisions`
	const { enabledVCRevisions } = newConfig?.vc ?? {};
	if (typeof enabledVCRevisions?.byExperience === 'object') {
		config = {
			...newConfig,
			vc: {
				...newConfig.vc,
				enabledVCRevisions: {
					// enforce axiom about `enabledVCRevisions.all` config
					all: Array.from(
						new Set([
							DEFAULT_TTVC_REVISION,
							...enabledVCRevisions?.all,
							...Object.values(enabledVCRevisions?.byExperience).flat(),
						]),
					),
					byExperience: { ...enabledVCRevisions?.byExperience },
				},
			},
		};
	} else {
		config = newConfig;
	}
}

export function getConfig(): Config | undefined {
	return config;
}

const isValidConfigArray = <T>(array: any): array is T[] => {
	return Array.isArray(array) && array.length > 0;
};

export function getEnabledVCRevisions(experienceKey: string = ''): readonly TTVCRevision[] {
	try {
		if (!config) {
			return [];
		}

		if (config.vc?.enabled) {
			const { enabledVCRevisions } = config.vc ?? {};

			if (isValidConfigArray(enabledVCRevisions?.byExperience?.[experienceKey])) {
				return enabledVCRevisions.byExperience?.[experienceKey];
			}

			if (isValidConfigArray(enabledVCRevisions?.all)) {
				return enabledVCRevisions.all;
			}

			return [DEFAULT_TTVC_REVISION];
		}

		return [];
	} catch {
		return [];
	}
}

export function isVCRevisionEnabled(revision: TTVCRevision, experienceKey?: string): boolean {
	return getEnabledVCRevisions(experienceKey).includes(revision);
}

export function getMostRecentVCRevision(experienceKey: string = ''): TTVCRevision {
	const enabledVCRevisions = getEnabledVCRevisions(experienceKey);
	return enabledVCRevisions[enabledVCRevisions.length - 1];
}

export function getReactHydrationStats(): ReactHydrationStats | undefined {
	if (!config) {
		return undefined;
	}
	try {
		const stats = config?.getReactHydrationStats?.();
		return stats ?? undefined;
	} catch (e) {
		// eslint-disable-next-line no-console
		console.error('getReactHydrationStats threw an error: ', e);
		return undefined;
	}
}

export function getInteractionRate(name: string, interactionKind: InteractionKind): number {
	try {
		if (!config) {
			return 0;
		}
		const { killswitch, rates, rules, kind, autoGeneratedRate } = config;

		if (killswitch != null) {
			// Specifically kill certain events
			if (killswitch.includes(name)) {
				return 0;
			}
		}

		const isUnknown = name === 'unknown';
		if (isUnknown) {
			if (rates?.[name] != null) {
				return rates[name];
			}
			// Return default rate for unknown events when no explicit rate is configured
			return UNKNOWN_INTERACTION_RATE;
		}

		if (rates != null) {
			// Decide the rate explicitly
			if (rates[name] != null) {
				return rates[name];
			}
		}

		if (rules != null) {
			for (let i = 0; i < rules.length; i++) {
				const rule = rules[i];
				const { test, rate } = rule;
				if (test != null && rate != null) {
					const regexp = new RegExp(test, 'ig');

					if (regexp.test(name)) {
						return rate;
					}
				}
			}
		}

		const isAutogenerated = name?.startsWith('auto-generated');
		if (isAutogenerated) {
			const rate = autoGeneratedRate;
			if (rate != null) {
				return rate;
			}
		}

		if (kind != null) {
			const rate = kind[interactionKind];
			if (rate != null) {
				return rate;
			}
		}

		return 0;
	} catch {
		// Fallback
		return 0;
	}
}

export function getExperimentalInteractionRate(
	name: string,
	interactionType: InteractionType,
): number {
	try {
		if (!config) {
			return 0;
		}
		const { experimentalInteractionMetrics } = config;
		if (!experimentalInteractionMetrics?.enabled) {
			return 0;
		}

		if (
			experimentalInteractionMetrics.rates &&
			typeof experimentalInteractionMetrics.rates[name] === 'number'
		) {
			return experimentalInteractionMetrics.rates[name];
		}

		if (
			experimentalInteractionMetrics.kind &&
			typeof experimentalInteractionMetrics.kind[interactionType] === 'number'
		) {
			return experimentalInteractionMetrics.kind[interactionType];
		}

		return 0;
	} catch {
		return 0;
	}
}

export function getVCRawDataInteractionRate(
	name: string,
	interactionType: InteractionType,
): number {
	return getConfigRate(name, interactionType, 'enableVCRawDataRates');
}

export function shouldUseRawDataThirdPartyBehavior(
	name: string,
	interactionType: InteractionType,
): boolean {
	if (!fg('platform_ufo_raw_data_thirdparty')) {
		return false;
	}
	return getVCRawDataInteractionRate(name, interactionType) > 0;
}

export function getPostInteractionRate(name: string, interactionType: InteractionType): number {
	return getConfigRate(name, interactionType, 'postInteractionLog');
}

export function getCapabilityRate(capability: Capability): number {
	if (fg('platform_ufo_remove_deprecated_config_fields')) {
		return 1;
	}

	try {
		if (!config) {
			return 0;
		}
		const { capability: capabilityRate } = config;
		if (capabilityRate != null) {
			const rate = capabilityRate[capability];
			if (rate != null) {
				return rate;
			}
		}
		return 0;
	} catch {
		return 0;
	}
}

function getConfigRate(
	name: string,
	interactionType: InteractionType,
	configName: 'postInteractionLog' | 'extraInteractionMetrics' | 'enableVCRawDataRates',
): number {
	try {
		if (!config) {
			return 0;
		}
		const gotConfig = config[configName];
		if (!gotConfig?.enabled) {
			return 0;
		}

		if (interactionType !== 'page_load' && interactionType !== 'transition') {
			return 0;
		}

		if (gotConfig.rates && typeof gotConfig.rates[name] === 'number') {
			return gotConfig.rates[name];
		}

		if (
			'kind' in gotConfig &&
			gotConfig.kind &&
			typeof gotConfig.kind[interactionType] === 'number'
		) {
			return gotConfig.kind[interactionType];
		}

		return 0;
	} catch {
		return 0;
	}
}

export function getExtraInteractionRate(name: string, interactionType: InteractionType): number {
	return getConfigRate(name, interactionType, 'extraInteractionMetrics');
}

const validTypingMethods = ['timeout', 'timeoutNoAlloc', 'mutationObserver'] as const;
type ValidTypingMethod = (typeof validTypingMethods)[number];

export function getTypingPerformanceTracingMethod(): ValidTypingMethod {
	const defaultMethod = 'timeout';
	try {
		if (!config) {
			return defaultMethod;
		}
		const { typingMethod } = config;

		if (typingMethod != null && validTypingMethods.find((m) => m === typingMethod)) {
			return typingMethod as ValidTypingMethod;
		} else {
			return defaultMethod;
		}
	} catch {
		return defaultMethod;
	}
}

// Will ask UFO to wait for BM3 TTI for all events on this list
export function getAwaitBM3TTIList(): string[] {
	try {
		if (!config) {
			return [];
		}
		const { awaitBM3TTI } = config;

		if (awaitBM3TTI != null) {
			return awaitBM3TTI;
		} else {
			return [];
		}
	} catch {
		return [];
	}
}

// Will ask UFO to override ufoName => experienceKey to the apdex key
// This is to cover use cases where one rUFO route is split into multiple BM3 keys (1:N)
// This workaround should only be used as last resource,
// when we find router limitations preventing teams from splliting these routes
export function getUfoNameOverrides(): UFONameOverride | undefined {
	try {
		if (!config) {
			return undefined;
		}
		const { ufoNameOverrides } = config;
		if (ufoNameOverrides != null) {
			return ufoNameOverrides;
		}
		return undefined;
	} catch {
		return undefined;
	}
}

export function getMinorInteractions(): string[] | undefined {
	try {
		if (!config) {
			return undefined;
		}
		const { minorInteractions } = config;

		return minorInteractions;
	} catch {
		return undefined;
	}
}

// Contains the list of interactions that do not abort existing known interactions
export function getDoNotAbortActivePressInteraction(): string[] | undefined {
	try {
		if (!config) {
			return undefined;
		}
		const { doNotAbortActivePressInteraction } = config;

		return doNotAbortActivePressInteraction;
	} catch {
		return undefined;
	}
}

// Contains the list of interactions that do not abort on transitions
export function getDoNotAbortActivePressInteractionOnTransition(): string[] | undefined {
	try {
		if (!config) {
			return undefined;
		}
		const { doNotAbortActivePressInteractionOnTransition } = config;

		return doNotAbortActivePressInteractionOnTransition;
	} catch {
		return undefined;
	}
}

// Contains the list of interactions that do not abort on transitions
export function getFinishInteractionOnTransition(): string[] | undefined {
	try {
		if (!config) {
			return undefined;
		}
		const { finishInteractionOnTransition } = config;

		return finishInteractionOnTransition;
	} catch {
		return undefined;
	}
}

export const CLEANUP_TIMEOUT: number = 60 * 1000;

export function getInteractionTimeout(ufoName: string): number {
	try {
		if (!config) {
			return CLEANUP_TIMEOUT;
		}
		const { interactionTimeout } = config;

		if (interactionTimeout != null && interactionTimeout[ufoName] != null) {
			return interactionTimeout[ufoName];
		}
		if (interactionTimeout != null && interactionTimeout.__globalInteractionTimeout != null) {
			return interactionTimeout.__globalInteractionTimeout;
		} else {
			return CLEANUP_TIMEOUT;
		}
	} catch {
		return CLEANUP_TIMEOUT;
	}
}
