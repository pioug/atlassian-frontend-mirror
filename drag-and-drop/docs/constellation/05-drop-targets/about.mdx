---
order: 0
title: Drop targets
description: Drop targets are elements that can be dropped on.
---

## Basic usage

```ts
// drop targets are exposed through adapters
import { dropTargetForFiles } from '@atlaskit/drag-and-drop/adapter/files';

const cleanup = dropTargetForFiles({
  element: myElement,
});
```

```ts
// basic usage with react
import React, { useEffect, useRef } from 'react';
import { dropTargetForElements } from '@atlaskit/drag-and-drop/adapter/elements';

function DropTarget() {
  const ref = useRef<HTMLDivElement | null>(null);

  useEffect(() => {
    const el = ref.current;
    if (!el) {
      throw new Error('ref not set correctly');
    }

    return dropTargetForFiles({
      element: el,
    });
  }, []);

  return <div ref={ref}>Drop elements on me!</div>;
}
```

## Rules

- Drop targets are scoped to a particular entity type. For example, `dropTargetForElements` is a _drop target_ for elements, and `dropTargetForFiles` is a drop target for files.
- A single `element` can be used as a drop target for multiple entity types.

```ts
// ✅ Using the same element as a drop target for elements and for files
const cleanup = combine(
  dropTargetForElements({
    element: myElement,
  }),
  dropTargetForFiles({
    element: myElement,
  }),
);
```

- A single `element` cannot be used to create multiple drop targets for the same entity type (you will get a warning in your `console` if you make a mistake).

```ts
// ❌ Using the same element for two drop targets of the same entity type is not allowed
const cleanup = combine(
  dropTargetForElements({
    element: myElement,
  }),
  // ⚠️ A warning will be logged if this is detected
  dropTargetForElements({
    element: myElement,
  }),
);
```

- Drop targets can be nested.

```ts
dropTargetForElements({
  element: parentElement,
});
dropTargetForElements({
  element: childElement,
});
```

- During a drag operation:
  - You can add new _drop targets_
  - You can remove _drop targets_
  - You can _remount_ a _drop targets_ (see [reconciliation](/components/drag-and-drop/reconciliation))
  - You can change the dimensions of any _drop target_

## Drop target arguments

High level:

- `element` - the `Element` the drop target will be attached to
- `getData()` - data to associate with the drop target
- `canDrop()` - whether the drop target can be dropped on
- `getDropEffect()` - control the cursor when over a drop target
- `getIsSticky()` - whether the drop target will hold onto selection after no longer being dragged over
- [`onGenerateDragPreview`](/components/drag-and-drop/events)
- [`onDragStart`](/components/drag-and-drop/events)
- [`onDrag`](/components/drag-and-drop/events)
- [`onDropTargetChange`](/components/drag-and-drop/events)
- [`onDrop`](/components/drag-and-drop/events)

### Required arguments

- `element`: `Element` you want to attach the drop target to

### Optional arguments

- `getData?: (args: GetFeedbackArgs) => Record<string, unknown>`: a function that returns data you want to attach to the drop target. `getData()` is called _repeatedly_ while the user is dragging over the drop target in order to power addons. If your `getData()` function is expensive, consider using the [`once` utility function](/components/drag-and-drop/packages/core/about#once). `getData()` is called with `GetFeedbackArgs` (see below) which contains limited information about the current drag operation. Try to make your `getData()` function _pure_ (same input results in the same output)

```ts
const cleanup = dropTargetForFiles({
  element: myElement,
  getData: () => ({ id: 'Alex' }),
});
```

- `canDrop?: (args: GetFeedbackArgs) => boolean` is used to conditionally block dropping. When looking for valid drop targets, `@atlaskit/drag-and-drop` starts at the deepest part of the DOM tree the user is currently over and searches upwards for valid targets. If a drop target blocks dragging (`canDrop()` returns `false`), then that drop target is ignored and the search upwards continues. `canDrop()` is called _repeatedly_ while a drop target is being dragged over to allow you to dynamically change your mind as to whether a drop target can be dropped on. `canDrop()` being called _repeatedly_ allows you to change your mind about whether a drop target can be dropped on _after_ it has been entered into. This could be helpful in a situation where you are waiting on some permission information from a backend service.

```ts
// I can never be dropped on!
dropTargetForFiles({
  element: myElement,
  canDrop: () => false,
});

// only allow 'cards' to be dropped on this drop target
dropTargetForElements({
  element: myOtherElement,
  canDrop: ({ source }: GetFeedbackArgs) => {
    return source.data.type === 'card';
  },
});
```

```ts
type GetFeedbackArgs = {
  input: Input;
  source: SourcePayload; // this payload type will be different for different adapters
  element: Element;
};
```

- `getDropEffect?: (args: GetFeedbackArgs) => DataTransfer['dropEffect']`. The `dropEffect` property will control the visual feedback (cursor) when dragging over it. As with `getData()`, `getDropEffect()` is repeatedly called throughout a drag operation. The default `dropEffect` is dependent on the adapter. `getDropEffect()` is called _repeatedly_ while a drop target is being dragged over to allow you change your mind about which drop effect should be applied.

```ts
dropTargetForLinks({
  getDropEffect: () => 'link',
});
```

When working with nested _drop targets_, the inner most drop targets `dropEffect` is the one that will be applied; even if inner most drop target is using the default value (`"move"`)

- `getIsSticky?: (args: GetFeedbackArgs) => boolean`: Drop targets are generally calculated based on where the user's pointer is currently located. In some scenarios you might want to _hold on_ to a previous drop target (make it _sticky_), even when the drop target is no longer being directly dragged over. This is useful if you want to maintain a selection while you are in _gaps_ between drop targets. `getIsSticky()` is called `repeatedly` while a drop target is being dragged over

```ts
dropTargetForElements({
  element: myElement,
  getIsSticky: () => true,
});

dropTargetForElements({
  element: myElement,
  getIsSticky: ({ source }: GetFeedbackArgs): boolean => {
    // only be sticky when dragging something with 'author = Alex'
    return source.data.author === 'Alex';
  },
});
```

A _drop target_ that otherwise would not be dragged over any more due to changes in the users pointer, will continue to be marked as "dragged over" when:

1. The drop target `getIsSticky()` returns `true` AND
2. The parent of a _drop target_ is unchanged

> `[]` = Which _drop targets_ are currently dragged over
> `[A]` = over the `A` drop target

> Scenario: `[A(sticky)]` → `[]`
> Result: `[A]`

> Scenario: `[B(sticky), A(sticky)]` → `[]`
> Result: `[B, A]`

> Scenario: `[C, B(sticky), A(sticky)]` → `[]`
> Result: `[B, A]`

> Scenario: `[A(sticky)]` → `[B]`
> Result: `[B]`

> Scenario: `[B(sticky), A]` → `[A]`
> Result: `[B, A]`

> Scenario: `[B, A(sticky)]` → `[A]`
> Result: `[A]`

> Scenario: `[B(sticky), A]` → `[X]`
> Result: `[X]`

> Scenario: `[B(sticky), A]` → `[]`
> Result: `[]`

> Scenario: `[B(sticky), A(sticky)]` → `[X]`
> Result: `[X]`

All _drop targets_, regardless of stickiness, will no longer be "dragged over" when the users pointer moves out of the `window`

## Nested drop targets

When calculating what _drop targets_ are currently being dragged over, we look from the deepest possible _drop target_ upwards (bubble ordering). We will search up to the document root to find any available drop targets. If a _drop target_ specifies that it cannot be dropped on (`canDrop()` returns `false`), then it will be ignored and the search will continue upwards.

> Scenario: `[] -> [B, A(blocked)]`
> Result: `[] -> [B]`

Flow:

- `B` visited and allows dropping. Drop targets: `[] -> [B]`
- `A` visited and does not allow dropping

> Scenario: `[] -> [C, B(blocked), A]`
> Result: `[] -> [C, A]`

- Going from no drop targets `[]` to three drop targets: `[C, B, A]` (bubble ordered).
- `C` and `A` allow dropping, but `B` has blocked dropping

Flow:

- `C` visited and allows dropping. Drop targets: `[] -> [C]`
- `B` visited and does not allow dropping
- `A` visited and allows dropping. Drop targets `[C] -> [C, A]`
