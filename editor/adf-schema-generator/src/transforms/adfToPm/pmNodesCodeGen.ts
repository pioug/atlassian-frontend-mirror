import camelCase from 'lodash/camelCase';
import type { ADFAttribute, ADFAttributes } from '../../types/ADFAttribute';
import {
	_codeBlock,
	_functionCallToVariable,
	_interface,
	_namedImport,
	_namedTypeImport,
	_type,
	buildADFAttributesTypes,
	convertTypeToTypeName,
	stringifyWithUndefined,
} from './codeGenHelpers';
import { isAnyOf } from '../../utils/isAnyOf';
import { adfToPmAutogeneratedMessage } from './adfToPmAutogeneratedMessage';
import type { NodeTypeDefinition, NodeSpecResMap } from './types';
import { objectToSortedArray } from './objectToSortedArray';

export const _nodeInterfaces = (
	nodeName: string,
	nodeTypeDefinitionName: string,
	nodeTypeDefinition: NodeTypeDefinition,
) => {
	const additionalAttributeTypes: string[] = [];

	const _attrs = (name: string, attrs: ADFAttributes): string | null => {
		if (!attrs || !Object.keys(attrs).length) {
			return null;
		}
		return `${name}: {${buildADFAttributesTypes(attrs).join(';')}},`;
	};

	const _anyOfAttrs = (name: string, anyOf: Record<string, ADFAttribute>[]): string | null => {
		if (!anyOf) {
			return null;
		}
		const additionalAttributeName = (index: number) => `${nodeName}Attributes${index}`;

		anyOf.forEach((attr, index) => {
			additionalAttributeTypes.push(
				_interface(additionalAttributeName(index), buildADFAttributesTypes(attr).join(';')),
			);
		});
		return `${name}: ${anyOf.map((_, index) => additionalAttributeName(index)).join('|')}`;
	};

	const _string = (name: string, value: string): string | null => {
		if (!value) {
			return null;
		}
		return `${name}: '${value}'`;
	};

	const _contentTypes = (name: string, value: string[]): string | null => {
		if (!value || value.length === 0) {
			return null;
		}
		const types = value.map((v) => {
			return convertTypeToTypeName(v, '');
		});
		return `${name}: Array<${types.sort().join('|')}>`;
	};

	const _nodeMarks = (name: string, value: string[]): string | null => {
		if (!value || value.length === 0) {
			return null;
		}
		return `${name}: Array<${value.sort().join('|')}>`;
	};

	const type = _string('type', nodeTypeDefinition.type);
	const content = _contentTypes('content', nodeTypeDefinition.content ?? []);
	const marks = _nodeMarks('marks', nodeTypeDefinition.marks ?? []);
	const attrs = isAnyOf(nodeTypeDefinition.attrs as unknown as ADFAttributes)
		? _anyOfAttrs(
				'attrs',
				nodeTypeDefinition.attrs?.anyOf as unknown as Record<string, ADFAttribute>[],
			)
		: _attrs('attrs', nodeTypeDefinition.attrs as unknown as ADFAttributes);

	const body = [type, content, marks, attrs].filter((v) => !!v).join(',');
	return [
		...additionalAttributeTypes,
		_interface(nodeTypeDefinitionName, body),
		_type(nodeName, `PMNode & ${nodeTypeDefinitionName}`),
	].join('\n\n');
};

export const buildNodeMarksForImport = (nodeResMap: Record<string, NodeSpecResMap>): string[] => {
	const markTypes: string[] = [];
	Object.values(nodeResMap).forEach(({ nodeTypeDefinition: { marks } }) => {
		markTypes.push(...(marks ?? []));
	});
	return [...new Set(markTypes)];
};

export function pmNodesCodeGen(nodeResMap: Record<string, NodeSpecResMap>) {
	return _codeBlock(
		adfToPmAutogeneratedMessage,
		_namedImport('../../schema/createPMSpecFactory', 'createPMNodeSpecFactory'),
		_namedTypeImport('@atlaskit/editor-prosemirror/model', 'Node as PMNode'),
		_namedTypeImport(
			'./nodeGroupTypes',
			...['InlineDefinition', 'BlockDefinition', 'BlockRootOnlyDefinition'],
		),
		_namedTypeImport('./markTypes', ...buildNodeMarksForImport(nodeResMap).sort()),
		objectToSortedArray(nodeResMap)
			.map(([key, { nodeTypeDefinition, pmNodeSpec }]) => {
				const functionName = camelCase(key);
				const nodeName = convertTypeToTypeName(key, 'Node');
				const nodeTypeDefinitionName = convertTypeToTypeName(key, 'Definition');
				return _codeBlock(
					// build node types
					_nodeInterfaces(nodeName, nodeTypeDefinitionName, nodeTypeDefinition),
					// build node speec
					_functionCallToVariable(functionName, `createPMNodeSpecFactory<${nodeName}>`, [
						stringifyWithUndefined(pmNodeSpec),
					]),
				);
			})
			.join('\n\n'),
	);
}
