<!-- API Report Version: 2.3 -->

## API Report File for "@atlaskit/jql-ast"

> Do not edit this file. This report is auto-generated using [API Extractor](https://api-extractor.com/).
> [Learn more about API reports](https://hello.atlassian.net/wiki/spaces/UR/pages/1825484529/Package+API+Reports)

### Table of contents

- [Main Entry Types](#main-entry-types)
- [Peer Dependencies](#peer-dependencies)

### Main Entry Types

<!--SECTION START: Main Entry Types-->

```ts
import { ANTLRErrorStrategy } from 'antlr4ts';
import { ParserErrorListener } from 'antlr4ts';

// @public (undocumented)
export abstract class AbstractJastVisitor<Result>
  implements JastVisitor<Result>
{
  protected aggregateResult(aggregate: Result, nextResult: Result): Result;
  protected abstract defaultResult(): Result;
  protected shouldVisitNextChild(node: AstNode, currentResult: Result): boolean;
  visit(node: AstNode): Result;
  visitChildren(node: AstNode): Result;
}

// @public (undocumented)
export const AFFECTED_VERSION_FIELD = 'affectedversion';

// @public (undocumented)
export const APPROVALS_FIELD = 'approvals';

// @public
export interface Argument extends AstNode {
  text: string;
  value: string;
}

// @public (undocumented)
export const ASSIGNEE_FIELD = 'assignee';

// @public (undocumented)
export const ASSIGNEE_PROPERTY = 'assignee.property';

// @public
export interface AstNode<Parent extends AstNode = AstNode<any>> {
  accept: <Result>(visitor: JastVisitor<Result>) => Result;
  enterNode: (listener: JastListener) => void;
  exitNode: (listener: JastListener) => void;
  getChildren: () => AstNode[];
  parent: Parent | null;
  position: Position | null;
}

// @public (undocumented)
export interface BaseOperator<T> extends AstNode {
  text: string;
  value: T;
}

// @public (undocumented)
export const CATEGORY_FIELD = 'category';

// @public (undocumented)
export const CHANGED_OPERATORS: readonly ['changed'];

// @public (undocumented)
export type ChangedOperator = BaseOperator<ChangedOperatorValue>;

// @public (undocumented)
export type ChangedOperatorValue = (typeof CHANGED_OPERATORS)[number];

// @public
export type Clause = CompoundClause | NotClause | TerminalClause;

// @public (undocumented)
export const CLAUSE_OPERATOR_NOT = 'not';

// @public (undocumented)
export const CLAUSE_TYPE_COMPOUND = 'compound';

// @public (undocumented)
export const CLAUSE_TYPE_NOT = 'not';

// @public (undocumented)
export const CLAUSE_TYPE_TERMINAL = 'terminal';

// @public (undocumented)
export const COLLAPSED_CUSTOM_FIELD_PATTERN: RegExp;

// @public (undocumented)
export const COLLAPSED_CUSTOM_FIELD_PATTERN_NO_QUOTES: RegExp;

// @public (undocumented)
export const COMPARISON_OPERATORS: readonly ['<', '>', '<=', '>='];

// @public (undocumented)
export type ComparisonOperator = BaseOperator<ComparisonOperatorValue>;

// @public (undocumented)
export type ComparisonOperatorValue = (typeof COMPARISON_OPERATORS)[number];

// @public (undocumented)
export const COMPONENT_FIELD = 'component';

// @public (undocumented)
export const COMPOUND_OPERATOR_AND = 'and';

// @public (undocumented)
export const COMPOUND_OPERATOR_OR = 'or';

// @public
export interface CompoundClause
  extends AstNode<ParentOfClause & AstNode>,
    Removable,
    Replaceable<Clause>,
    ParentOfClause {
  appendClause: (clause: Clause) => void;
  clauses: Clause[];
  // (undocumented)
  clauseType: typeof CLAUSE_TYPE_COMPOUND;
  operator: CompoundOperator;
  // (undocumented)
  type: typeof NODE_TYPE_CLAUSE;
}

// @public
export interface CompoundOperator extends AstNode {
  positions: Position[];
  value: CompoundOperatorValue;
}

// @public (undocumented)
export type CompoundOperatorValue =
  | typeof COMPOUND_OPERATOR_AND
  | typeof COMPOUND_OPERATOR_OR;

// @public (undocumented)
export const computeJqlInsights: (jast: Jast) => JqlInsightsAttributes;

// @public (undocumented)
export const CREATED_FIELD = 'created';

// @public (undocumented)
export const CREATOR_PROPERTY = 'creator.property';

// @public (undocumented)
export const creators: {
  query: (where: Clause | void, orderBy?: OrderBy | undefined) => Query;
  compoundClause: (
    operator: CompoundOperator,
    clauses: Clause[],
  ) => CompoundClause;
  compoundOperator: (value: CompoundOperatorValue) => CompoundOperator;
  terminalClause: (
    field: Field,
    operator?: Operator | undefined,
    operand?: Operand | undefined,
    predicates?: Predicate[],
  ) => TerminalClause;
  notClause: (clause: Clause) => NotClause;
  notClauseOperator: () => NotClauseOperator;
  predicate: (
    operator: PredicateOperator,
    operand?: Operand | undefined,
  ) => Predicate;
  predicateOperator: (
    value: 'after' | 'before' | 'by' | 'during' | 'from' | 'on' | 'to',
  ) => PredicateOperator;
  field: (value: string, properties?: Property[] | undefined) => Field;
  property: (key: Argument | void, path?: Argument[]) => Property;
  operator: (
    value:
      | '!='
      | '!~'
      | '<'
      | '<='
      | '='
      | '>'
      | '>='
      | 'changed'
      | 'in'
      | 'is not'
      | 'is'
      | 'not in'
      | 'was in'
      | 'was not in'
      | 'was not'
      | 'was'
      | '~',
  ) => Operator;
  valueOperand: (value: string) => ValueOperand;
  keywordOperand: () => KeywordOperand;
  functionOperand: (
    functionString: FunctionString,
    args?: Argument[],
  ) => FunctionOperand;
  functionString: (value: string) => FunctionString;
  argument: (value: string) => Argument;
  listOperand: (values: Operand[]) => ListOperand;
  orderBy: (fields: OrderByField[]) => OrderBy;
  orderByOperator: () => OrderByOperator;
  orderByField: (
    field: Field,
    direction?: OrderByDirection | undefined,
  ) => OrderByField;
  orderByDirection: (value: OrderByDirectionValue) => OrderByDirection;
  byText: {
    argument: (text: string) => Argument;
    valueOperand: (text: string) => ValueOperand;
  };
};

// @public (undocumented)
export const DESCRIPTION_FIELD = 'description';

// @public (undocumented)
export const DEVELOPMENT_FIELD = 'development';

// @public (undocumented)
export const DUE_DATE_FIELD = 'duedate';

// @public (undocumented)
export const ENVIRONMENT_FIELD = 'environment';

// @public (undocumented)
export const EPIC_LINK_FIELD = 'epic link';

// @public (undocumented)
export const EQUALS_OPERATORS: readonly ['=', '!='];

// @public (undocumented)
export type EqualsOperator = BaseOperator<EqualsOperatorValue>;

// @public (undocumented)
export type EqualsOperatorValue = (typeof EQUALS_OPERATORS)[number];

// @public
export interface Field extends AstNode {
  properties: Property[] | void;
  text: string;
  value: string;
}

// @public (undocumented)
export const FILTER_FIELD = 'filter';

// @public (undocumented)
export const FIX_VERSION_FIELD = 'fixversion';

// @public
export interface FunctionOperand extends AstNode {
  arguments: Argument[];
  function: FunctionString;
  // (undocumented)
  operandType: typeof OPERAND_TYPE_FUNCTION;
  // (undocumented)
  type: typeof NODE_TYPE_OPERAND;
}

// @public
export interface FunctionString extends AstNode {
  text: string;
  value: string;
}

// @public (undocumented)
export const IN_OPERATORS: readonly ['in', 'not in'];

// @public (undocumented)
export type InOperator = BaseOperator<InOperatorValue>;

// @public (undocumented)
export type InOperatorValue = (typeof IN_OPERATORS)[number];

// @public (undocumented)
export const IS_OPERATORS: readonly ['is', 'is not'];

// @public (undocumented)
export const isChangedOperator: (operator: string) => operator is 'changed';

// @public (undocumented)
export const isComparisonOperator: (
  operator: string,
) => operator is '<' | '<=' | '>' | '>=';

// @public (undocumented)
export const isEqualsOperator: (operator: string) => operator is '!=' | '=';

// @public (undocumented)
export const isInOperator: (operator: string) => operator is 'in' | 'not in';

// @public (undocumented)
export const isIsOperator: (operator: string) => operator is 'is not' | 'is';

// @public (undocumented)
export const isLikeOperator: (operator: string) => operator is '!~' | '~';

// @public (undocumented)
export const isListOperator: (
  operator: string,
) => operator is 'in' | 'not in' | 'was in' | 'was not in';

// @public (undocumented)
export const isOperandNode: (
  maybeOperandNode: AstNode,
) => maybeOperandNode is Operand;

// @public (undocumented)
export type IsOperator = BaseOperator<IsOperatorValue>;

// @public (undocumented)
export const isOperator: (
  operator: string,
) => operator is
  | '!='
  | '!~'
  | '<'
  | '<='
  | '='
  | '>'
  | '>='
  | 'changed'
  | 'in'
  | 'is not'
  | 'is'
  | 'not in'
  | 'was in'
  | 'was not in'
  | 'was not'
  | 'was'
  | '~';

// @public (undocumented)
export type IsOperatorValue = (typeof IS_OPERATORS)[number];

// @public (undocumented)
export const isPredicateOperator: (
  operator: string,
) => operator is 'after' | 'before' | 'by' | 'during' | 'from' | 'on' | 'to';

// @public (undocumented)
export const ISSUE_KEY_FIELD = 'issuekey';

// @public (undocumented)
export const ISSUE_PROPERTY = 'issue.property';

// @public (undocumented)
export const ISSUE_TYPE_FIELD = 'issuetype';

// @public (undocumented)
export const isWasInOperator: (
  operator: string,
) => operator is 'was in' | 'was not in';

// @public (undocumented)
export const isWasOperator: (operator: string) => operator is 'was not' | 'was';

// @public
export interface Jast {
  errors: JQLParseError[];
  query: Query | void;
  represents: string;
}

// @public (undocumented)
export class JastBuilder {
  // (undocumented)
  build(value: string): Jast;
  // (undocumented)
  setErrorHandler(errorHandler: ANTLRErrorStrategy): JastBuilder;
  // (undocumented)
  setErrorListeners(errorListeners: ParserErrorListener[]): JastBuilder;
}

// @public
export interface JastListener {
  // (undocumented)
  enterArgument?: (argument: Argument) => void;
  // (undocumented)
  enterCompoundClause?: (compoundClause: CompoundClause) => void;
  // (undocumented)
  enterCompoundOperator?: (compoundOperator: CompoundOperator) => void;
  // (undocumented)
  enterEveryNode?: (query: AstNode) => void;
  // (undocumented)
  enterField?: (field: Field) => void;
  // (undocumented)
  enterFunction?: (functionString: FunctionString) => void;
  // (undocumented)
  enterFunctionOperand?: (functionOperand: FunctionOperand) => void;
  // (undocumented)
  enterKeywordOperand?: (keywordOperand: KeywordOperand) => void;
  // (undocumented)
  enterListOperand?: (listOperand: ListOperand) => void;
  // (undocumented)
  enterNotClause?: (notClause: NotClause) => void;
  // (undocumented)
  enterNotClauseOperator?: (notClauseOperator: NotClauseOperator) => void;
  // (undocumented)
  enterOperator?: (operator: Operator) => void;
  // (undocumented)
  enterOrderBy?: (orderBy: OrderBy) => void;
  // (undocumented)
  enterOrderByDirection?: (orderByDirection: OrderByDirection) => void;
  // (undocumented)
  enterOrderByField?: (orderByField: OrderByField) => void;
  // (undocumented)
  enterOrderByOperator?: (orderByOperator: OrderByOperator) => void;
  // (undocumented)
  enterPredicate?: (predicate: Predicate) => void;
  // (undocumented)
  enterPredicateOperator?: (predicateOperator: PredicateOperator) => void;
  // (undocumented)
  enterProperty?: (field: Property) => void;
  // (undocumented)
  enterQuery?: (query: Query) => void;
  // (undocumented)
  enterTerminalClause?: (terminalClause: TerminalClause) => void;
  // (undocumented)
  enterValueOperand?: (valueOperand: ValueOperand) => void;
  // (undocumented)
  exitArgument?: (argument: Argument) => void;
  // (undocumented)
  exitCompoundClause?: (compoundClause: CompoundClause) => void;
  // (undocumented)
  exitCompoundOperator?: (compoundOperator: CompoundOperator) => void;
  // (undocumented)
  exitEveryNode?: (query: AstNode) => void;
  // (undocumented)
  exitField?: (field: Field) => void;
  // (undocumented)
  exitFunction?: (functionString: FunctionString) => void;
  // (undocumented)
  exitFunctionOperand?: (functionOperand: FunctionOperand) => void;
  // (undocumented)
  exitKeywordOperand?: (keywordOperand: KeywordOperand) => void;
  // (undocumented)
  exitListOperand?: (listOperand: ListOperand) => void;
  // (undocumented)
  exitNotClause?: (notClause: NotClause) => void;
  // (undocumented)
  exitNotClauseOperator?: (notClauseOperator: NotClauseOperator) => void;
  // (undocumented)
  exitOperator?: (operator: Operator) => void;
  // (undocumented)
  exitOrderBy?: (orderBy: OrderBy) => void;
  // (undocumented)
  exitOrderByDirection?: (orderByDirection: OrderByDirection) => void;
  // (undocumented)
  exitOrderByField?: (orderByField: OrderByField) => void;
  // (undocumented)
  exitOrderByOperator?: (orderByOperator: OrderByOperator) => void;
  // (undocumented)
  exitPredicate?: (predicate: Predicate) => void;
  // (undocumented)
  exitPredicateOperator?: (predicateOperator: PredicateOperator) => void;
  // (undocumented)
  exitProperty?: (field: Property) => void;
  // (undocumented)
  exitQuery?: (query: Query) => void;
  // (undocumented)
  exitTerminalClause?: (terminalClause: TerminalClause) => void;
  // (undocumented)
  exitValueOperand?: (valueOperand: ValueOperand) => void;
}

// @public
export interface JastVisitor<Result> {
  visit(node: AstNode): Result;
  // (undocumented)
  visitArgument?: (argument: Argument) => Result;
  visitChildren(node: AstNode): Result;
  // (undocumented)
  visitCompoundClause?: (compoundClause: CompoundClause) => Result;
  // (undocumented)
  visitCompoundOperator?: (compoundOperator: CompoundOperator) => Result;
  // (undocumented)
  visitField?: (field: Field) => Result;
  // (undocumented)
  visitFunction?: (functionString: FunctionString) => Result;
  // (undocumented)
  visitFunctionOperand?: (functionOperand: FunctionOperand) => Result;
  // (undocumented)
  visitKeywordOperand?: (keywordOperand: KeywordOperand) => Result;
  // (undocumented)
  visitListOperand?: (listOperand: ListOperand) => Result;
  // (undocumented)
  visitNotClause?: (notClause: NotClause) => Result;
  // (undocumented)
  visitNotClauseOperator?: (notClauseOperator: NotClauseOperator) => Result;
  // (undocumented)
  visitOperator?: (operator: Operator) => Result;
  // (undocumented)
  visitOrderBy?: (orderBy: OrderBy) => Result;
  // (undocumented)
  visitOrderByDirection?: (orderByDirection: OrderByDirection) => Result;
  // (undocumented)
  visitOrderByField?: (orderByField: OrderByField) => Result;
  // (undocumented)
  visitOrderByOperator?: (orderByOperator: OrderByOperator) => Result;
  // (undocumented)
  visitPredicate?: (predicate: Predicate) => Result;
  // (undocumented)
  visitPredicateOperator?: (predicateOperator: PredicateOperator) => Result;
  // (undocumented)
  visitProperty?: (property: Property) => Result;
  // (undocumented)
  visitQuery?: (query: Query) => Result;
  // (undocumented)
  visitTerminalClause?: (terminalClause: TerminalClause) => Result;
  // (undocumented)
  visitValueOperand?: (valueOperand: ValueOperand) => Result;
}

// @public (undocumented)
export class JqlAnonymizerVisitor extends AbstractJastVisitor<string> {
  // (undocumented)
  protected defaultResult(): string;
  // (undocumented)
  visitCompoundClause: (compoundClause: CompoundClause) => string;
  // (undocumented)
  visitField: (field: Field) => string;
  // (undocumented)
  visitFunctionOperand: (functionOperand: FunctionOperand) => string;
  // (undocumented)
  visitKeywordOperand: (keywordOperand: KeywordOperand) => string;
  // (undocumented)
  visitListOperand: (listOperand: ListOperand) => string;
  // (undocumented)
  visitNotClause: (notClause: NotClause) => string;
  // (undocumented)
  visitOrderBy: (orderBy: OrderBy) => string;
  // (undocumented)
  visitPredicate: (predicate: Predicate) => string;
  // (undocumented)
  visitQuery: (query: Query) => string;
  // (undocumented)
  visitTerminalClause: (terminalClause: TerminalClause) => string;
  // (undocumented)
  visitValueOperand: () => string;
}

// @public
export type JqlInsightsAttributes = {
  jqlFieldValueCount: {
    issueType: number;
    project: number;
    assignee: number;
    reporter: number;
    priority: number;
    status: number;
    resolution: number;
    team: number;
  };
  jqlFieldIsUsed: {
    summary: boolean;
    due: boolean;
    resolutionDate: boolean;
    created: boolean;
    lastviewed: boolean;
    updated: boolean;
    team: boolean;
  };
  jqlUsedFields: string[];
  jqlUsedFieldsCount: number;
  jqlUsedFieldsOrderBy: string[];
  jqlLineCount: number;
  jqlErrorCount: number;
  jqlClauseCount: {
    orderBy: number;
    leaf: number;
    and: number;
    not: number;
    or: number;
  };
  jqlMaxCompoundClauseDepth: number;
};

// @public
export class JQLParseError extends Error {
  constructor(message: string, cause?: Error);
  cause?: Error;
  description: string;
}

// @public
export class JQLSyntaxError extends JQLParseError {
  constructor(
    message: string,
    start: number,
    stop: number,
    line: number,
    charPositionInLine: number,
  );
  charPositionInLine: number;
  line: number;
  start: number;
  stop: number;
}

// @public
export interface KeywordOperand extends AstNode {
  // (undocumented)
  operandType: typeof OPERAND_TYPE_KEYWORD;
  // (undocumented)
  type: typeof NODE_TYPE_OPERAND;
  value: KeywordOperandValue;
}

// @public (undocumented)
export type KeywordOperandValue = typeof OPERAND_EMPTY;

// @public (undocumented)
export const LABELS_FIELD = 'labels';

// @public (undocumented)
export const LAST_VIEWED_FIELD = 'lastviewed';

// @public (undocumented)
export const LIKE_OPERATORS: readonly ['~', '!~'];

// @public (undocumented)
export type LikeOperator = BaseOperator<LikeOperatorValue>;

// @public (undocumented)
export type LikeOperatorValue = (typeof LIKE_OPERATORS)[number];

// @public (undocumented)
export const LIST_OPERATORS: readonly ['in', 'not in', 'was in', 'was not in'];

// @public
export interface ListOperand extends AstNode {
  appendOperand: (this: ListOperand, operand: Operand) => void;
  // (undocumented)
  operandType: typeof OPERAND_TYPE_LIST;
  // (undocumented)
  type: typeof NODE_TYPE_OPERAND;
  values: Operand[];
}

// @public (undocumented)
export type ListOperatorValue = (typeof LIST_OPERATORS)[number];

// @public (undocumented)
export const NODE_TYPE_CLAUSE = 'clause';

// @public (undocumented)
export const NODE_TYPE_OPERAND = 'operand';

// @public (undocumented)
export const NODE_TYPE_ORDER_BY = 'order_by';

// @public (undocumented)
export const NODE_TYPE_QUERY = 'query';

// @public
export const normaliseJqlString: (maybeQuotedString: string) => string;

// @public
export interface NotClause
  extends AstNode<ParentOfClause & AstNode>,
    Removable,
    Replaceable<Clause>,
    ParentOfClause {
  // (undocumented)
  clause: Clause;
  // (undocumented)
  clauseType: typeof CLAUSE_TYPE_NOT;
  // (undocumented)
  operator: NotClauseOperator;
  // (undocumented)
  type: typeof NODE_TYPE_CLAUSE;
}

// @public
export interface NotClauseOperator extends AstNode {
  // (undocumented)
  value: typeof CLAUSE_OPERATOR_NOT;
}

// @public
export type Operand =
  | FunctionOperand
  | KeywordOperand
  | ListOperand
  | ValueOperand;

// @public (undocumented)
export const OPERAND_EMPTY = 'empty';

// @public (undocumented)
export const OPERAND_TYPE_FUNCTION = 'function';

// @public (undocumented)
export const OPERAND_TYPE_KEYWORD = 'keyword';

// @public (undocumented)
export const OPERAND_TYPE_LIST = 'list';

// @public (undocumented)
export const OPERAND_TYPE_VALUE = 'value';

// @public (undocumented)
export type OperandType =
  | typeof OPERAND_TYPE_FUNCTION
  | typeof OPERAND_TYPE_KEYWORD
  | typeof OPERAND_TYPE_LIST
  | typeof OPERAND_TYPE_VALUE;

// @public (undocumented)
export type Operator =
  | ChangedOperator
  | ComparisonOperator
  | EqualsOperator
  | InOperator
  | IsOperator
  | LikeOperator
  | WasInOperator
  | WasOperator;

// @public (undocumented)
export const OPERATOR_CHANGED = 'changed';

// @public (undocumented)
export const OPERATOR_EQUALS = '=';

// @public (undocumented)
export const OPERATOR_GT = '>';

// @public (undocumented)
export const OPERATOR_GT_EQUALS = '>=';

// @public (undocumented)
export const OPERATOR_IN = 'in';

// @public (undocumented)
export const OPERATOR_IS = 'is';

// @public (undocumented)
export const OPERATOR_IS_NOT = 'is not';

// @public (undocumented)
export const OPERATOR_LIKE = '~';

// @public (undocumented)
export const OPERATOR_LT = '<';

// @public (undocumented)
export const OPERATOR_LT_EQUALS = '<=';

// @public (undocumented)
export const OPERATOR_NOT_EQUALS = '!=';

// @public (undocumented)
export const OPERATOR_NOT_IN = 'not in';

// @public (undocumented)
export const OPERATOR_NOT_LIKE = '!~';

// @public (undocumented)
export const OPERATOR_WAS = 'was';

// @public (undocumented)
export const OPERATOR_WAS_IN = 'was in';

// @public (undocumented)
export const OPERATOR_WAS_NOT = 'was not';

// @public (undocumented)
export const OPERATOR_WAS_NOT_IN = 'was not in';

// @public (undocumented)
export const OPERATORS: readonly [
  '=',
  '!=',
  '~',
  '!~',
  '<',
  '>',
  '<=',
  '>=',
  'in',
  'not in',
  'is',
  'is not',
  'was',
  'was not',
  'was in',
  'was not in',
  'changed',
];

// @public (undocumented)
export type OperatorValue = (typeof OPERATORS)[number];

// @public (undocumented)
export const ORDER_BY_DIRECTION_ASC = 'ASC';

// @public (undocumented)
export const ORDER_BY_DIRECTION_DESC = 'DESC';

// @public (undocumented)
export const ORDER_BY_OPERATOR_ORDER_BY = 'ORDER BY';

// @public
export interface OrderBy extends AstNode {
  fields: OrderByField[];
  operator: OrderByOperator;
  prependOrderField: (orderField: OrderByField) => void;
  setOrderDirection: (orderDirection: OrderByDirection) => void;
  // (undocumented)
  type: typeof NODE_TYPE_ORDER_BY;
}

// @public
export interface OrderByDirection extends AstNode {
  value: OrderByDirectionValue;
}

// @public (undocumented)
export type OrderByDirectionValue =
  | typeof ORDER_BY_DIRECTION_ASC
  | typeof ORDER_BY_DIRECTION_DESC;

// @public
export interface OrderByField extends AstNode {
  direction: OrderByDirection | void;
  field: Field;
  setOrderDirection: (orderDirection: OrderByDirection) => void;
}

// @public
export interface OrderByOperator extends AstNode {
  value: typeof ORDER_BY_OPERATOR_ORDER_BY;
}

// @public (undocumented)
export const PARENT_FIELD = 'parent';

// @public (undocumented)
export interface ParentOfClause {
  removeClause: (clause: Clause) => void;
  replaceClause: (clause: Clause, nextClause: Clause) => void;
}

// @public
export type Position = [number, number];

// @public
export interface Predicate extends AstNode {
  operand: Operand | void;
  operator: PredicateOperator;
}

// @public (undocumented)
export const PREDICATE_OPERATOR_AFTER = 'after';

// @public (undocumented)
export const PREDICATE_OPERATOR_BEFORE = 'before';

// @public (undocumented)
export const PREDICATE_OPERATOR_BY = 'by';

// @public (undocumented)
export const PREDICATE_OPERATOR_DURING = 'during';

// @public (undocumented)
export const PREDICATE_OPERATOR_FROM = 'from';

// @public (undocumented)
export const PREDICATE_OPERATOR_ON = 'on';

// @public (undocumented)
export const PREDICATE_OPERATOR_TO = 'to';

// @public (undocumented)
export const PREDICATE_OPERATORS: readonly [
  'after',
  'before',
  'by',
  'during',
  'from',
  'on',
  'to',
];

// @public
export interface PredicateOperator extends AstNode {
  text: string;
  value: PredicateOperatorValue;
}

// @public (undocumented)
export type PredicateOperatorValue = (typeof PREDICATE_OPERATORS)[number];

// @public
const print_2: (jast: Jast, options?: PrintOptions) => string;
export { print_2 as print };

// @public (undocumented)
type PrintOptions = {
  printWidth?: null | number;
};

// @public (undocumented)
export const PRIORITY_FIELD = 'priority';

// @public (undocumented)
export const PRIVACY_SAFE_FIELDS: string[];

// @public (undocumented)
export const PROJECT_FIELD = 'project';

// @public (undocumented)
export const PROJECT_PROPERTY = 'project.property';

// @public
export interface Property extends AstNode {
  key: Argument | void;
  path: Argument[] | void;
}

// @public
export interface Query extends AstNode, ParentOfClause {
  appendClause: (
    clause: Clause,
    compoundOperatorValue: CompoundOperatorValue,
  ) => void;
  orderBy: OrderBy | void;
  prependOrderField: (orderField: OrderByField) => void;
  setOrderDirection: (orderDirection: OrderByDirection) => void;
  // (undocumented)
  type: typeof NODE_TYPE_QUERY;
  where: Clause | void;
}

// @public
export interface Removable {
  remove: () => void;
}

// @public
export interface Replaceable<T extends AstNode> {
  replace: (node: T) => void;
}

// @public (undocumented)
export const REPORTER_FIELD = 'reporter';

// @public (undocumented)
export const REPORTER_PROPERTY = 'reporter.property';

// @public (undocumented)
export const RESOLUTION_DATE_FIELD = 'resolutiondate';

// @public (undocumented)
export const RESOLUTION_FIELD = 'resolution';

// @public (undocumented)
export const RESOLVED_FIELD = 'resolved';

// @public
export const sanitiseJqlString: (jqlString: string) => string;

// @public (undocumented)
export const SPRINT_FIELD = 'sprint';

// @public (undocumented)
export const STATUS_CATEGORY_FIELD = 'statuscategory';

// @public (undocumented)
export const STATUS_FIELD = 'status';

// @public
export type StringValue = {
  text: string;
  value: string;
  position: Position | null;
};

// @public (undocumented)
export const SUMMARY_FIELD = 'summary';

// @public (undocumented)
export const TEAM_CUSTOM_FIELD_TYPE = '[team]';

// @public
export interface TerminalClause
  extends AstNode<ParentOfClause & AstNode>,
    Removable,
    Replaceable<Clause> {
  appendOperand: (this: TerminalClause, operand: Operand) => void;
  // (undocumented)
  clauseType: typeof CLAUSE_TYPE_TERMINAL;
  field: Field;
  operand: Operand | void;
  operator: Operator | void;
  predicates: Predicate[];
  setOperand: (this: TerminalClause, operand: Operand) => void;
  setOperator: (this: TerminalClause, operator: Operator) => void;
  // (undocumented)
  type: typeof NODE_TYPE_CLAUSE;
}

// @public (undocumented)
export type TerminalClauseRhs = Pick<
  TerminalClause,
  'operand' | 'operator' | 'predicates'
>;

// @public (undocumented)
export const TEXT_FIELD = 'text';

// @public (undocumented)
export const TYPE_FIELD = 'type';

// @public (undocumented)
export const UPDATED_FIELD = 'updated';

// @public
export interface ValueOperand extends AstNode {
  // (undocumented)
  operandType: typeof OPERAND_TYPE_VALUE;
  text: string;
  // (undocumented)
  type: typeof NODE_TYPE_OPERAND;
  value: string;
}

// @public (undocumented)
export const VOTER_PROPERTY = 'voter.property';

// @public
export const walkAST: (listener: JastListener, jast: Jast) => void;

// @public (undocumented)
export const WAS_IN_OPERATORS: readonly ['was in', 'was not in'];

// @public (undocumented)
export const WAS_OPERATORS: readonly ['was', 'was not'];

// @public (undocumented)
export type WasInOperator = BaseOperator<WasInOperatorValue>;

// @public (undocumented)
export type WasInOperatorValue = (typeof WAS_IN_OPERATORS)[number];

// @public (undocumented)
export type WasOperator = BaseOperator<WasOperatorValue>;

// @public (undocumented)
export type WasOperatorValue = (typeof WAS_OPERATORS)[number];

// @public (undocumented)
export const WATCHER_PROPERTY = 'watcher.property';

// (No @packageDocumentation comment for this package)
```

<!--SECTION END: Main Entry Types-->

### Peer Dependencies

<!--SECTION START: Peer Dependencies-->

```json
{}
```

<!--SECTION END: Peer Dependencies-->
