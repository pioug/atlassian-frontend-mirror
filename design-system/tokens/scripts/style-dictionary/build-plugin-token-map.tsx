/*
 * Generate JSON of constants for the SWC tokens plugin.
 * Sources: codegen JS artifacts in prebuilt/artifacts (produced by `yarn build tokens`).
 */
import fs from 'fs';
import path from 'path';

import json5 from 'json5';

import { createSignedArtifact } from '@atlassian/codegen';

// Type definitions for token structures
interface ShadowToken {
	radius: number;
	offset: {
		x: number;
		y: number;
	};
	color: string;
	opacity: number;
	spread?: number;
	inset?: boolean;
}

type TokenValue = string | number | ShadowToken[];

interface TokenAttributes {
	group: string;
	state: string;
	introduced: string;
	description: string;
	suggest?: string[];
	deprecated?: string;
}

interface Token {
	value: TokenValue;
	filePath: string;
	isSource: boolean;
	attributes: TokenAttributes;
	original: {
		value: TokenValue;
		attributes: TokenAttributes;
	};
	name: string;
	path: string[];
	cleanName: string;
}

type FormattedTokens = Record<string, string>;

const packageRoot = path.resolve(__dirname, '../..');
const prebuiltRoot = path.join(packageRoot, 'prebuilt', 'artifacts');

function requireJsonish(modulePath: string) {
	// prebuilt artifacts are CJS default exports
	const mod = require(modulePath);
	return mod && mod.__esModule && 'default' in mod ? mod.default : mod;
}

function getThemeValues(theme: Token[]): FormattedTokens {
	return theme.reduce((formatted: FormattedTokens, rawToken: Token) => {
		let value;
		if (typeof rawToken.value === 'string') {
			value = rawToken.value;
		} else if (typeof rawToken.value === 'number') {
			value = String(rawToken.value);
		} else if (Array.isArray(rawToken.value)) {
			value = rawToken.value.reduce((prev: string, curr: ShadowToken, index: number) => {
				let { color } = curr;
				if (typeof color === 'string' && color.length === 7 && curr.opacity) {
					const opacityAsHex = curr.opacity.toString(16);
					let shortenedHex = opacityAsHex.slice(2, 4);
					if (shortenedHex.length === 1) {
						shortenedHex += '0';
					}
					color += shortenedHex;
				}
				let v = `${curr.offset.x}px ${curr.offset.y}px ${curr.radius}px ${color}`;
				if (index === 0) {
					v += `, `;
				}
				return prev + v;
			}, '');
		} else {
			// Unknown value shape â€“ default to string coercion to avoid crashing codegen
			value = String(rawToken.value);
		}
		return { ...formatted, [rawToken.cleanName]: value };
	}, {});
}

async function main() {
	const tokenNames = requireJsonish(path.join(prebuiltRoot, 'token-names.js'));
	const light = requireJsonish(path.join(prebuiltRoot, 'tokens-raw', 'atlassian-light.js'));
	const shape = requireJsonish(path.join(prebuiltRoot, 'tokens-raw', 'atlassian-shape.js'));
	const spacing = requireJsonish(path.join(prebuiltRoot, 'tokens-raw', 'atlassian-spacing.js'));
	const typography = requireJsonish(
		path.join(prebuiltRoot, 'tokens-raw', 'atlassian-typography.js'),
	);

	const lightValues = getThemeValues(light);
	const shapeValues = getThemeValues(shape);
	const spacingValues = getThemeValues(spacing);
	const typographyValues = getThemeValues(typography);

	const header = `// @generated by scripts/style-dictionary/build-plugin-token-map.tsx\n// DO NOT EDIT MANUALLY\n`;
	const tokens = {
		tokenNames,
		light: lightValues,
		shape: shapeValues,
		spacing: spacingValues,
		typography: typographyValues,
	};

	const outDir = path.resolve(packageRoot, 'src/artifacts');
	fs.mkdirSync(outDir, { recursive: true });
	const body = json5.stringify(tokens, null, '\t');
	const content = `${header}\n${body}\n`;
	const signed = createSignedArtifact(content, 'yarn codegen-tokens');
	const outFile = path.join(outDir, 'token-data.json5');
	fs.writeFileSync(outFile, signed);
	// eslint-disable-next-line no-console
	console.log(`Wrote JSON token data to ${outFile}`);
}

main().catch((e) => {
	// eslint-disable-next-line no-console
	console.error('[build-plugin-token-map] failed:', e);
	process.exitCode = 1;
});
