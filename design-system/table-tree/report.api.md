## API Report File for "@atlaskit/table-tree"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
/// <reference types="react" />

import { Component } from 'react';
import { Context } from 'react';
import { ErrorInfo } from 'react';
import PropTypes from 'prop-types';
import { default as React_2 } from 'react';
import { ReactInstance } from 'react';
import { ReactNode } from 'react';
import { Validator } from 'prop-types';
import { WithAnalyticsEventsProps } from '@atlaskit/analytics-next';
import { WithContextProps } from '@atlaskit/analytics-next';

// @public (undocumented)
export const Cell: {
  new (props: Readonly<CellProps & CellWithColumnWidthProps>): {
    UNSAFE_componentWillMount(): void;
    setColumnWidth(width?: string | number | undefined): void;
    UNSAFE_componentWillReceiveProps(nextProps: CellWithColumnWidthProps): void;
    render(): JSX.Element;
    context: any;
    setState<K extends never>(
      state:
        | {}
        | ((
            prevState: Readonly<{}>,
            props: Readonly<CellProps & CellWithColumnWidthProps>,
          ) => {} | Pick<{}, K> | null)
        | Pick<{}, K>
        | null,
      callback?: (() => void) | undefined,
    ): void;
    forceUpdate(callBack?: (() => void) | undefined): void;
    readonly props: Readonly<CellProps & CellWithColumnWidthProps> &
      Readonly<{
        children?: React_2.ReactNode;
      }>;
    state: Readonly<{}>;
    refs: {
      [key: string]: React_2.ReactInstance;
    };
    componentDidMount?(): void;
    shouldComponentUpdate?(
      nextProps: Readonly<CellProps & CellWithColumnWidthProps>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): boolean;
    componentWillUnmount?(): void;
    componentDidCatch?(error: Error, errorInfo: React_2.ErrorInfo): void;
    getSnapshotBeforeUpdate?(
      prevProps: Readonly<CellProps & CellWithColumnWidthProps>,
      prevState: Readonly<{}>,
    ): any;
    componentDidUpdate?(
      prevProps: Readonly<CellProps & CellWithColumnWidthProps>,
      prevState: Readonly<{}>,
      snapshot?: any,
    ): void;
    componentWillMount?(): void;
    componentWillReceiveProps?(
      nextProps: Readonly<CellProps & CellWithColumnWidthProps>,
      nextContext: any,
    ): void;
    componentWillUpdate?(
      nextProps: Readonly<CellProps & CellWithColumnWidthProps>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): void;
    UNSAFE_componentWillUpdate?(
      nextProps: Readonly<CellProps & CellWithColumnWidthProps>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): void;
  };
  new (props: CellProps & CellWithColumnWidthProps, context?: any): {
    UNSAFE_componentWillMount(): void;
    setColumnWidth(width?: string | number | undefined): void;
    UNSAFE_componentWillReceiveProps(nextProps: CellWithColumnWidthProps): void;
    render(): JSX.Element;
    context: any;
    setState<K extends never>(
      state:
        | {}
        | ((
            prevState: Readonly<{}>,
            props: Readonly<CellProps & CellWithColumnWidthProps>,
          ) => {} | Pick<{}, K> | null)
        | Pick<{}, K>
        | null,
      callback?: (() => void) | undefined,
    ): void;
    forceUpdate(callBack?: (() => void) | undefined): void;
    readonly props: Readonly<CellProps & CellWithColumnWidthProps> &
      Readonly<{
        children?: React_2.ReactNode;
      }>;
    state: Readonly<{}>;
    refs: {
      [key: string]: React_2.ReactInstance;
    };
    componentDidMount?(): void;
    shouldComponentUpdate?(
      nextProps: Readonly<CellProps & CellWithColumnWidthProps>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): boolean;
    componentWillUnmount?(): void;
    componentDidCatch?(error: Error, errorInfo: React_2.ErrorInfo): void;
    getSnapshotBeforeUpdate?(
      prevProps: Readonly<CellProps & CellWithColumnWidthProps>,
      prevState: Readonly<{}>,
    ): any;
    componentDidUpdate?(
      prevProps: Readonly<CellProps & CellWithColumnWidthProps>,
      prevState: Readonly<{}>,
      snapshot?: any,
    ): void;
    componentWillMount?(): void;
    componentWillReceiveProps?(
      nextProps: Readonly<CellProps & CellWithColumnWidthProps>,
      nextContext: any,
    ): void;
    componentWillUpdate?(
      nextProps: Readonly<CellProps & CellWithColumnWidthProps>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): void;
    UNSAFE_componentWillUpdate?(
      nextProps: Readonly<CellProps & CellWithColumnWidthProps>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): void;
  };
  contextTypes: {
    tableTree: Validator<object>;
  };
  contextType?: React_2.Context<any> | undefined;
};

// @public (undocumented)
export interface CellProps {
  className?: string;
  indentLevel?: number;
  singleLine?: boolean;
  width?: number | string;
}

// @public (undocumented)
export interface CellWithColumnWidthProps {
  // (undocumented)
  columnIndex?: number;
  // (undocumented)
  width?: number | string;
}

// @public (undocumented)
export const Header: {
  new (props: Readonly<any>): {
    UNSAFE_componentWillMount(): void;
    setColumnWidth(width?: string | number | undefined): void;
    UNSAFE_componentWillReceiveProps(nextProps: CellWithColumnWidthProps): void;
    render(): JSX.Element;
    context: any;
    setState<K extends never>(
      state:
        | {}
        | ((
            prevState: Readonly<{}>,
            props: Readonly<any>,
          ) => {} | Pick<{}, K> | null)
        | Pick<{}, K>
        | null,
      callback?: (() => void) | undefined,
    ): void;
    forceUpdate(callBack?: (() => void) | undefined): void;
    readonly props: Readonly<any> &
      Readonly<{
        children?: ReactNode;
      }>;
    state: Readonly<{}>;
    refs: {
      [key: string]: ReactInstance;
    };
    componentDidMount?(): void;
    shouldComponentUpdate?(
      nextProps: Readonly<any>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): boolean;
    componentWillUnmount?(): void;
    componentDidCatch?(error: Error, errorInfo: ErrorInfo): void;
    getSnapshotBeforeUpdate?(
      prevProps: Readonly<any>,
      prevState: Readonly<{}>,
    ): any;
    componentDidUpdate?(
      prevProps: Readonly<any>,
      prevState: Readonly<{}>,
      snapshot?: any,
    ): void;
    componentWillMount?(): void;
    componentWillReceiveProps?(
      nextProps: Readonly<any>,
      nextContext: any,
    ): void;
    componentWillUpdate?(
      nextProps: Readonly<any>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): void;
    UNSAFE_componentWillUpdate?(
      nextProps: Readonly<any>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): void;
  };
  new (props: any, context?: any): {
    UNSAFE_componentWillMount(): void;
    setColumnWidth(width?: string | number | undefined): void;
    UNSAFE_componentWillReceiveProps(nextProps: CellWithColumnWidthProps): void;
    render(): JSX.Element;
    context: any;
    setState<K extends never>(
      state:
        | {}
        | ((
            prevState: Readonly<{}>,
            props: Readonly<any>,
          ) => {} | Pick<{}, K> | null)
        | Pick<{}, K>
        | null,
      callback?: (() => void) | undefined,
    ): void;
    forceUpdate(callBack?: (() => void) | undefined): void;
    readonly props: Readonly<any> &
      Readonly<{
        children?: ReactNode;
      }>;
    state: Readonly<{}>;
    refs: {
      [key: string]: ReactInstance;
    };
    componentDidMount?(): void;
    shouldComponentUpdate?(
      nextProps: Readonly<any>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): boolean;
    componentWillUnmount?(): void;
    componentDidCatch?(error: Error, errorInfo: ErrorInfo): void;
    getSnapshotBeforeUpdate?(
      prevProps: Readonly<any>,
      prevState: Readonly<{}>,
    ): any;
    componentDidUpdate?(
      prevProps: Readonly<any>,
      prevState: Readonly<{}>,
      snapshot?: any,
    ): void;
    componentWillMount?(): void;
    componentWillReceiveProps?(
      nextProps: Readonly<any>,
      nextContext: any,
    ): void;
    componentWillUpdate?(
      nextProps: Readonly<any>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): void;
    UNSAFE_componentWillUpdate?(
      nextProps: Readonly<any>,
      nextState: Readonly<{}>,
      nextContext: any,
    ): void;
  };
  contextTypes: {
    tableTree: Validator<object>;
  };
  contextType?: Context<any> | undefined;
};

// @public (undocumented)
class Headers_2 extends Component<any> {
  // (undocumented)
  render(): JSX.Element;
}
export { Headers_2 as Headers };

// @public (undocumented)
export const Row: React_2.ForwardRefExoticComponent<
  Pick<
    Pick<Omit<any, keyof WithAnalyticsEventsProps>, string | number | symbol> &
      React_2.RefAttributes<any> &
      WithContextProps,
    string | number | symbol
  > &
    React_2.RefAttributes<any>
>;

// @public (undocumented)
export class Rows<T> extends Component<RowsProps<T>> {
  // (undocumented)
  render(): JSX.Element;
}

// @public (undocumented)
export interface RowsProps<T> {
  // (undocumented)
  items?: WithChildren<T>[];
  // (undocumented)
  render: (args: WithChildren<T>) => React_2.ReactNode;
}

// @public (undocumented)
class TableTree extends Component<any, State> {
  // (undocumented)
  static childContextTypes: {
    tableTree: PropTypes.Validator<object>;
  };
  // (undocumented)
  componentDidMount(): void;
  // (undocumented)
  getChildContext(): {
    tableTree: {
      columnWidths: number[];
      setColumnWidth: (columnIndex: number, width: number) => void;
      getColumnWidth: (columnIndex: any) => number | null;
    };
  };
  // (undocumented)
  getColumnWidth: (columnIndex: any) => number | null;
  // (undocumented)
  render(): JSX.Element;
  // (undocumented)
  setColumnWidth: (columnIndex: number, width: number) => void;
  // (undocumented)
  state: State;
}
export default TableTree;

// @public
export class TableTreeDataHelper<T extends any = any> {
  constructor({ key }?: { key?: keyof T | undefined });
  // (undocumented)
  appendItems(items: T[], allItems?: T[], parentItem?: T | null): T[];
  // (undocumented)
  key: keyof T;
  // (undocumented)
  keysCache: any;
  // (undocumented)
  updateItems(items: T[], allItems?: T[], parentItem?: T | null): T[];
}

// (No @packageDocumentation comment for this package)
```
