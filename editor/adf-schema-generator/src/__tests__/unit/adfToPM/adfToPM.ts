import { adfToPmAutogeneratedMessage } from '../../../transforms/adfToPm/adfToPmAutogeneratedMessage';
import { adfToPm, transform } from '../../../transforms/adfToPm/adfToPm';
import { adfNode } from '../../../adfNode';
import { adfNodeGroup } from '../../../adfNodeGroup';
import { $or } from '../../../$or';
import {
	expectedMarks,
	expectedNodeGroups,
	expectedNodes,
	getTestAdfNode,
} from '../../__fixtures__/testAdfNode.fixture';

describe('code generation output', () => {
	function prepareResult(result: string) {
		return result
			.replace(adfToPmAutogeneratedMessage, '')
			.split('\n')
			.filter((part) => part !== '');
	}

	describe('node groups', () => {
		let generated: string;
		let generatedParts: string[];

		beforeAll(() => {
			const testDoc = getTestAdfNode();
			generated = adfToPm(testDoc)!.pmNodeGroups;
			generatedParts = prepareResult(generated);
		});

		test('should contain adfToPmAutogeneratedMessage', () => {
			expect(generated).toContain(adfToPmAutogeneratedMessage);
		});

		test('should contain only expected node groups', () => {
			expect(generatedParts.sort()).toEqual(expectedNodeGroups.sort());
		});
	});

	describe('node', () => {
		let generated: string;
		let generatedParts: string[];

		beforeAll(() => {
			const testDoc = getTestAdfNode();
			generated = adfToPm(testDoc)!.pmNodes;
			generatedParts = prepareResult(generated);
		});

		test('should contain adfToPmAutogeneratedMessage', () => {
			expect(generated).toContain(adfToPmAutogeneratedMessage);
		});

		test('should contain only expected nodes', () => {
			expect(generatedParts.sort()).toEqual(expectedNodes.sort());
		});
	});

	describe('marks', () => {
		let generated: string;
		let generatedParts: string[];

		beforeAll(() => {
			const testDoc = getTestAdfNode();
			generated = adfToPm(testDoc)!.pmMarks;
			generatedParts = prepareResult(generated);
		});

		test('should contain adfToPmAutogeneratedMessage', () => {
			expect(generated).toContain(adfToPmAutogeneratedMessage);
		});

		test('should contain only expected marks', () => {
			expect(generatedParts.sort()).toEqual(expectedMarks.sort());
		});
	});
});

describe('transform', () => {
	describe('node', () => {
		test('should generate nodeGroupMap correctly', () => {
			const testDoc = getTestAdfNode();
			// snapshot includes inlineDefinition and blockDefinition definitions
			expect(transform(testDoc).nodeGroupMap).toEqual({
				block: ['paragraph_with_alignment', 'paragraph_with_no_marks', 'decisionList'],
				blockRootOnly: [],
				inline: ['text_code_inline', 'emoji', 'placeholder', 'hardBreak'],
			});
		});

		test('should generate nodeSpec and nodeTypes correctly', () => {
			const testDoc = getTestAdfNode();
			expect(transform(testDoc).nodeResMap).toEqual({
				emoji: {
					nodeTypeDefinition: {
						attrs: {
							id: { default: '', optional: true, type: 'string' },
							shortName: { default: '', type: 'string' },
							text: { default: '', optional: true, type: 'string' },
						},
						content: [],
						marks: [],
						type: 'emoji',
					},
					pmNodeSpec: {
						attrs: {
							id: { default: '' },
							shortName: { default: '' },
							text: { default: '' },
						},
						group: 'inline',
						inline: true,
						selectable: true,
					},
				},
				hardBreak: {
					nodeTypeDefinition: {
						content: [],
						marks: [],
						type: 'hardBreak',
					},
					pmNodeSpec: {
						group: 'inline',
						inline: true,
						linebreakReplacement: true,
						selectable: false,
					},
				},
				paragraph_with_alignment: {
					nodeTypeDefinition: {
						attrs: undefined,
						content: ['InlineDefinition'],
						marks: ['AlignmentMark'],
						type: 'paragraph',
					},
					pmNodeSpec: {
						content: 'inline*',
						group: 'block',
						marks: 'code annotation',
						selectable: false,
					},
				},
				paragraph_with_no_marks: {
					nodeTypeDefinition: {
						attrs: undefined,
						content: ['InlineDefinition'],
						marks: [],
						type: 'paragraph',
					},
					pmNodeSpec: {
						content: 'inline*',
						group: 'block',
						marks: 'code annotation',
						selectable: false,
					},
				},
				testDoc: {
					nodeTypeDefinition: {
						attrs: undefined,
						content: ['BlockDefinition'],
						marks: [],
						type: 'testDoc',
					},
					pmNodeSpec: {
						content: '(block | blockRootOnly)+',
						marks: 'alignment',
					},
				},
				text_code_inline: {
					nodeTypeDefinition: {
						attrs: undefined,
						content: [],
						marks: ['CodeMark', 'AnnotationMark'],
						type: 'text',
					},
					pmNodeSpec: { group: 'inline' },
				},
				decisionList: {
					nodeTypeDefinition: {
						attrs: undefined,
						content: ['ParagraphWithAlignmentDefinition'],
						marks: [],
						type: 'decisionList',
					},
					pmNodeSpec: {
						content: 'paragraph+',
						selectable: false,
						group: 'block',
						marks: '_',
					},
				},
				placeholder: {
					nodeTypeDefinition: {
						attrs: undefined,
						content: [],
						marks: [],
						type: 'placeholder',
					},
					pmNodeSpec: {
						group: 'inline',
						inline: true,
						marks: '',
					},
				},
			});
		});
	});

	describe('node groups', () => {
		test('should not output ignored groups', () => {
			const paragraph = adfNode('paragraph').define({});
			const group = adfNodeGroup('block', [paragraph], {
				ignore: ['pm-spec'],
			});
			const root = adfNode('root').define({
				root: true,
				content: [$or(group, paragraph)],
			});

			const nodeResMap = transform(root).nodeResMap;
			expect(nodeResMap.paragraph.pmNodeSpec).toStrictEqual({});
		});

		test('should not output ignored groups when node has multiple groups', () => {
			const paragraph = adfNode('paragraph').define({});
			const group = adfNodeGroup('block', [paragraph], {
				ignore: ['pm-spec'],
			});
			const group2 = adfNodeGroup('block2', [paragraph]);
			const root = adfNode('root').define({
				root: true,
				content: [$or(group, group2, paragraph)],
			});

			const nodeResMap = transform(root).nodeResMap;
			expect(nodeResMap.paragraph.pmNodeSpec).toStrictEqual({
				group: 'block2',
			});
		});

		test('should correctly output miltiple groups', () => {
			const paragraph = adfNode('paragraph').define({});
			const group = adfNodeGroup('block', [paragraph]);
			const group2 = adfNodeGroup('block2', [paragraph]);
			const root = adfNode('root').define({
				root: true,
				content: [$or(group, group2, paragraph)],
			});

			const nodeResMap = transform(root).nodeResMap;
			expect(nodeResMap.paragraph.pmNodeSpec).toStrictEqual({
				group: 'block block2',
			});
		});

		test('should flatten special groups (pseudo groups)', () => {
			const paragraph = adfNode('paragraph').define({});
			const group = adfNodeGroup('non_nestable_block_content', [paragraph]);
			const root = adfNode('root').define({
				root: true,
				content: [$or(group)],
			});

			const nodeResMap = transform(root).nodeResMap;
			expect(nodeResMap.root.pmNodeSpec).toStrictEqual({
				content: 'paragraph',
			});
		});
	});
});
