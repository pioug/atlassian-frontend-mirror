// Shorthand alias for the global cache map key because it's (intentionally) a long name
const CACHE_MAP_KEY =
	'__conditionalHooksFactory_conditionCacheMap_dont_modify_this_manually_unless_you_want_react_to_blow_up';

declare global {
	// A global WeakMap to cache the initial condition result per hook instance when the gate is enabled
	var __conditionalHooksFactory_conditionCacheMap_dont_modify_this_manually_unless_you_want_react_to_blow_up: WeakMap<
		(...args: never[]) => unknown,
		boolean
	>;
}

// Initialize the global cache map once
globalThis[CACHE_MAP_KEY] =
	globalThis[CACHE_MAP_KEY] || new WeakMap<(...args: never[]) => unknown, boolean>();

/**
 * Resets the cache used by the conditional hooks factory.
 * This is useful for testing purposes or when you want to clear the cache between runs.
 * You should **never** use this in production code as it will break the rules of hooks.
 * Seriously, don't do it.
 *
 * Calling this function will cause all instances of conditional hooks to be re-evaluated
 * and may lead to unexpected behaviour if the conditions change.
 */
export function DO_NOT_USE_THIS_IN_PRODUCTION_EVER_resetConditionalHooksFactoryCache(): void {
	globalThis[CACHE_MAP_KEY] = new WeakMap();
}

/**
 * A factory function to create a conditional hook. The condition must return a boolean value
 * that does not change after initialisation. This function will cache the result of the condition
 * and use it to determine which hook to call. If the condition changes between renders,
 * unexpected behaviour may occur.
 *
 * The hook generated by this factory will also force the condition to be effectively constant
 * by caching the result of the condition on the first call. In non-production environments,
 * it will throw an error if the condition changes between renders to help catch potential issues.
 *
 * If for some reason you need to reset the cache (i.e. for tests where you change the condition between runs),
 * you can call `DO_NOT_USE_THIS_IN_PRODUCTION_EVER_resetConditionalHooksFactoryCache()`.
 *
 * **This hook should only be used for Feature Gates & Experiments where the value doesn't change.**
 * ```ts
 * // Acceptable use
 * const useMyHook = conditionalHooksFactory(
 *   () => isFeatureEnabled('my-feature'),
 *   useMyNewHook,
 *   useMyOldHook,
 * );
 *
 * // Not acceptable use
 * const useMyHook = conditionalHooksFactory(
 *    () => someVarThatCouldChange === 'my-value',
 *    useMyNewHook,
 *    useMyOldHook,
 * );
 * ```
 *
 * @param condition The condition function that will be used to determine which hook to call.
 * @param newHook The new hook to call if the condition is true.
 * @param oldHook The old hook to call if the condition is false.
 * @returns A migrator hook that will call either the new hook or the old hook based on the condition.
 */
export function conditionalHooksFactory<Result, A>(
	condition: () => boolean,
	newHook: (...args: A[]) => Result,
	oldHook: (...args: A[]) => Result,
): (...args: A[]) => Result {
	const hookFn = (...args: A[]) => {
		// call each time so we can track exposures
		const conditionResult = condition();
		const cache: WeakMap<(...args: never[]) => unknown, boolean> = globalThis[CACHE_MAP_KEY];
		if (!cache.has(hookFn)) {
			cache.set(hookFn, conditionResult);
		}

		// Extra level of safety for dev environment to notify devs of changed condition
		if (process.env.NODE_ENV !== 'production') {
			if (cache.get(hookFn) !== conditionResult) {
				throw new Error(
					'Conditional hook called with different condition, this breaks the rules of hooks!',
				);
			}
		}

		if (cache.get(hookFn)) {
			return newHook(...args);
		} else {
			return oldHook(...args);
		}
	};
	return hookFn;
}
