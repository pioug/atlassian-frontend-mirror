<!-- API Report Version: 2.3 -->

## API Report File for "@atlaskit/react-experiment-framework"

> Do not edit this file. This report is auto-generated using
> [API Extractor](https://api-extractor.com/).
> [Learn more about API reports](https://hello.atlassian.net/wiki/spaces/UR/pages/1825484529/Package+API+Reports)

### Table of contents

- [Main Entry Types](#main-entry-types)
- [Peer Dependencies](#peer-dependencies)

### Main Entry Types

<!--SECTION START: Main Entry Types-->

```ts
/// <reference types="react" />

import { Component } from 'react';
import { ComponentType } from 'react';
import { Consumer } from 'react';
import { Provider } from 'react';
import { default as React_2 } from 'react';
import { ReactNode } from 'react';

// @public (undocumented)
export function asExperiment(
	experimentComponentMap: ExperimentComponentMap,
	experimentKey: string,
	callbacks: {
		onError: (error: Error, options?: ExperimentEnrollmentOptions) => void;
		onExposure: (exposureDetails: ExposureDetails, options?: ExperimentEnrollmentOptions) => void;
	},
	LoadingComponent?: ComponentType,
): {
	new (props: Readonly<Record<string, any>> | Record<string, any>): {
		state: {
			forceFallback: boolean;
			options: undefined;
		};
		onReceiveContext: (
			experiments: Experiments,
			options?: ExperimentEnrollmentOptions,
		) => JSX.Element | null;
		componentDidCatch(err: Error): void;
		renderFallback: () => JSX.Element;
		render(): JSX.Element;
		context: any;
		setState<K extends 'forceFallback'>(
			state:
				| ((
						prevState: Readonly<State>,
						props: Readonly<Record<string, any>>,
				  ) => Pick<State, K> | State | null)
				| Pick<State, K>
				| State
				| null,
			callback?: (() => void) | undefined,
		): void;
		forceUpdate(callback?: (() => void) | undefined): void;
		readonly props: Readonly<Record<string, any>> &
			Readonly<{
				children?: React_2.ReactNode;
			}>;
		refs: {
			[key: string]: React_2.ReactInstance;
		};
		componentDidMount?(): void;
		shouldComponentUpdate?(
			nextProps: Readonly<Record<string, any>>,
			nextState: Readonly<State>,
			nextContext: any,
		): boolean;
		componentWillUnmount?(): void;
		getSnapshotBeforeUpdate?(
			prevProps: Readonly<Record<string, any>>,
			prevState: Readonly<State>,
		): any;
		componentDidUpdate?(
			prevProps: Readonly<Record<string, any>>,
			prevState: Readonly<State>,
			snapshot?: any,
		): void;
		componentWillMount?(): void;
		UNSAFE_componentWillMount?(): void;
		componentWillReceiveProps?(nextProps: Readonly<Record<string, any>>, nextContext: any): void;
		UNSAFE_componentWillReceiveProps?(
			nextProps: Readonly<Record<string, any>>,
			nextContext: any,
		): void;
		componentWillUpdate?(
			nextProps: Readonly<Record<string, any>>,
			nextState: Readonly<State>,
			nextContext: any,
		): void;
		UNSAFE_componentWillUpdate?(
			nextProps: Readonly<Record<string, any>>,
			nextState: Readonly<State>,
			nextContext: any,
		): void;
	};
	new (
		props: Record<string, any>,
		context: any,
	): {
		state: {
			forceFallback: boolean;
			options: undefined;
		};
		onReceiveContext: (
			experiments: Experiments,
			options?: ExperimentEnrollmentOptions,
		) => JSX.Element | null;
		componentDidCatch(err: Error): void;
		renderFallback: () => JSX.Element;
		render(): JSX.Element;
		context: any;
		setState<K extends 'forceFallback'>(
			state:
				| ((
						prevState: Readonly<State>,
						props: Readonly<Record<string, any>>,
				  ) => Pick<State, K> | State | null)
				| Pick<State, K>
				| State
				| null,
			callback?: (() => void) | undefined,
		): void;
		forceUpdate(callback?: (() => void) | undefined): void;
		readonly props: Readonly<Record<string, any>> &
			Readonly<{
				children?: React_2.ReactNode;
			}>;
		refs: {
			[key: string]: React_2.ReactInstance;
		};
		componentDidMount?(): void;
		shouldComponentUpdate?(
			nextProps: Readonly<Record<string, any>>,
			nextState: Readonly<State>,
			nextContext: any,
		): boolean;
		componentWillUnmount?(): void;
		getSnapshotBeforeUpdate?(
			prevProps: Readonly<Record<string, any>>,
			prevState: Readonly<State>,
		): any;
		componentDidUpdate?(
			prevProps: Readonly<Record<string, any>>,
			prevState: Readonly<State>,
			snapshot?: any,
		): void;
		componentWillMount?(): void;
		UNSAFE_componentWillMount?(): void;
		componentWillReceiveProps?(nextProps: Readonly<Record<string, any>>, nextContext: any): void;
		UNSAFE_componentWillReceiveProps?(
			nextProps: Readonly<Record<string, any>>,
			nextContext: any,
		): void;
		componentWillUpdate?(
			nextProps: Readonly<Record<string, any>>,
			nextState: Readonly<State>,
			nextContext: any,
		): void;
		UNSAFE_componentWillUpdate?(
			nextProps: Readonly<Record<string, any>>,
			nextState: Readonly<State>,
			nextContext: any,
		): void;
	};
	displayName: string;
	contextType?: React_2.Context<any> | undefined;
};

// @public (undocumented)
export class CohortTracker extends Component<Props> {
	// (undocumented)
	componentDidMount(): void;
	// (undocumented)
	static displayName: string;
	// (undocumented)
	render(): null;
}

// @public (undocumented)
export type EnrollmentDetails = {
	cohort: string;
	isEligible: boolean;
	ineligibilityReasons?: string[];
};

// @public (undocumented)
type EnrollmentOptions = {
	[experimentKey: string]: any;
};

// @public (undocumented)
type ExperimentComponentMap = {
	fallback: ComponentType<any>;
	[key: string]: ComponentType<any>;
};

// @public (undocumented)
export const ExperimentConsumer: Consumer<ExperimentContext>;

// @public (undocumented)
export type ExperimentContext = {
	experiments: Experiments;
	options?: ExperimentEnrollmentOptions;
};

// @public (undocumented)
export class ExperimentController extends Component<Props_2, State_2> {
	constructor(props: Props_2);
	// (undocumented)
	static displayName: string;
	// (undocumented)
	render(): JSX.Element;
	// (undocumented)
	resolveEnrollmentForExperiment(experimentKey: ExperimentKey): Promise<EnrollmentDetails>;
	// (undocumented)
	resolverPromises: ResolverPromises;
}

// @public (undocumented)
export type ExperimentDetails =
	| {
			isEnrollmentDecided: false;
			enrollmentResolver: ExperimentEnrollmentResolver;
	  }
	| {
			isEnrollmentDecided: true;
			enrollmentDetails?: EnrollmentDetails;
	  };

// @public (undocumented)
export type ExperimentEnrollmentConfig = {
	[experimentKey: string]: ExperimentEnrollmentResolver;
};

// @public (undocumented)
export type ExperimentEnrollmentOptions = EnrollmentOptions | OptionsResolver;

// @public (undocumented)
export type ExperimentEnrollmentResolver = (
	options?: ExperimentEnrollmentOptions,
) => EnrollmentDetails | Promise<EnrollmentDetails>;

// @public (undocumented)
export type ExperimentKey = string;

// @public (undocumented)
export const ExperimentProvider: Provider<ExperimentContext>;

// @public (undocumented)
export type Experiments = {
	[experimentKey: string]: ExperimentDetails;
};

// @public (undocumented)
export type ExposureDetails = EnrollmentDetails & {
	experimentKey: ExperimentKey;
};

// @public (undocumented)
type OptionsResolver = (experimentKey: ExperimentKey) => EnrollmentOptions;

// @public (undocumented)
interface Props {
	// (undocumented)
	exposureDetails: ExposureDetails;
	// (undocumented)
	onExposure: (exposureDetails: ExposureDetails, options?: ExperimentEnrollmentOptions) => void;
	// (undocumented)
	options?: ExperimentEnrollmentOptions;
}

// @public (undocumented)
type Props_2 = {
	experimentEnrollmentConfig: ExperimentEnrollmentConfig;
	experimentEnrollmentOptions?: ExperimentEnrollmentOptions;
	children?: ReactNode;
};

// @public (undocumented)
type ResolverPromises = {
	[experimentKey: string]: Promise<EnrollmentDetails>;
};

// @public (undocumented)
type State = {
	forceFallback: boolean;
};

// @public (undocumented)
type State_2 = {
	experiments: Experiments;
};

// (No @packageDocumentation comment for this package)
```

<!--SECTION END: Main Entry Types-->

### Peer Dependencies

<!--SECTION START: Peer Dependencies-->

```json
{
	"react": "^16.8.0",
	"react-dom": "^16.8.0"
}
```

<!--SECTION END: Peer Dependencies-->
