/**
 * This file was automatically generated by @atlaskit/adf-schema-generator
 * DO NOT MODIFY IT BY HAND. Instead, modify the source files in "packages/adf-schema/src/next-schema" ,
 * and run "yarn workspace @atlaskit/adf-schema build:schema:all" to regenerate this file.
 */

import { createPMMarkSpecFactory } from '../../schema/createPMSpecFactory';

import type { Mark } from '@atlaskit/editor-prosemirror/model';

export interface AlignmentMarkAttributes {
  align: 'center' | 'end';
}

export interface AlignmentDefinition {
  type: 'alignment';
  attrs: AlignmentMarkAttributes;
}

export interface AlignmentMark extends Mark {
  attrs: AlignmentMarkAttributes;
}

export const alignment = createPMMarkSpecFactory<AlignmentMark>({
  attrs: { align: {} },
  excludes: 'alignment indentation',
  group: 'alignment',
});

export interface AnnotationMarkAttributes {
  id: string;
  annotationType: 'inlineComment';
}

export interface AnnotationDefinition {
  type: 'annotation';
  attrs: AnnotationMarkAttributes;
}

export interface AnnotationMark extends Mark {
  attrs: AnnotationMarkAttributes;
}

export const annotation = createPMMarkSpecFactory<AnnotationMark>({
  attrs: { id: { default: '' }, annotationType: { default: 'inlineComment' } },
  inclusive: true,
  excludes: '',
  group: 'annotation',
});

export interface BackgroundColorMarkAttributes {
  color: string;
}

export interface BackgroundColorDefinition {
  type: 'backgroundColor';
  attrs: BackgroundColorMarkAttributes;
}

export interface BackgroundColorMark extends Mark {
  attrs: BackgroundColorMarkAttributes;
}

export const backgroundColor = createPMMarkSpecFactory<BackgroundColorMark>({
  attrs: { color: {} },
  inclusive: true,
  excludes: 'color',
  group: 'color',
});

export interface BorderMarkAttributes {
  size: number;
  color: string;
}

export interface BorderDefinition {
  type: 'border';
  attrs: BorderMarkAttributes;
}

export interface BorderMark extends Mark {
  attrs: BorderMarkAttributes;
}

export const border = createPMMarkSpecFactory<BorderMark>({
  attrs: { size: {}, color: {} },
  inclusive: false,
});

export interface BreakoutMarkAttributes {
  mode: 'wide' | 'full-width';
  width?: number;
}

export interface BreakoutDefinition {
  type: 'breakout';
  attrs: BreakoutMarkAttributes;
}

export interface BreakoutMark extends Mark {
  attrs: BreakoutMarkAttributes;
}

export const breakout = createPMMarkSpecFactory<BreakoutMark>({
  attrs: { mode: { default: 'wide' }, width: { default: null } },
  inclusive: false,
  spanning: false,
});

export interface CodeDefinition {
  type: 'code';
}

export type CodeMark = Mark;

export const code = createPMMarkSpecFactory({
  inclusive: true,
  excludes: 'fontStyle link searchQuery color',
});

export interface ConfluenceInlineCommentMarkAttributes {
  reference: string;
}

export interface ConfluenceInlineCommentDefinition {
  type: 'confluenceInlineComment';
  attrs: ConfluenceInlineCommentMarkAttributes;
}

export interface ConfluenceInlineCommentMark extends Mark {
  attrs: ConfluenceInlineCommentMarkAttributes;
}

export const confluenceInlineComment =
  createPMMarkSpecFactory<ConfluenceInlineCommentMark>({
    attrs: { reference: { default: '' } },
    inclusive: false,
    excludes: '',
  });

export interface DataConsumerMarkAttributes {
  sources: Array<string>;
}

export interface DataConsumerDefinition {
  type: 'dataConsumer';
  attrs: DataConsumerMarkAttributes;
}

export interface DataConsumerMark extends Mark {
  attrs: DataConsumerMarkAttributes;
}

export const dataConsumer = createPMMarkSpecFactory<DataConsumerMark>({
  attrs: { sources: { default: [] } },
});

export interface EmDefinition {
  type: 'em';
}

export type EmMark = Mark;

export const em = createPMMarkSpecFactory({
  inclusive: true,
  group: 'fontStyle',
});

export interface FragmentMarkAttributes {
  localId: string;
  name?: string;
}

export interface FragmentDefinition {
  type: 'fragment';
  attrs: FragmentMarkAttributes;
}

export interface FragmentMark extends Mark {
  attrs: FragmentMarkAttributes;
}

export const fragment = createPMMarkSpecFactory<FragmentMark>({
  attrs: { localId: { default: '' }, name: { default: null } },
  inclusive: false,
  excludes: '',
});

export interface IndentationMarkAttributes {
  level: number;
}

export interface IndentationDefinition {
  type: 'indentation';
  attrs: IndentationMarkAttributes;
}

export interface IndentationMark extends Mark {
  attrs: IndentationMarkAttributes;
}

export const indentation = createPMMarkSpecFactory<IndentationMark>({
  attrs: { level: {} },
  excludes: 'indentation alignment',
  group: 'indentation',
});

export interface LinkMarkAttributes {
  href: string;
  title?: string;
  id?: string;
  collection?: string;
  occurrenceKey?: string;
  __confluenceMetadata?: Record<string, unknown>;
}

export interface LinkDefinition {
  type: 'link';
  attrs: LinkMarkAttributes;
}

export interface LinkMark extends Mark {
  attrs: LinkMarkAttributes;
}

export const link = createPMMarkSpecFactory<LinkMark>({
  attrs: { href: {}, __confluenceMetadata: { default: null } },
  inclusive: false,
  excludes: 'link',
  group: 'link',
});

export interface StrikeDefinition {
  type: 'strike';
}

export type StrikeMark = Mark;

export const strike = createPMMarkSpecFactory({
  inclusive: true,
  group: 'fontStyle',
});

export interface StrongDefinition {
  type: 'strong';
}

export type StrongMark = Mark;

export const strong = createPMMarkSpecFactory({
  inclusive: true,
  group: 'fontStyle',
});

export interface SubsupMarkAttributes {
  type: 'sub' | 'sup';
}

export interface SubsupDefinition {
  type: 'subsup';
  attrs: SubsupMarkAttributes;
}

export interface SubsupMark extends Mark {
  attrs: SubsupMarkAttributes;
}

export const subsup = createPMMarkSpecFactory<SubsupMark>({
  attrs: { type: { default: 'sub' } },
  inclusive: true,
  group: 'fontStyle',
});

export interface TextColorMarkAttributes {
  color: string;
}

export interface TextColorDefinition {
  type: 'textColor';
  attrs: TextColorMarkAttributes;
}

export interface TextColorMark extends Mark {
  attrs: TextColorMarkAttributes;
}

export const textColor = createPMMarkSpecFactory<TextColorMark>({
  attrs: { color: {} },
  inclusive: true,
  group: 'color',
});

export interface TypeAheadQueryMarkAttributes {
  trigger: string;
}

export interface TypeAheadQueryDefinition {
  type: 'typeAheadQuery';
  attrs: TypeAheadQueryMarkAttributes;
}

export interface TypeAheadQueryMark extends Mark {
  attrs: TypeAheadQueryMarkAttributes;
}

export const typeAheadQuery = createPMMarkSpecFactory<TypeAheadQueryMark>({
  attrs: { trigger: { default: '' } },
  inclusive: true,
  group: 'searchQuery',
});

export interface UnderlineDefinition {
  type: 'underline';
}

export type UnderlineMark = Mark;

export const underline = createPMMarkSpecFactory({
  inclusive: true,
  group: 'fontStyle',
});

export interface UnsupportedMarkMarkAttributes {
  originalValue: Record<string, unknown>;
}

export interface UnsupportedMarkDefinition {
  type: 'unsupportedMark';
  attrs: UnsupportedMarkMarkAttributes;
}

export interface UnsupportedMarkMark extends Mark {
  attrs: UnsupportedMarkMarkAttributes;
}

export const unsupportedMark = createPMMarkSpecFactory<UnsupportedMarkMark>({
  attrs: { originalValue: {} },
  excludes: '',
});

export interface UnsupportedNodeAttributeMarkAttributes {
  unsupported: Record<string, unknown>;
  type: string;
}

export interface UnsupportedNodeAttributeDefinition {
  type: 'unsupportedNodeAttribute';
  attrs: UnsupportedNodeAttributeMarkAttributes;
}

export interface UnsupportedNodeAttributeMark extends Mark {
  attrs: UnsupportedNodeAttributeMarkAttributes;
}

export const unsupportedNodeAttribute =
  createPMMarkSpecFactory<UnsupportedNodeAttributeMark>({
    attrs: { unsupported: {}, type: {} },
  });
