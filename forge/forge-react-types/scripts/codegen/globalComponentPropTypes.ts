// This file was generated by AI. It is an internal script used only for generating types and is not used in any production code. Use AI to update as needed and check the generated types are correct before committing.

/* eslint-disable @typescript-eslint/ban-types */
import { createSignedArtifact } from '@atlassian/codegen';
import { Project } from 'ts-morph';
import type { Symbol, InterfaceDeclaration, PropertySignature, SourceFile } from 'ts-morph';
import { resolve } from 'path';
import fs from 'fs';

// Path to the global component props source file (re-exports)
const GLOBAL_PROPS_SOURCE_PATH = resolve(
	__dirname,
	'../../../../..',
	'services/forge-common-app-gateway/src/types/global-component-props.ts',
);

// Output directory for generated files
const GLOBAL_OUTPUT_DIR = resolve(
	__dirname,
	'..',
	'..',
	'src',
	'components',
	'global',
	'__generated__',
);

/**
 * Extracts the JSDoc comment from a node and formats it properly.
 * Only extracts JSDoc that is directly attached to the node (not file-level comments).
 */
const getJSDocComment = (node: InterfaceDeclaration | PropertySignature): string | null => {
	const jsDocs = node.getJsDocs();
	if (jsDocs.length === 0) {
		return null;
	}

	// Get only the last JSDoc (the one directly attached to the declaration)
	const lastJsDoc = jsDocs[jsDocs.length - 1];
	const comment = lastJsDoc.getInnerText();

	if (!comment || comment.length === 0) {
		return null;
	}

	const commentBody = comment
		.split('\n')
		.map((line: string) => line.trimEnd())
		.map((line: string) => (line.length === 0 ? ' *' : ` * ${line}`))
		.join('\n');

	return `/**\n${commentBody}\n */`;
};

/**
 * Resolves a TypeScript type to its primitive representation.
 * For now, we only support simple primitive types.
 */
const resolveToPrimitive = (typeText: string): string => {
	// Already primitive types
	const primitives = [
		'string',
		'number',
		'boolean',
		'null',
		'undefined',
		'void',
		'never',
		'unknown',
		'any',
	];
	if (primitives.includes(typeText)) {
		return typeText;
	}

	// Handle optional types (e.g., "string | undefined")
	if (typeText.includes('|')) {
		const parts = typeText.split('|').map((p) => p.trim());
		const resolvedParts = parts.map((part) => resolveToPrimitive(part));
		return resolvedParts.join(' | ');
	}

	// For any other type, return as-is (it should already be primitive based on our props)
	return typeText;
};

/**
 * Resolves a symbol to its original interface declaration.
 * Handles re-exported types by following the export declarations.
 */
const resolveToInterfaceDeclaration = (
	symbol: Symbol,
	sourceFile: SourceFile,
	project: Project,
): { interfaceDecl: InterfaceDeclaration; sourceFilePath: string } | null => {
	const symbolName = symbol.getName();

	// Find the export declaration for this symbol
	const exportDeclarations = sourceFile.getExportDeclarations();

	for (const exportDecl of exportDeclarations) {
		const namedExports = exportDecl.getNamedExports();
		const matchingExport = namedExports.find(
			(ne) => ne.getName() === symbolName || ne.getAliasNode()?.getText() === symbolName,
		);

		if (matchingExport) {
			// Get the module specifier (the path being exported from)
			const moduleSpecifier = exportDecl.getModuleSpecifierValue();
			if (!moduleSpecifier) {
				continue;
			}

			// Resolve the module path
			const moduleSourceFile = exportDecl.getModuleSpecifierSourceFile();
			if (!moduleSourceFile) {
				// Try to manually resolve and add the source file
				const resolvedPath = resolve(sourceFile.getDirectoryPath(), moduleSpecifier + '.tsx');

				if (fs.existsSync(resolvedPath)) {
					const addedSourceFile = project.addSourceFileAtPath(resolvedPath);
					const interfaceDecl = addedSourceFile.getInterface(symbolName);
					if (interfaceDecl) {
						return {
							interfaceDecl,
							sourceFilePath: resolvedPath,
						};
					}
				}
				continue;
			}

			// Find the interface in the module source file
			const interfaceDecl = moduleSourceFile.getInterface(symbolName);
			if (interfaceDecl) {
				return {
					interfaceDecl,
					sourceFilePath: moduleSourceFile.getFilePath(),
				};
			}
		}
	}

	return null;
};

/**
 * Generates the source code for a single component's prop types.
 */
const generateComponentPropTypeCode = (interfaceDecl: InterfaceDeclaration): string => {
	const interfaceName = interfaceDecl.getName();
	const componentName = interfaceName.replace('Props', '');

	const lines: string[] = [];

	// Add eslint directive
	lines.push('/* eslint @repo/internal/codegen/signed-source-integrity: "warn" */');
	lines.push('');

	// Get interface JSDoc
	const interfaceJSDoc = getJSDocComment(interfaceDecl);
	if (interfaceJSDoc) {
		lines.push(interfaceJSDoc);
	}

	// Generate the props type
	const properties = interfaceDecl.getProperties();

	if (properties.length === 0) {
		// Empty props interface
		lines.push(`export type ${interfaceName} = Record<string, never>;`);
	} else {
		lines.push(`export type ${interfaceName} = {`);

		properties.forEach((prop: PropertySignature) => {
			const propName = prop.getName();
			const propType = prop.getType().getText();
			const isOptional = prop.hasQuestionToken();
			const resolvedType = resolveToPrimitive(propType);

			// Get property JSDoc
			const propJSDoc = getJSDocComment(prop);
			if (propJSDoc) {
				// Indent the JSDoc for property
				const indentedJSDoc = propJSDoc
					.split('\n')
					.map((line: string) => `\t${line}`)
					.join('\n');
				lines.push(indentedJSDoc);
			}

			const optionalMarker = isOptional ? '?' : '';
			lines.push(`\t${propName}${optionalMarker}: ${resolvedType};`);
		});

		lines.push('};');
	}

	lines.push('');

	// Generate the T* component type
	if (interfaceJSDoc) {
		lines.push(interfaceJSDoc);
	}
	lines.push(`export type T${componentName}<T> = (props: ${interfaceName}) => T;`);

	return lines.join('\n');
};

/**
 * Generates prop type files for all Global components.
 *
 * Process:
 * 1. Load the re-export file (global-component-props.ts)
 * 2. Get exported symbols ending with "Props"
 * 3. Resolve each to its original interface declaration
 * 4. Extract type info and resolve to primitives
 * 5. Generate signed .codegen.tsx files and index.ts
 */
const generateGlobalComponentPropTypes = () => {
	// eslint-disable-next-line no-console
	console.log('Generating Global component prop types...');

	// Ensure output directory exists
	if (!fs.existsSync(GLOBAL_OUTPUT_DIR)) {
		fs.mkdirSync(GLOBAL_OUTPUT_DIR, { recursive: true });
	}

	const project = new Project({
		compilerOptions: {
			strict: true,
		},
	});

	const sourceFile = project.addSourceFileAtPath(GLOBAL_PROPS_SOURCE_PATH);
	const exportedSymbols = sourceFile.getExportSymbols();
	const propsSymbols = exportedSymbols.filter((symbol) => symbol.getName().endsWith('Props'));

	const generatedFiles: string[] = [];

	propsSymbols.forEach((symbol) => {
		const symbolName = symbol.getName();
		const componentName = symbolName.replace('Props', '');

		const resolved = resolveToInterfaceDeclaration(symbol, sourceFile, project);

		if (!resolved) {
			// eslint-disable-next-line no-console
			console.error(`  ✗ Could not resolve ${symbolName} to an interface declaration`);
			return;
		}

		const { interfaceDecl, sourceFilePath } = resolved;
		const sourceCode = generateComponentPropTypeCode(interfaceDecl);
		const outputPath = resolve(GLOBAL_OUTPUT_DIR, `${symbolName}.codegen.tsx`);

		const signedSourceCode = createSignedArtifact(
			sourceCode,
			'yarn workspace @atlaskit/forge-react-types codegen-global',
			{
				description: `Generated prop types for Global component - ${componentName}`,
				dependencies: [GLOBAL_PROPS_SOURCE_PATH, sourceFilePath],
				outputFolder: GLOBAL_OUTPUT_DIR,
			},
		);

		fs.writeFileSync(outputPath, signedSourceCode);
		generatedFiles.push(symbolName);

		// eslint-disable-next-line no-console
		console.log(`  ✓ Generated ${symbolName}.codegen.tsx`);
	});

	generateIndexFile(generatedFiles);

	// eslint-disable-next-line no-console
	console.log('✓ Global component prop types generation complete!');
};

/**
 * Generates the index.ts file that exports all generated types.
 */
const generateIndexFile = (interfaceNames: string[]) => {
	const lines: string[] = [];

	lines.push('/* eslint @repo/internal/codegen/signed-source-integrity: "warn" */');
	lines.push('');

	interfaceNames.forEach((interfaceName) => {
		const componentName = interfaceName.replace('Props', '');
		lines.push(
			`export type { ${interfaceName}, T${componentName} } from './${interfaceName}.codegen';`,
		);
	});

	const sourceCode = lines.join('\n') + '\n';

	const indexPath = resolve(GLOBAL_OUTPUT_DIR, 'index.ts');

	const signedSourceCode = createSignedArtifact(
		sourceCode,
		'yarn workspace @atlaskit/forge-react-types codegen-global',
		{
			description: 'Index file for generated Global component prop types',
			dependencies: [GLOBAL_PROPS_SOURCE_PATH],
			outputFolder: GLOBAL_OUTPUT_DIR,
		},
	);

	fs.writeFileSync(indexPath, signedSourceCode);
};

export { generateGlobalComponentPropTypes };
