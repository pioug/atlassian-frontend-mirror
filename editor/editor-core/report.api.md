<!-- API Report Version: 2.3 -->

## API Report File for "@atlaskit/editor-core"

> Do not edit this file. This report is auto-generated using [API Extractor](https://api-extractor.com/).
> [Learn more about API reports](https://hello.atlassian.net/wiki/spaces/UR/pages/1825484529/Package+API+Reports)

### Table of contents

- [Main Entry Types](#main-entry-types)
- [Peer Dependencies](#peer-dependencies)

### Main Entry Types

<!--SECTION START: Main Entry Types-->

```ts
/// <reference types="node" />
/// <reference types="react" />

import { AbstractMentionResource } from '@atlaskit/mention/resource';
import { ACTION } from '@atlaskit/editor-common/analytics';
import { ACTION_SUBJECT } from '@atlaskit/editor-common/analytics';
import { ACTION_SUBJECT_ID } from '@atlaskit/editor-common/analytics';
import { ActivityProvider } from '@atlaskit/activity-provider';
import { AnalyticsEventPayload } from '@atlaskit/editor-common/analytics';
import { AnalyticsEventPayload as AnalyticsEventPayload_2 } from '@atlaskit/analytics-next/AnalyticsEvent';
import { AnnotationTypes } from '@atlaskit/adf-schema';
import { CardOptions } from '@atlaskit/editor-common/card';
import { CardProvider } from '@atlaskit/editor-common/provider-factory';
import { CollabEditProvider } from '@atlaskit/editor-common/collab';
import { Color } from '@atlaskit/status/element';
import { Command as Command_2 } from '@atlaskit/editor-common/types';
import type { ContextIdentifierProvider } from '@atlaskit/editor-common/provider-factory';
import { ContextUpdateHandler } from '@atlaskit/editor-common/types';
import { createTable } from '@atlaskit/editor-plugin-table/commands';
import { CreateUIAnalyticsEvent } from '@atlaskit/analytics-next';
import { CreateUIAnalyticsEvent as CreateUIAnalyticsEvent_2 } from '@atlaskit/analytics-next/types';
import { darkModeStatusColorPalette } from '@atlaskit/editor-common/ui-color';
import { DecorationSet } from 'prosemirror-view';
import { DEFAULT_BORDER_COLOR } from '@atlaskit/editor-common/ui-color';
import { DirectEditorProps } from 'prosemirror-view';
import { Dispatch } from '@atlaskit/editor-common/event-dispatcher';
import { DispatchAnalyticsEvent } from '@atlaskit/editor-common/analytics';
import { DropdownOptionT } from '@atlaskit/editor-common/types';
import { EditorActionsOptions } from '@atlaskit/editor-common/types';
import { EditorAppearance } from '@atlaskit/editor-common/types';
import { FeatureFlags as EditorFeatureFlags } from '@atlaskit/editor-common/types';
import { EditorPlugin } from '@atlaskit/editor-common/types';
import { EditorReactContext } from '@atlaskit/editor-common/types';
import { EditorSelectionAPI } from '@atlaskit/editor-common/selection';
import { EditorState } from 'prosemirror-state';
import { EditorView } from 'prosemirror-view';
import { EmojiResource } from '@atlaskit/emoji/resource';
import { EmptyStateHandler } from '@atlaskit/editor-common/types';
import { ErrorReporter } from '@atlaskit/editor-common/utils';
import type { ErrorReportingHandler } from '@atlaskit/editor-common/utils';
import { EVENT_TYPE } from '@atlaskit/editor-common/analytics';
import { EventDispatcher } from '@atlaskit/editor-common/event-dispatcher';
import { EventEmitter as EventEmitter_2 } from 'events';
import { ExperienceStore } from '@atlaskit/editor-common/ufo';
import type { ExtensionHandlers } from '@atlaskit/editor-common/extensions';
import type { ExtensionProvider } from '@atlaskit/editor-common/extensions';
import { ExtensionType } from '@atlaskit/editor-common/provider-factory';
import { FloatingToolbarButton } from '@atlaskit/editor-common/types';
import { FloatingToolbarColorPicker } from '@atlaskit/editor-common/types';
import { FloatingToolbarConfig } from '@atlaskit/editor-common/types';
import { FloatingToolbarDatePicker } from '@atlaskit/editor-common/types';
import { FloatingToolbarDropdown } from '@atlaskit/editor-common/types';
import { FloatingToolbarEmojiPicker } from '@atlaskit/editor-common/types';
import { FloatingToolbarInput } from '@atlaskit/editor-common/types';
import { FloatingToolbarItem } from '@atlaskit/editor-common/types';
import { FloatingToolbarListPicker } from '@atlaskit/editor-common/types';
import { FloatingToolbarSelect } from '@atlaskit/editor-common/types';
import { FULL_WIDTH_MODE } from '@atlaskit/editor-common/analytics';
import { GapCursorSelection } from '@atlaskit/editor-common/selection';
import { Side as GapCursorSide } from '@atlaskit/editor-common/selection';
import { INPUT_METHOD } from '@atlaskit/editor-common/analytics';
import { InputMethodInsertMedia } from '@atlaskit/editor-common/analytics';
import { IntlShape } from 'react-intl-next';
import { JSONDocNode } from '@atlaskit/editor-json-transformer/types';
import { jsx } from '@emotion/react';
import { lightModeStatusColorPalette } from '@atlaskit/editor-common/ui-color';
import { LinkPickerProps } from '@atlaskit/link-picker';
import { MacroAttributes } from '@atlaskit/editor-common/provider-factory';
import { MacroProvider } from '@atlaskit/editor-common/provider-factory';
import { MarkConfig } from '@atlaskit/editor-common/types';
import { MediaClientConfig } from '@atlaskit/media-core';
import { MediaFeatureFlags } from '@atlaskit/media-common';
import { MediaFeatureFlags as MediaFeatureFlags_2 } from '@atlaskit/media-common/mediaFeatureFlags';
import { MediaFile } from '@atlaskit/media-picker/types';
import { MediaProvider as MediaProvider_2 } from '@atlaskit/editor-common/provider-factory';
import { MemoizedFn } from 'memoize-one';
import { MentionDescription } from '@atlaskit/mention';
import { MentionProvider } from '@atlaskit/mention/resource';
import { MentionProvider as MentionProvider_2 } from '@atlaskit/mention';
import { MentionResource } from '@atlaskit/mention/resource';
import { MenuItem } from '@atlaskit/editor-common/ui-menu';
import { default as messages } from '@atlaskit/editor-common/messages';
import { NextEditorPlugin } from '@atlaskit/editor-common/types';
import { Node as Node_2 } from 'prosemirror-model';
import { NodeConfig } from '@atlaskit/editor-common/types';
import { NodeType } from 'prosemirror-model';
import { NodeView } from 'prosemirror-view';
import { PaletteColor } from '@atlaskit/editor-common/ui-color';
import { PluginConfig } from '@atlaskit/editor-plugin-table/types';
import { PluginKey } from 'prosemirror-state';
import { PMPlugin } from '@atlaskit/editor-common/types';
import { PositionType } from '@atlaskit/tooltip/types';
import { PresenceProvider } from '@atlaskit/mention/resource';
import { PresenceResource } from '@atlaskit/mention/resource';
import PropTypes from 'prop-types';
import { ProviderFactory } from '@atlaskit/editor-common/provider-factory';
import { Providers } from '@atlaskit/editor-common/provider-factory';
import { PureComponent } from 'react';
import { QuickInsertActionInsert } from '@atlaskit/editor-common/provider-factory';
import { QuickInsertItem } from '@atlaskit/editor-common/provider-factory';
import { QuickInsertItemId } from '@atlaskit/editor-common/provider-factory';
import { QuickInsertProvider } from '@atlaskit/editor-common/provider-factory';
import { default as React_2 } from 'react';
import { ReactElement } from 'react';
import { RefObject } from 'react';
import { ResolvedEditorState } from '@atlaskit/editor-common/collab';
import { RichMediaLayout } from '@atlaskit/adf-schema';
import { Schema } from 'prosemirror-model';
import type { SearchProvider } from '@atlaskit/editor-common/provider-factory';
import { SelectItemMode } from '@atlaskit/editor-common/type-ahead';
import type { SelectOption } from '@atlaskit/editor-common/types';
import { setTextSelection } from '@atlaskit/editor-common/utils';
import { SEVERITY } from '@atlaskit/editor-common/utils';
import { TaskDecisionProvider } from '@atlaskit/task-decision';
import { TeamMentionProvider } from '@atlaskit/mention/resource';
import { TeamMentionResource } from '@atlaskit/mention/team-resource';
import type { ThemeModes } from '@atlaskit/theme/types';
import { ToolbarUIComponentFactory } from '@atlaskit/editor-common/types';
import { Transaction } from 'prosemirror-state';
import { Transformer as Transformer_2 } from '@atlaskit/editor-common/types';
import type { TypeAheadHandler } from '@atlaskit/editor-common/types';
import type { TypeAheadItem } from '@atlaskit/editor-common/types';
import type { TypeAheadItem as TypeAheadItem_2 } from '@atlaskit/editor-common/provider-factory';
import type { TypeAheadStats } from '@atlaskit/editor-common/types';
import { UIComponentFactory } from '@atlaskit/editor-common/types';
import { UploadEndEventPayload } from '@atlaskit/media-picker/types';
import { UploadErrorEventPayload } from '@atlaskit/media-picker/types';
import { UploadParams } from '@atlaskit/media-picker/types';
import { UploadPreviewUpdateEventPayload } from '@atlaskit/media-picker/types';
import { WithIntlProps } from 'react-intl-next';
import { WithPluginState } from '@atlaskit/editor-common/with-plugin-state';
import { WrappedComponentProps } from 'react-intl-next';

export { AbstractMentionResource };

export { ACTION };

export { ACTION_SUBJECT };

export { ACTION_SUBJECT_ID };

// @public (undocumented)
type AddItemTransactionCreator = (opts: {
  state: EditorState;
  tr: Transaction;
  list: NodeType;
  item: NodeType;
  listLocalId: string;
  itemLocalId: string;
}) => Transaction | null;

// @public (undocumented)
type AllowedBlockTypes = 'blockquote' | 'codeBlock' | 'hardBreak' | 'heading';

// @public (undocumented)
interface AllSelectionData {
  // (undocumented)
  type: 'all';
}

export { AnalyticsEventPayload };

// @public (undocumented)
type AnnotationComponentProps = {
  textSelection?: string;
  dom?: HTMLElement;
  onClose?: () => void;
};

// @public (undocumented)
export type AnnotationInfo = {
  id: string;
  type: AnnotationTypes.INLINE_COMMENT;
};

// @public (undocumented)
export interface AnnotationProviders {
  // (undocumented)
  inlineComment: InlineCommentAnnotationProvider;
}

// @public (undocumented)
export interface AnnotationState<Type, State> {
  // (undocumented)
  annotationType: Type;
  // (undocumented)
  id: string;
  // (undocumented)
  state: State;
}

// @public (undocumented)
export interface AnnotationTypeProvider<Type, State> {
  // (undocumented)
  disallowOnWhitespace?: boolean;
  // (undocumented)
  getState: (
    annotationIds: string[],
  ) => Promise<AnnotationState<Type, State>[]>;
  // (undocumented)
  updateSubscriber?: AnnotationUpdateEmitter;
}

// @public (undocumented)
export class AnnotationUpdateEmitter extends EventEmitter_2 {
  // (undocumented)
  on(event: VisibilityEvent, listener: (isVisible: boolean) => void): this;
  // (undocumented)
  on(event: UpdateEvent, listener: (annotationId: string) => void): this;
}

// @public (undocumented)
interface BasePluginOptions {
  // (undocumented)
  allowInlineCursorTarget?: boolean;
  // (undocumented)
  allowScrollGutter?: ScrollGutterPluginOptions;
  // (undocumented)
  browserFreezeTracking?: BrowserFreezetracking;
  // (undocumented)
  inputTracking?: InputTracking;
  // (undocumented)
  ufo?: boolean;
}

// @public (undocumented)
type BasePortalProviderProps = {
  render: (
    portalProviderAPI: PortalProviderAPI,
  ) => JSX.Element | React_2.ReactChild | null;
  onAnalyticsEvent?: FireAnalyticsCallback;
  useAnalyticsContext?: boolean;
  themeMode?: ThemeModes;
} & WrappedComponentProps;

// @public (undocumented)
export class BaseReactEditorView<T = {}> extends React_2.Component<
  EditorViewProps & WrappedComponentProps & T,
  {},
  EditorReactContext
> {
  constructor(
    props: EditorViewProps & WrappedComponentProps & T,
    context: EditorReactContext,
  );
  // (undocumented)
  blur: () => void;
  // (undocumented)
  componentDidMount(): void;
  componentWillUnmount(): void;
  // (undocumented)
  config: EditorConfig;
  // (undocumented)
  contentTransformer?: Transformer_2<string>;
  // (undocumented)
  static contextTypes: {
    getAtlaskitAnalyticsEventHandlers: PropTypes.Requireable<
      (...args: any[]) => any
    >;
  };
  // (undocumented)
  createEditorState: (options: CreateEditorStateOptions) => EditorState<any>;
  // (undocumented)
  dispatch: Dispatch;
  // (undocumented)
  dispatchAnalyticsEvent: (payload: AnalyticsEventPayload) => void;
  // (undocumented)
  editorRef: React_2.RefObject<HTMLDivElement>;
  // (undocumented)
  editorState: EditorState;
  // (undocumented)
  errorReporter: ErrorReporter;
  // (undocumented)
  eventDispatcher: EventDispatcher;
  // (undocumented)
  experienceStore?: ExperienceStore;
  // (undocumented)
  formatFullWidthAppearance: (
    appearance: EditorAppearance | undefined,
  ) => FULL_WIDTH_MODE;
  // (undocumented)
  getDirectEditorProps: (
    state?: EditorState<any> | undefined,
  ) => DirectEditorProps;
  // (undocumented)
  getPlugins(
    editorProps: EditorProps,
    prevEditorProps?: EditorProps,
    createAnalyticsEvent?: CreateUIAnalyticsEvent,
  ): EditorPlugin[];
  // (undocumented)
  handleAnalyticsEvent: FireAnalyticsCallback;
  // (undocumented)
  handleEditorViewRef: (node: HTMLDivElement) => void;
  // (undocumented)
  proseMirrorRenderedSeverity?: SEVERITY;
  // (undocumented)
  reconfigureState: (props: EditorViewProps) => void;
  // (undocumented)
  render(): JSX.Element;
  // (undocumented)
  resetEditorState: ({
    doc,
    shouldScrollToBottom,
  }: {
    doc: string;
    shouldScrollToBottom: boolean;
  }) => void;
  // (undocumented)
  transactionTracker: TransactionTracker;
  // (undocumented)
  get transactionTracking(): TransactionTracking;
  // (undocumented)
  UNSAFE_componentWillReceiveProps(nextProps: EditorViewProps): void;
  // (undocumented)
  validTransactionCount: number;
  // (undocumented)
  view?: EditorView;
}

// @public (undocumented)
type BeforeAndAfterToolbarComponents = {
  before: ReactComponents;
  after: ReactComponents;
};

// @public (undocumented)
export const blockPluginStateKey: PluginKey<BlockTypeState, any>;

// @public (undocumented)
interface BlockType {
  // (undocumented)
  level?: HeadingLevelsAndNormalText;
  // (undocumented)
  name: string;
  // (undocumented)
  nodeName: string;
  // (undocumented)
  tagName?: string;
  // (undocumented)
  title: MessageDescriptor;
}

// @public (undocumented)
export type BlockTypeInputMethod =
  | INPUT_METHOD.FORMATTING
  | INPUT_METHOD.INSERT_MENU
  | INPUT_METHOD.KEYBOARD
  | INPUT_METHOD.SHORTCUT
  | INPUT_METHOD.TOOLBAR;

// @public (undocumented)
interface BlockTypePluginOptions {
  // (undocumented)
  allowBlockType?: {
    exclude?: Array<AllowedBlockTypes>;
  };
  // (undocumented)
  isUndoRedoButtonsEnabled?: boolean;
  // (undocumented)
  lastNodeMustBeParagraph?: boolean;
}

// @public (undocumented)
export type BlockTypeState = {
  currentBlockType: BlockType;
  blockTypesDisabled: boolean;
  availableBlockTypes: BlockType[];
  availableWrapperBlockTypes: BlockType[];
};

// @public (undocumented)
type BrowserFreezetracking = {
  enabled?: boolean;
  trackInteractionType?: boolean;
  trackSeverity?: boolean;
  severityNormalThreshold?: number;
  severityDegradedThreshold?: number;
};

export { CardProvider };

// @public (undocumented)
type CatchAllTracking = {
  enabled: boolean;
};

// @public (undocumented)
interface CellSelectionData {
  // (undocumented)
  anchor: number;
  // (undocumented)
  head: number;
  // (undocumented)
  type: 'cell';
}

// @public (undocumented)
export const changeColor: (color: string) => Command;

// @public (undocumented)
export const clearEditorContent: Command;

// @public (undocumented)
type CloseOptions = {
  insertCurrentQueryAsRawText: boolean;
  attachCommand?: Command;
};

// @public (undocumented)
interface CodeBlockOptions extends LongPressSelectionPluginOptions {
  // (undocumented)
  allowCompositionInputOverride?: boolean;
  // (undocumented)
  allowCopyToClipboard?: boolean;
  // (undocumented)
  appearance?: EditorAppearance | undefined;
}

// @public (undocumented)
interface CollabAnalyticsProps {
  EXPERIMENTAL_allowInternalErrorAnalytics?: boolean;
}

// @public (undocumented)
type CollabEditOptions = {
  provider?: Providers['collabEditProvider'];
  userId?: string;
  useNativePlugin?: boolean;
} & CollabInviteToEditProps &
  CollabAnalyticsProps;

export { CollabEditProvider };

// @public (undocumented)
interface CollabInviteToEditProps {
  // (undocumented)
  inviteToEditComponent?: React.ComponentType<InviteToEditComponentProps>;
  // (undocumented)
  inviteToEditHandler?: (event: React.MouseEvent<HTMLElement>) => void;
  // (undocumented)
  isInviteToEditButtonSelected?: boolean;
}

// @public (undocumented)
export class CollapsedEditor extends React_2.Component<Props, State_2> {
  // (undocumented)
  componentDidUpdate(): void;
  // (undocumented)
  editorComponent?: Editor;
  // (undocumented)
  handleEditorRef: (
    editorRef?: Editor | undefined,
    editorRefCallback?: any,
  ) => void;
  // (undocumented)
  render(): JSX.Element;
  // (undocumented)
  shouldTriggerExpandEvent?: boolean;
  // (undocumented)
  UNSAFE_componentWillReceiveProps(nextProps: Props): void;
}

// @public (undocumented)
export type Command = (
  state: EditorState,
  dispatch?: CommandDispatch,
  view?: EditorView,
) => boolean;

// @public (undocumented)
export type CommandDispatch = (tr: Transaction) => void;

// @public (undocumented)
export const commitStatusPicker: () => (editorView: EditorView) => void;

// @public (undocumented)
type ConfigWithNodeInfo = {
  config: FloatingToolbarConfig | undefined;
  pos: number;
  node: Node_2;
};

// @public (undocumented)
type ContentRetrievalTracking = {
  enabled: boolean;
  successSamplingRate?: number;
  failureSamplingRate?: number;
  reportErrorStack?: boolean;
};

// @public (undocumented)
type Context = {
  editorActions?: EditorActions;
  intl: IntlShape;
};

// @public (undocumented)
export class ContextPanel extends React_2.Component<Props_4> {
  // (undocumented)
  render(): jsx.JSX.Element;
}

// @public (undocumented)
interface CreateEditorStateOptions {
  // (undocumented)
  context: EditorReactContext;
  // (undocumented)
  doc?: Object | Node_2 | string;
  // (undocumented)
  props: EditorViewProps;
  // (undocumented)
  resetting?: boolean;
  // (undocumented)
  selectionAtStart?: boolean;
}

// @public (undocumented)
export const createQuickInsertTools: (editorView: EditorView) => {
  getItems: (
    query: string,
    options?: QuickInsertPluginOptions | undefined,
  ) => QuickInsertItem[];
};

export { createTable };

// @public (undocumented)
export const createTypeAheadTools: (editorView: EditorView) => {
  isOpen: () => TypeAheadHandler | false;
  currentQuery: () => string;
  close: (options?: CloseOptions) => boolean;
  openMention: (inputMethod: TypeAheadInputMethod) => boolean;
  searchMention: (query?: string) => {
    type: (appendValue: string) => Promise<TypeAheadItem_2[]> | undefined;
    result: () => Promise<TypeAheadItem_2[] | undefined>;
    close: (options?: CloseOptions) => boolean;
    insert: ({
      index,
      mode,
    }: {
      index: number;
      mode?: SelectItemMode | undefined;
    }) => Promise<void>;
  };
  openQuickInsert: (inputMethod: TypeAheadInputMethod) => boolean;
  searchQuickInsert: (query?: string) => {
    type: (appendValue: string) => Promise<TypeAheadItem_2[]> | undefined;
    result: () => Promise<TypeAheadItem_2[] | undefined>;
    close: (options?: CloseOptions) => boolean;
    insert: ({
      index,
      mode,
    }: {
      index: number;
      mode?: SelectItemMode | undefined;
    }) => Promise<void>;
  };
  openEmoji: (inputMethod: TypeAheadInputMethod) => boolean;
  searchEmoji: (query?: string) => {
    type: (appendValue: string) => Promise<TypeAheadItem_2[]> | undefined;
    result: () => Promise<TypeAheadItem_2[] | undefined>;
    close: (options?: CloseOptions) => boolean;
    insert: ({
      index,
      mode,
    }: {
      index: number;
      mode?: SelectItemMode | undefined;
    }) => Promise<void>;
  };
  insertItemMention: ({
    contentItem,
    query,
    sourceListItem,
  }: InsertItemProps) => boolean;
  insertItemEmoji: ({
    contentItem,
    query,
    sourceListItem,
  }: InsertItemProps) => boolean;
  insertItemQuickInsert: ({
    contentItem,
    query,
    sourceListItem,
  }: InsertItemProps) => boolean;
};

// @public (undocumented)
export interface CustomMediaPicker {
  // (undocumented)
  destroy(): void;
  // (undocumented)
  emit(event: string, data: any): void;
  // (undocumented)
  on(event: string, cb: Listener): void;
  // (undocumented)
  removeAllListeners(event: any): void;
  // (undocumented)
  setUploadParams(uploadParams: UploadParams): void;
}

export { darkModeStatusColorPalette };

// @public (undocumented)
export const dateMessages: {
  editText: {
    id: string;
    defaultMessage: string;
    description: string;
  };
};

// @public (undocumented)
export const datePluginKey: PluginKey<DatePluginState, any>;

// @public (undocumented)
export type DatePluginState = {
  isQuickInsertAction?: boolean;
  isNew: boolean;
  showDatePickerAt: null | number;
  isDateEmpty: boolean;
  focusDateInput: boolean;
};

// @public
export function dateToDateType(date: Date): DateType;

// @public (undocumented)
type DateType = {
  year: number;
  month: number;
  day?: number;
};

// @public (undocumented)
export function dedupe<T>(list?: T[], iteratee?: (p: T) => T | T[keyof T]): T[];

export { DEFAULT_BORDER_COLOR };

// @public (undocumented)
type DefaultPresetPluginOptions = {
  paste: PastePluginOptions;
  base?: BasePluginOptions;
  blockType?: BlockTypePluginOptions;
  placeholder?: PlaceholderPluginOptions;
  textFormatting?: TextFormattingOptions;
  submitEditor?: EditorProps_2['onSave'];
  annotationProviders?: AnnotationProviders;
  quickInsert?: QuickInsertPluginOptions;
  codeBlock?: CodeBlockOptions;
  selection?: SelectionPluginOptions;
  cardOptions?: CardOptions;
  hyperlinkOptions?: HyperlinkPluginOptions;
  createAnalyticsEvent?: CreateUIAnalyticsEvent;
  typeAhead?: TypeAheadPluginOptions;
};

// @public
export const deleteDate: () => Command;

export { DropdownOptionT };

// @public (undocumented)
type EditInsertedState = {
  type: HyperlinkInsertStatus.EDIT_INSERTED_TOOLBAR;
  node: Node_2;
  pos: number;
};

// @public (undocumented)
export class Editor extends React_2.Component<EditorProps, State> {
  constructor(props: EditorProps, context: Context);
  // (undocumented)
  componentDidMount(): void;
  // (undocumented)
  componentDidUpdate(prevProps: EditorProps): void;
  // (undocumented)
  componentWillUnmount(): void;
  // (undocumented)
  static contextTypes: {
    editorActions: PropTypes.Requireable<object>;
  };
  // (undocumented)
  static defaultProps: EditorProps;
  // (undocumented)
  handleAnalyticsEvent: FireAnalyticsCallback;
  // (undocumented)
  handleSave: (view: EditorView) => void;
  // (undocumented)
  onEditorCreated(instance: {
    view: EditorView;
    eventDispatcher: EventDispatcher;
    transformer?: Transformer_2<string>;
  }): void;
  // (undocumented)
  onEditorDestroyed(_instance: {
    view: EditorView;
    transformer?: Transformer_2<string>;
  }): void;
  // (undocumented)
  prepareExtensionProvider: MemoizedFn<
    (
      extensionProviders?: ExtensionProvidersProp | undefined,
    ) => ExtensionProvider<any> | undefined
  >;
  // (undocumented)
  prepareQuickInsertProvider: (
    extensionProvider?: ExtensionProvider<any> | undefined,
    quickInsert?: QuickInsertOptions | undefined,
  ) => Promise<QuickInsertProvider> | undefined;
  // (undocumented)
  static propTypes: {
    minHeight: ({ appearance, minHeight }: EditorProps) => Error | null;
  };
  // (undocumented)
  render(): jsx.JSX.Element;
  // (undocumented)
  trackEditorActions(
    editorActions: EditorActions & {
      _contentRetrievalTracking?: {
        getValueTracked: boolean;
        samplingCounters: {
          success: number;
          failure: number;
        };
      };
    },
    props: EditorProps,
  ): EditorActions<any> & {
    _contentRetrievalTracking?:
      | undefined
      | {
          getValueTracked: boolean;
          samplingCounters: {
            success: number;
            failure: number;
          };
        };
  };
}

// @public (undocumented)
export class EditorActions<T = any> implements EditorActionsOptions<T> {
  // (undocumented)
  __temporaryFixForConfigPanel(): Promise<void>;
  // (undocumented)
  appendText(text: string): boolean;
  // (undocumented)
  blur(): boolean;
  // (undocumented)
  clear(): boolean;
  // (undocumented)
  dispatchAnalyticsEvent: (payload: AnalyticsEventPayload_2) => void;
  // (undocumented)
  focus(): boolean;
  // (undocumented)
  static from<T>(
    view: EditorView,
    eventDispatcher: EventDispatcher,
    transformer?: Transformer_2<T>,
  ): EditorActions<T>;
  // (undocumented)
  getNodeByFragmentLocalId(id: string): Node_2 | undefined;
  // (undocumented)
  getNodeByLocalId(id: string): Node_2 | undefined;
  getResolvedEditorState: () => Promise<ResolvedEditorState | undefined>;
  getSelectedNode(): Node_2 | undefined;
  // (undocumented)
  getValue(): Promise<T | JSONDocNode | undefined>;
  // (undocumented)
  isDocumentEmpty(): boolean;
  // (undocumented)
  _privateGetEditorView(): EditorView | undefined;
  // (undocumented)
  _privateGetEventDispatcher(): EventDispatcher | undefined;
  // (undocumented)
  _privateRegisterEditor(
    editorView: EditorView,
    eventDispatcher: EventDispatcher,
    contentTransformer?: Transformer_2<T>,
  ): void;
  // (undocumented)
  _privateSubscribe(cb: ContextUpdateHandler): void;
  // (undocumented)
  _privateUnregisterEditor(): void;
  // (undocumented)
  _privateUnsubscribe(cb: ContextUpdateHandler): void;
  // (undocumented)
  replaceDocument(
    rawValue: any,
    shouldScrollToBottom?: boolean,
    shouldAddToHistory?: boolean,
  ): boolean;
  // (undocumented)
  replaceSelection(
    rawValue: Node_2 | Object | string,
    tryToReplace?: boolean,
  ): boolean;
}

// @public (undocumented)
interface EditorConfig {
  // (undocumented)
  contentComponents: UIComponentFactory[];
  // (undocumented)
  marks: MarkConfig[];
  // (undocumented)
  nodes: NodeConfig[];
  // (undocumented)
  onEditorViewStateUpdatedCallbacks: Array<{
    pluginName: string;
    callback: (props: EditorViewStateUpdatedCallbackProps) => void;
  }>;
  // (undocumented)
  pmPlugins: Array<PMPlugin>;
  // (undocumented)
  primaryToolbarComponents: ToolbarUIComponentFactory[];
  // (undocumented)
  secondaryToolbarComponents: UIComponentFactory[];
}

// @public (undocumented)
export class EditorContext extends React_2.Component<EditorContextProps, {}> {
  constructor(props: EditorContextProps);
  // (undocumented)
  static childContextTypes: {
    editorActions: PropTypes.Requireable<object>;
  };
  // (undocumented)
  getChildContext(): {
    editorActions: EditorActions<any>;
  };
  // (undocumented)
  render(): JSX.Element;
}

// @public (undocumented)
type EditorContextProps = {
  editorActions?: EditorActions;
};

export { EditorFeatureFlags };

// @public (undocumented)
export interface EditorInstance {
  // (undocumented)
  contentComponents: UIComponentFactory[];
  // (undocumented)
  contentTransformer?: Transformer<string>;
  // (undocumented)
  editorView: EditorView;
  // (undocumented)
  eventDispatcher: EventDispatcher;
  // (undocumented)
  insertMenuItems?: MenuItem[];
  // (undocumented)
  onEditorViewStateUpdatedCallbacks: {
    pluginName: string;
    callback: OnEditorViewStateUpdated;
  }[];
  // (undocumented)
  primaryToolbarComponents: ToolbarUIComponentFactory[];
  // (undocumented)
  secondaryToolbarComponents: UIComponentFactory[];
}

// @public (undocumented)
type EditorOnChangeHandler = (
  editorView: EditorView,
  meta: {
    source: 'local' | 'remote';
  },
) => void;

export { EditorPlugin };

// @public (undocumented)
interface EditorPresetProps {
  // (undocumented)
  excludes?: Set<string>;
  // (undocumented)
  experimental?: Array<string>;
  // (undocumented)
  featureFlags?: EditorFeatureFlags;
}

// @public (undocumented)
type EditorProduct = 'bitbucket' | 'confluence' | 'jira' | 'stride' | undefined;

// @public (undocumented)
export interface EditorProps {
  // (undocumented)
  activityProvider?: Promise<ActivityProvider>;
  // (undocumented)
  allowAnalyticsGASV3?: boolean;
  // (undocumented)
  allowBlockType?: BlockTypePluginOptions['allowBlockType'];
  // (undocumented)
  allowBreakout?: boolean;
  // (undocumented)
  allowConfluenceInlineComment?: boolean;
  // (undocumented)
  allowDate?: boolean;
  // (undocumented)
  allowExpand?:
    | boolean
    | {
        allowInsertion?: boolean;
        allowInteractiveExpand?: boolean;
      };
  // (undocumented)
  allowExtension?: ExtensionConfig | boolean;
  // (undocumented)
  allowFindReplace?: FindReplaceOptions | boolean;
  allowFragmentMark?: boolean;
  // (undocumented)
  allowHelpDialog?: boolean;
  // (undocumented)
  allowIndentation?: boolean;
  // (undocumented)
  allowJiraIssue?: boolean;
  // (undocumented)
  allowLayouts?: LayoutPluginOptions | boolean;
  // (undocumented)
  allowNestedTasks?: boolean;
  allowNewInsertionBehaviour?: boolean;
  // (undocumented)
  allowPanel?: PanelPluginConfig | boolean;
  // (undocumented)
  allowRule?: boolean;
  // (undocumented)
  allowStatus?:
    | boolean
    | {
        menuDisabled: boolean;
      };
  // (undocumented)
  allowTables?: PluginConfig | boolean;
  // (undocumented)
  allowTasksAndDecisions?: boolean;
  // (undocumented)
  allowTemplatePlaceholders?: PlaceholderTextOptions | boolean;
  // (undocumented)
  allowTextAlignment?: boolean;
  // (undocumented)
  allowTextColor?: TextColorPluginConfig | boolean;
  // (undocumented)
  allowUndoRedoButtons?: boolean;
  // (undocumented)
  annotationProviders?: AnnotationProviders;
  // (undocumented)
  appearance?: EditorAppearance;
  // (undocumented)
  autoformattingProvider?: Providers['autoformattingProvider'];
  autoScrollIntoView?: boolean;
  // (undocumented)
  codeBlock?: CodeBlockOptions;
  // (undocumented)
  collabEdit?: CollabEditOptions;
  // (undocumented)
  collabEditProvider?: Providers['collabEditProvider'];
  // (undocumented)
  contentComponents?: ReactComponents;
  // (undocumented)
  contentTransformerProvider?: (schema: Schema) => Transformer_2<string>;
  // (undocumented)
  contextIdentifierProvider?: Promise<ContextIdentifierProvider>;
  // (undocumented)
  contextPanel?: ReactComponents;
  // @deprecated (undocumented)
  dangerouslyAppendPlugins?: {
    __plugins: EditorPlugin[];
  };
  // (undocumented)
  defaultValue?: Node_2 | Object | string;
  // (undocumented)
  disabled?: boolean;
  // (undocumented)
  editorActions?: EditorActions;
  // (undocumented)
  elementBrowser?: {
    showModal?: boolean;
    replacePlusMenu?: boolean;
    helpUrl?: string;
    emptyStateHandler?: EmptyStateHandler;
  };
  // (undocumented)
  emojiProvider?: Providers['emojiProvider'];
  // (undocumented)
  errorReporterHandler?: ErrorReportingHandler;
  // (undocumented)
  extensionHandlers?: ExtensionHandlers;
  // (undocumented)
  extensionProviders?: ExtensionProvidersProp;
  featureFlags?: {
    [featureFlag: string]: boolean | string;
  };
  // (undocumented)
  feedbackInfo?: FeedbackInfo;
  // @deprecated
  inputSamplingLimit?: number;
  // (undocumented)
  insertMenuItems?: MenuItem[];
  // (undocumented)
  legacyImageUploadProvider?: Providers['imageUploadProvider'];
  linking?: LinkingOptions;
  // (undocumented)
  macroProvider?: Providers['macroProvider'];
  // (undocumented)
  maxContentSize?: number;
  // (undocumented)
  maxHeight?: number;
  // (undocumented)
  media?: MediaOptions;
  // (undocumented)
  mention?: MentionPluginConfig;
  // @deprecated
  mentionInsertDisplayName?: boolean;
  // (undocumented)
  mentionProvider?: Promise<MentionProvider>;
  // (undocumented)
  minHeight?: number;
  // (undocumented)
  onCancel?: (editorView: EditorView) => void;
  // (undocumented)
  onChange?: EditorOnChangeHandler;
  // (undocumented)
  onDestroy?: () => void;
  // (undocumented)
  onEditorReady?: (editorActions: EditorActions) => void;
  // (undocumented)
  onSave?: (editorView: EditorView) => void;
  performanceTracking?: PerformanceTracking;
  // (undocumented)
  persistScrollGutter?: boolean;
  // (undocumented)
  placeholder?: string;
  // (undocumented)
  placeholderBracketHint?: string;
  // (undocumented)
  popupsBoundariesElement?: HTMLElement;
  // (undocumented)
  popupsMountPoint?: HTMLElement;
  // (undocumented)
  popupsScrollableElement?: HTMLElement;
  // (undocumented)
  presenceProvider?: Promise<any>;
  // (undocumented)
  primaryToolbarComponents?: PrimaryToolbarComponents;
  // (undocumented)
  primaryToolbarIconBefore?: ReactElement;
  // (undocumented)
  quickInsert?: QuickInsertOptions;
  // (undocumented)
  sanitizePrivateContent?: boolean;
  // (undocumented)
  saveOnEnter?: boolean;
  // (undocumented)
  searchProvider?: Promise<SearchProvider>;
  // (undocumented)
  secondaryToolbarComponents?: ReactComponents;
  // (undocumented)
  shouldFocus?: boolean;
  // @deprecated (undocumented)
  smartLinks?: CardOptions;
  // (undocumented)
  taskDecisionProvider?: Promise<TaskDecisionProvider>;
  // (undocumented)
  textFormatting?: TextFormattingOptions;
  trackValidTransactions?:
    | boolean
    | {
        samplingRate: number;
      };
  // @deprecated (undocumented)
  UNSAFE_cards?: CardOptions;
  // (undocumented)
  UNSAFE_useAnalyticsContext?: boolean;
  // (undocumented)
  uploadErrorHandler?: (state: MediaState) => void;
  useStickyToolbar?: RefObject<HTMLElement> | boolean;
  // (undocumented)
  waitForMediaUpload?: boolean;
}

// @public (undocumented)
type EditorProps_2 = {
  plugins?: Array<EditorPlugin>;
  transformer?: (schema: Schema) => Transformer_2<any>;
  children?: React.ReactChild;
  defaultValue?: object | string;
  popupsMountPoint?: HTMLElement;
  popupsBoundariesElement?: HTMLElement;
  popupsScrollableElement?: HTMLElement;
  disabled?: boolean;
  placeholder?: string;
  onAnalyticsEvent?: FireAnalyticsCallback;
  onChange?: (
    value: any,
    meta: {
      source: 'local' | 'remote';
    },
  ) => void;
  onSave?: (value: any) => void;
  onCancel?: (value: any) => void;
  onMount?: (actions: EditorActions) => void;
  onDestroy?: () => void;
};

// @public (undocumented)
interface EditorViewProps {
  // (undocumented)
  allowAnalyticsGASV3?: boolean;
  // (undocumented)
  createAnalyticsEvent?: CreateUIAnalyticsEvent;
  // (undocumented)
  disabled?: boolean;
  // (undocumented)
  editorProps: EditorProps;
  // (undocumented)
  experienceStore?: ExperienceStore;
  // (undocumented)
  onEditorCreated: (instance: {
    view: EditorView;
    config: EditorConfig;
    eventDispatcher: EventDispatcher;
    transformer?: Transformer_2<string>;
  }) => void;
  // (undocumented)
  onEditorDestroyed: (instance: {
    view: EditorView;
    config: EditorConfig;
    eventDispatcher: EventDispatcher;
    transformer?: Transformer_2<string>;
  }) => void;
  // (undocumented)
  portalProviderAPI: PortalProviderAPI;
  // (undocumented)
  providerFactory: ProviderFactory;
  // (undocumented)
  render?: (props: {
    editor: JSX.Element;
    view?: EditorView;
    config: EditorConfig;
    eventDispatcher: EventDispatcher;
    transformer?: Transformer_2<string>;
    dispatchAnalyticsEvent: DispatchAnalyticsEvent;
    editorRef: React_2.RefObject<HTMLDivElement>;
  }) => JSX.Element;
}

// @public (undocumented)
type EditorViewStateUpdatedCallbackProps = {
  readonly originalTransaction: Readonly<Transaction>;
  readonly transactions: Transaction[];
  readonly oldEditorState: Readonly<EditorState>;
  readonly newEditorState: Readonly<EditorState>;
};

// @public (undocumented)
type EditState = {
  type: HyperlinkInsertStatus.EDIT_LINK_TOOLBAR;
  node: Node_2;
  pos: number;
};

export { EmojiResource };

export { EVENT_TYPE };

export { EventDispatcher };

// @public (undocumented)
interface ExtensionConfig {
  // (undocumented)
  allowAutoSave?: boolean;
  // (undocumented)
  allowBreakout?: boolean;
  // (undocumented)
  allowExtendFloatingToolbars?: boolean;
}

// @public (undocumented)
type ExtensionProviders = (ExtensionProvider | Promise<ExtensionProvider>)[];

// @public (undocumented)
type ExtensionProvidersProp =
  | ExtensionProviders
  | ExtensionProvidersWithEditorAction;

// @public (undocumented)
type ExtensionProvidersWithEditorAction = (
  editorActions?: EditorActions,
) => ExtensionProviders;

export { ExtensionType };

// @public (undocumented)
type FeedbackInfo = {
  product?: string;
  packageVersion?: string;
  packageName?: string;
  labels?: Array<string>;
  sessionId?: string;
  contentId?: string;
  tabId?: string;
};

// @public (undocumented)
type FindReplaceOptions = {
  allowMatchCase?: boolean;
};

// @public (undocumented)
type FireAnalyticsCallback = <T>(
  payload: FireAnalyticsEventPayload<T>,
) => undefined | void;

// @public (undocumented)
type FireAnalyticsEventPayload<T = void> = {
  payload: AnalyticsEventPayload<T>;
  channel?: string;
};

export { FloatingToolbarButton };

export { FloatingToolbarColorPicker };

export { FloatingToolbarConfig };

export { FloatingToolbarDatePicker };

export { FloatingToolbarDropdown };

export { FloatingToolbarEmojiPicker };

export { FloatingToolbarInput };

export { FloatingToolbarItem };

export { FloatingToolbarListPicker };

// @public
export const floatingToolbarPluginKey: PluginKey<
  FloatingToolbarPluginState,
  any
>;

// @public (undocumented)
export type FloatingToolbarPluginState = Record<
  'getConfigWithNodeInfo',
  (state: EditorState) => ConfigWithNodeInfo | null | undefined
>;

export { FloatingToolbarSelect };

export { GapCursorSelection };

export { GapCursorSide };

// @public (undocumented)
interface GapSelectionData {
  // (undocumented)
  pos: number;
  // (undocumented)
  type: 'gapcursor';
}

// @public (undocumented)
export function getDefaultPresetOptionsFromEditorProps(
  props: EditorProps,
  createAnalyticsEvent?: CreateUIAnalyticsEvent,
): EditorPresetProps & DefaultPresetPluginOptions;

// @public (undocumented)
export const getListCommands: () => {
  indentList: typeof indentList;
  outdentList: typeof outdentList;
  toggleOrderedList: typeof toggleOrderedList;
  toggleBulletList: typeof toggleBulletList;
};

// @public (undocumented)
export function getNodesCount(node: Node_2): Record<string, number>;

// @public (undocumented)
type getPosHandler = boolean | getPosHandlerNode;

// @public (undocumented)
type getPosHandlerNode = () => number;

// @public
export function hasVisibleContent(node: Node_2): boolean;

// @public (undocumented)
type HeadingLevels = 1 | 2 | 3 | 4 | 5 | 6;

// @public (undocumented)
type HeadingLevelsAndNormalText = HeadingLevels | NormalTextLevel;

// @public
export const historyPluginKey: PluginKey<HistoryPluginState, any>;

// @public (undocumented)
export interface HistoryPluginState {
  // (undocumented)
  canRedo: boolean;
  // (undocumented)
  canUndo: boolean;
}

// @public (undocumented)
export enum HyperlinkInsertStatus {
  // (undocumented)
  EDIT_INSERTED_TOOLBAR = 'EDIT_INSERTED',
  // (undocumented)
  EDIT_LINK_TOOLBAR = 'EDIT',
  // (undocumented)
  INSERT_LINK_TOOLBAR = 'INSERT',
}

// @public
interface HyperlinkPluginOptions {
  // (undocumented)
  cardOptions?: CardOptions;
  // (undocumented)
  linkPicker?: LinkPickerOptions;
  // (undocumented)
  platform?: 'mobile' | 'web';
}

// @public (undocumented)
export interface HyperlinkState {
  // (undocumented)
  activeLinkMark?: LinkToolbarState;
  // (undocumented)
  activeText?: string;
  // (undocumented)
  canInsertLink: boolean;
  // (undocumented)
  inputMethod?: INPUT_METHOD;
  // (undocumented)
  searchSessionId?: string;
  // (undocumented)
  timesViewed: number;
}

// @public (undocumented)
export const hyperlinkStateKey: PluginKey<HyperlinkState, any>;

// @public (undocumented)
function indentList(inputMethod?: InputMethod): Command;

// @public (undocumented)
export type InlineCommentAnnotationProvider = AnnotationTypeProvider<
  AnnotationTypes.INLINE_COMMENT,
  InlineCommentState
> & {
  createComponent?: React_2.ComponentType<InlineCommentCreateComponentProps>;
  viewComponent?: React_2.ComponentType<InlineCommentViewComponentProps>;
  isToolbarAbove?: boolean;
};

// @public (undocumented)
export type InlineCommentCreateComponentProps = AnnotationComponentProps & {
  onCreate: (id: string) => void;
};

// @public (undocumented)
export type InlineCommentState = {
  resolved: boolean;
};

// @public (undocumented)
export type InlineCommentViewComponentProps = AnnotationComponentProps & {
  annotations: Array<AnnotationInfo>;
  onResolve: (id: string) => void;
  onDelete?: (id: string) => void;
};

export { INPUT_METHOD };

// @public (undocumented)
type InputMethod = INPUT_METHOD.KEYBOARD | INPUT_METHOD.TOOLBAR;

// @public (undocumented)
type InputMethod_2 = INPUT_METHOD.KEYBOARD | INPUT_METHOD.TOOLBAR;

// @public (undocumented)
interface InputTracking {
  countNodes?: boolean;
  enabled: boolean;
  freezeThreshold?: number;
  samplingRate?: number;
  severityDegradedThreshold?: number;
  severityNormalThreshold?: number;
  slowThreshold?: number;
  trackSeverity?: boolean;
}

// @public (undocumented)
export type InsertBlockInputMethodToolbar =
  | INPUT_METHOD.INSERT_MENU
  | INPUT_METHOD.TOOLBAR;

// @public (undocumented)
export function insertBlockType(name: string): Command;

// @public (undocumented)
export const insertBlockTypesWithAnalytics: (
  name: string,
  inputMethod: BlockTypeInputMethod,
) => Command;

// @public (undocumented)
export const insertDate: (
  date?: DateType | undefined,
  inputMethod?: InsertBlockInputMethodToolbar | undefined,
  commitMethod?: INPUT_METHOD.KEYBOARD | INPUT_METHOD.PICKER | undefined,
  enterPressed?: boolean,
) => Command;

// @public (undocumented)
export const insertExpand: Command;

// @public (undocumented)
export const insertHorizontalRule: (
  inputMethod:
    | INPUT_METHOD.FORMATTING
    | INPUT_METHOD.INSERT_MENU
    | INPUT_METHOD.QUICK_INSERT
    | INPUT_METHOD.SHORTCUT
    | INPUT_METHOD.TOOLBAR,
) => Command;

// @public (undocumented)
type InsertItemProps = {
  contentItem: TypeAheadItem_2;
  query: string;
  sourceListItem: TypeAheadItem_2[];
};

// @public (undocumented)
export function insertLink(
  from: number,
  to: number,
  incomingHref: string,
  incomingTitle?: string,
  displayText?: string,
  source?: LinkInputMethod,
): Command;

// @public (undocumented)
export const insertLinkWithAnalytics: (
  inputMethod: LinkInputMethod,
  from: number,
  to: number,
  href: string,
  title?: string | undefined,
  displayText?: string | undefined,
  cardsAvailable?: boolean,
) => Command;

// @public (undocumented)
export const insertLinkWithAnalyticsMobileNative: (
  inputMethod: LinkInputMethod,
  from: number,
  to: number,
  href: string,
  title?: string | undefined,
  displayText?: string | undefined,
) => Command;

// @public (undocumented)
export const insertMediaSingleNode: (
  view: EditorView,
  mediaState: MediaState,
  inputMethod?: InputMethodInsertMedia | undefined,
  collection?: string | undefined,
  alignLeftOnInsert?: boolean | undefined,
) => boolean;

// @public (undocumented)
type InsertState = {
  type: HyperlinkInsertStatus.INSERT_LINK_TOOLBAR;
  from: number;
  to: number;
};

// @public (undocumented)
export const insertTaskDecisionCommand: (
  listType: TaskDecisionListType,
  inputMethod?:
    | INPUT_METHOD.FORMATTING
    | INPUT_METHOD.QUICK_INSERT
    | InsertBlockInputMethodToolbar,
  addItem?: AddItemTransactionCreator | undefined,
  listLocalId?: string | undefined,
  itemLocalId?: string | undefined,
) => Command;

// @public (undocumented)
type InviteToEditButtonProps = {
  onClick: (event: React.MouseEvent<HTMLElement>) => void;
  selected: boolean;
};

// @public (undocumented)
type InviteToEditComponentProps = {
  children: ReactElement<InviteToEditButtonProps>;
};

// @public
export function isEmptyDocument(node: Node_2): boolean;

// @public (undocumented)
export function isLinkAtPos(pos: number): Predicate;

// @public (undocumented)
export function isTextAtPos(pos: number): Predicate;

// @public (undocumented)
interface LayoutPluginOptions extends LongPressSelectionPluginOptions {
  // (undocumented)
  allowBreakout?: boolean;
  // (undocumented)
  UNSAFE_addSidebarLayouts?: boolean;
  // (undocumented)
  UNSAFE_allowSingleColumnLayout?: boolean;
}

export { lightModeStatusColorPalette };

// @public
interface LinkingOptions {
  linkPicker?: LinkPickerOptions;
  smartLinks?: CardOptions;
}

// @public (undocumented)
export type LinkInputMethod = INPUT_METHOD.MANUAL | INPUT_METHOD.TYPEAHEAD;

// @public
interface LinkPickerOptions extends Partial<LinkPickerProps> {}

// @public (undocumented)
type LinkToolbarState = EditInsertedState | EditState | InsertState | undefined;

// @public (undocumented)
type Listener = (data: any) => void;

// @public (undocumented)
export type ListInputMethod = INPUT_METHOD.KEYBOARD | INPUT_METHOD.TOOLBAR;

// @public (undocumented)
export interface ListState {
  // (undocumented)
  bulletListActive: boolean;
  // (undocumented)
  bulletListDisabled: boolean;
  // (undocumented)
  decorationSet: DecorationSet;
  // (undocumented)
  orderedListActive: boolean;
  // (undocumented)
  orderedListDisabled: boolean;
}

// @public (undocumented)
export const listStateKey: PluginKey<ListState, any>;

// @public (undocumented)
interface LongPressSelectionPluginOptions {
  // (undocumented)
  useLongPressSelection?: boolean;
}

export { MacroAttributes };

export { MacroProvider };

// @public (undocumented)
interface MeasureHelpers {
  // (undocumented)
  startMeasure: (measureName: string) => void;
  // (undocumented)
  stopMeasure: (
    measureName: string,
    onMeasureComplete?: (duration: number, startTime: number) => void,
  ) => void;
}

// @public (undocumented)
type MeasureListener = (entry: SimpleEntry) => void;

// @public (undocumented)
export const measurements: {
  EDITOR_MOUNTED: string;
  PROSEMIRROR_RENDERED: string;
  PROSEMIRROR_CONTENT_RENDERED: string;
  ON_EDITOR_READY_CALLBACK: string;
  PASTE: string;
};

// @public (undocumented)
interface MediaNodeWithPosHandler {
  // (undocumented)
  getPos: ProsemirrorGetPosHandler;
  // (undocumented)
  node: Node_2;
}

// @public (undocumented)
export interface MediaOptions {
  // (undocumented)
  alignLeftOnInsert?: boolean;
  // (undocumented)
  allowAdvancedToolBarOptions?: boolean;
  // (undocumented)
  allowAltTextOnImages?: boolean;
  // (undocumented)
  allowBreakoutSnapPoints?: boolean;
  // (undocumented)
  allowDropzoneDropLine?: boolean;
  // (undocumented)
  allowLazyLoading?: boolean;
  // (undocumented)
  allowLinking?: boolean;
  // (undocumented)
  allowMarkingUploadsAsIncomplete?: boolean;
  // (undocumented)
  allowMediaGroup?: boolean;
  // (undocumented)
  allowMediaSingle?: MediaSingleOptions | boolean;
  // (undocumented)
  allowMediaSingleEditable?: boolean;
  // (undocumented)
  allowRemoteDimensionsFetch?: boolean;
  // (undocumented)
  allowResizing?: boolean;
  // (undocumented)
  allowResizingInTables?: boolean;
  // (undocumented)
  allowTemplatePlaceholders?: PlaceholderTextOptions | boolean;
  // (undocumented)
  altTextValidator?: (value: string) => string[];
  // (undocumented)
  customDropzoneContainer?: HTMLElement;
  // (undocumented)
  customMediaPicker?: CustomMediaPicker;
  // (undocumented)
  editorSelectionAPI?: EditorSelectionAPI;
  // (undocumented)
  enableDownloadButton?: boolean;
  // (undocumented)
  featureFlags?: MediaFeatureFlags;
  // (undocumented)
  fullWidthEnabled?: boolean;
  // (undocumented)
  isCopyPasteEnabled?: boolean;
  // (undocumented)
  provider?: Providers['mediaProvider'];
  // (undocumented)
  uploadErrorHandler?: (state: MediaState) => void;
  // (undocumented)
  useForgePlugins?: boolean;
  // (undocumented)
  waitForMediaUpload?: boolean;
}

// @public (undocumented)
export const mediaPlugin: NextEditorPlugin<
  'media',
  never,
  MediaOptions | undefined
>;

// @public (undocumented)
export const mediaPluginKey: PluginKey<MediaPluginState, any>;

// @public (undocumented)
type MediaPluginOptions = {
  providerFactory: ProviderFactory;
  nodeViews: {
    [name: string]: (
      node: Node_2,
      view: EditorView,
      getPos: getPosHandler,
    ) => NodeView;
  };
  errorReporter?: ErrorReporter;
  uploadErrorHandler?: (state: MediaState) => void;
  waitForMediaUpload?: boolean;
  customDropzoneContainer?: HTMLElement;
  customMediaPicker?: CustomMediaPicker;
  allowResizing: boolean;
};

// @public (undocumented)
interface MediaPluginState {
  // (undocumented)
  addPendingTask: (promise: Promise<any>) => void;
  // (undocumented)
  allowsUploads: boolean;
  // (undocumented)
  allUploadsFinished: boolean;
  // (undocumented)
  destroy(): void;
  // (undocumented)
  dispatch?: Dispatch;
  // (undocumented)
  editingMediaSinglePos?: number;
  // (undocumented)
  element?: HTMLElement;
  // (undocumented)
  findMediaNode: (id: string) => MediaNodeWithPosHandler | null;
  // (undocumented)
  getMediaOptions: () => MediaPluginOptions;
  // (undocumented)
  handleDrag: (dragState: 'enter' | 'leave') => void;
  // (undocumented)
  handleMediaGroupUpdate: (oldNodes: Node_2[], newNodes: Node_2[]) => void;
  // (undocumented)
  handleMediaNodeMount: (
    node: Node_2,
    getPos: ProsemirrorGetPosHandler,
  ) => void;
  // (undocumented)
  handleMediaNodeRemoval: (
    node: Node_2 | undefined,
    getPos: ProsemirrorGetPosHandler,
  ) => void;
  // (undocumented)
  handleMediaNodeUnmount: (oldNode: Node_2) => void;
  // (undocumented)
  ignoreLinks: boolean;
  // (undocumented)
  insertFile: (
    mediaState: MediaState,
    onMediaStateChanged: MediaStateEventSubscriber,
    pickerType?: string,
  ) => void;
  // (undocumented)
  isFullscreen: boolean;
  // (undocumented)
  layout: RichMediaLayout;
  // (undocumented)
  mediaClientConfig?: MediaClientConfig;
  // (undocumented)
  mediaGroupNodes: Record<string, any>;
  // (undocumented)
  mediaNodes: MediaNodeWithPosHandler[];
  // (undocumented)
  mediaOptions?: MediaOptions;
  // (undocumented)
  mediaProvider?: MediaProvider_2;
  // (undocumented)
  onContextIdentifierProvider: (
    _name: string,
    provider?: Promise<ContextIdentifierProvider>,
  ) => Promise<void>;
  // (undocumented)
  onPopupPickerClose: () => void;
  // (undocumented)
  onPopupToggle: (onPopupToogleCallback: (isOpen: boolean) => void) => void;
  // (undocumented)
  options: MediaPluginOptions;
  // (undocumented)
  pickerPromises: Array<Promise<PickerFacade>>;
  // (undocumented)
  pickers: PickerFacade[];
  // (undocumented)
  removeNodeById: (state: MediaState) => void;
  // (undocumented)
  removeSelectedMediaContainer: () => boolean;
  // (undocumented)
  selectedMediaContainerNode: () => Node_2 | undefined;
  // (undocumented)
  setBrowseFn: (browseFn: () => void) => void;
  // (undocumented)
  setMediaGroupNode: (node: Node_2<any>, getPos: () => number) => void;
  // (undocumented)
  setMediaProvider: (mediaProvider?: Promise<MediaProvider_2>) => Promise<void>;
  // (undocumented)
  setView(view: EditorView): void;
  // (undocumented)
  showDropzone: boolean;
  // (undocumented)
  showEditingDialog?: boolean;
  // (undocumented)
  showMediaPicker: () => void;
  // (undocumented)
  splitMediaGroup: () => boolean;
  // (undocumented)
  updateAndDispatch(
    props: Partial<
      Pick<this, 'allUploadsFinished' | 'allowsUploads' | 'isFullscreen'>
    >,
  ): void;
  // (undocumented)
  updateElement(): void;
  // (undocumented)
  updateMediaNodeAttrs: (
    id: string,
    attrs: object,
    isMediaSingle: boolean,
  ) => boolean | undefined;
  // (undocumented)
  uploadMediaClientConfig?: MediaClientConfig;
  // (undocumented)
  waitForMediaUpload: boolean;
  // (undocumented)
  waitForPendingTasks: (
    timeout?: number,
    lastTask?: Promise<MediaState | null>,
  ) => Promise<MediaState | null>;
}

export { MediaProvider_2 as MediaProvider };

// @public (undocumented)
interface MediaSingleOptions {
  // (undocumented)
  disableLayout?: boolean;
}

// @public (undocumented)
export interface MediaState {
  // (undocumented)
  collection?: string;
  // (undocumented)
  contextId?: string;
  // (undocumented)
  dimensions?: {
    width: number | undefined;
    height: number | undefined;
  };
  // (undocumented)
  error?: {
    name: string;
    description: string;
  };
  // (undocumented)
  fileMimeType?: string;
  // (undocumented)
  fileName?: string;
  // (undocumented)
  fileSize?: number;
  // (undocumented)
  id: string;
  publicId?: string;
  // (undocumented)
  scaleFactor?: number;
  // (undocumented)
  status?: MediaStateStatus;
}

// @public (undocumented)
type MediaStateEvent = MediaState;

// @public (undocumented)
type MediaStateEventListener = (evt: MediaStateEvent) => void;

// @public (undocumented)
type MediaStateEventSubscriber = (listener: MediaStateEventListener) => void;

// @public (undocumented)
type MediaStateStatus =
  | 'cancelled'
  | 'error'
  | 'mobile-upload-end'
  | 'preview'
  | 'ready'
  | 'unknown';

// @public (undocumented)
interface MentionPluginConfig {
  // (undocumented)
  HighlightComponent?: React.ComponentType;
  // (undocumented)
  insertDisplayName?: boolean;
}

// @public (undocumented)
export const mentionPluginKey: PluginKey<MentionPluginState, any>;

// @public (undocumented)
export type MentionPluginState = {
  mentionProvider?: MentionProvider_2 | TeamMentionProvider;
  contextIdentifierProvider?: ContextIdentifierProvider;
  mentions?: Array<MentionDescription>;
};

export { MentionProvider };

export { MentionResource };

// @public (undocumented)
interface MessageDescriptor {
  // (undocumented)
  defaultMessage: string;
  // (undocumented)
  description: string;
  // (undocumented)
  id: string;
}

export { messages };

// @public (undocumented)
type MobileUploadEndEventPayload = {
  readonly file: MediaFile & {
    readonly collectionName?: string;
    readonly publicId?: string;
  };
};

// @public (undocumented)
type MountedPortal = {
  children: () => React_2.ReactChild | null;
  hasAnalyticsContext: boolean;
  hasIntlContext: boolean;
};

// @public (undocumented)
const name_2: string;
export { name_2 as name };

// @public (undocumented)
type NewMediaEvent = (
  state: MediaState,
  onStateChanged: MediaStateEventSubscriber,
  pickerType?: string,
) => void;

// @public (undocumented)
interface NodeSelectionData {
  // (undocumented)
  anchor: number;
  // (undocumented)
  type: 'node';
}

// @public (undocumented)
type NodeViewTracking = {
  enabled: boolean;
  samplingRate?: 100;
  slowThreshold?: number;
};

// @public (undocumented)
type NormalTextLevel = 0;

// @public (undocumented)
type OnChangeCallbackTracking = {
  enabled: boolean;
};

// @public (undocumented)
type OnEditorReadyCallbackTracking = {
  enabled: boolean;
};

// @public (undocumented)
type OnEditorViewStateUpdated = (props: {
  readonly originalTransaction: Readonly<Transaction>;
  readonly transactions: Transaction[];
  readonly oldEditorState: Readonly<EditorState>;
  readonly newEditorState: Readonly<EditorState>;
}) => void;

// @public (undocumented)
export const openDatePicker: () => Command;

// @public (undocumented)
function outdentList(inputMethod?: InputMethod_2): Command;

export { PaletteColor };

// @public (undocumented)
interface PanelPluginConfig {
  // (undocumented)
  allowCustomPanel?: boolean;
  // (undocumented)
  allowCustomPanelEdit?: boolean;
}

// @public (undocumented)
type PastePluginOptions = {
  plainTextPasteLinkification?: boolean;
  cardOptions?: CardOptions;
  sanitizePrivateContent?: boolean;
};

// @public (undocumented)
type PasteTracking = {
  enabled: boolean;
};

// @public (undocumented)
type PerformanceTracking = {
  catchAllTracking?: CatchAllTracking;
  ttiTracking?: TTITracking;
  inputTracking?: InputTracking;
  transactionTracking?: TransactionTracking;
  uiTracking?: UITracking;
  nodeViewTracking?: NodeViewTracking;
  bFreezeTracking?: BrowserFreezetracking;
  proseMirrorRenderedTracking?: ProseMirrorRenderedTracking;
  contentRetrievalTracking?: ContentRetrievalTracking;
  onChangeCallbackTracking?: OnChangeCallbackTracking;
  onEditorReadyCallbackTracking?: OnEditorReadyCallbackTracking;
  pasteTracking?: PasteTracking;
  renderTracking?: RenderTracking;
};

// @public (undocumented)
class PickerFacade {
  constructor(
    pickerType: PickerType,
    config: PickerFacadeConfig,
    pickerConfig?: CustomMediaPicker | null | undefined,
    analyticsName?: string,
  );
  // (undocumented)
  readonly config: PickerFacadeConfig;
  // (undocumented)
  destroy(): void;
  // (undocumented)
  erroredFiles: Set<string>;
  // (undocumented)
  handleMobileUploadEnd: (event: MobileUploadEndEventPayload) => void;
  // (undocumented)
  handleReady: (event: UploadEndEventPayload) => void;
  // (undocumented)
  handleUploadError: ({ error, fileId }: UploadErrorEventPayload) => void;
  // (undocumented)
  handleUploadPreviewUpdate: (event: UploadPreviewUpdateEventPayload) => void;
  // (undocumented)
  init(): Promise<PickerFacade>;
  // (undocumented)
  get mediaPicker(): CustomMediaPicker | undefined;
  // (undocumented)
  onDrag(cb: (state: 'enter' | 'leave') => any): void;
  // (undocumented)
  onNewMedia(cb: NewMediaEvent): void;
  // (undocumented)
  readonly pickerConfig?: CustomMediaPicker | null | undefined;
  // (undocumented)
  setUploadParams(params: UploadParams): void;
  // (undocumented)
  get type(): PickerType;
}

// @public (undocumented)
type PickerFacadeConfig = {
  mediaClientConfig: MediaClientConfig;
  errorReporter: ErrorReportingHandler;
  featureFlags?: MediaFeatureFlags_2;
};

// @public (undocumented)
type PickerType = 'clipboard' | 'customMediaPicker' | 'dropzone';

// @public (undocumented)
interface PlaceholderPluginOptions {
  // (undocumented)
  placeholder?: string;
  // (undocumented)
  placeholderBracketHint?: string;
}

// @public (undocumented)
interface PlaceholderTextOptions {
  // (undocumented)
  allowInserting?: boolean;
}

// @public (undocumented)
export const PortalProvider: React_2.FC<
  WithIntlProps<BasePortalProviderProps>
> & {
  WrappedComponent: React_2.ComponentType<BasePortalProviderProps>;
};

// @public (undocumented)
export class PortalProviderAPI extends EventDispatcher {
  constructor(
    intl: IntlShape,
    onAnalyticsEvent?: FireAnalyticsCallback,
    analyticsContext?: boolean,
    themeMode?: ThemeModes,
  );
  // (undocumented)
  context: any;
  // (undocumented)
  forceUpdate({
    intl,
    themeMode,
  }: {
    intl: IntlShape;
    themeMode: ThemeModes | undefined;
  }): void;
  // (undocumented)
  intl: IntlShape;
  // (undocumented)
  onAnalyticsEvent?: FireAnalyticsCallback;
  // (undocumented)
  portals: Map<HTMLElement, MountedPortal>;
  // (undocumented)
  remove(container: HTMLElement): void;
  // (undocumented)
  render(
    children: () => JSX.Element | React_2.ReactChild | null,
    container: HTMLElement,
    hasAnalyticsContext?: boolean,
    hasIntlContext?: boolean,
  ): void;
  // (undocumented)
  setContext: (context: any) => void;
  // (undocumented)
  themeMode?: ThemeModes;
  // (undocumented)
  useAnalyticsContext?: boolean;
}

// @public (undocumented)
export class PortalRenderer extends React_2.Component<
  {
    portalProviderAPI: PortalProviderAPI;
  },
  PortalRendererState
> {
  constructor(props: { portalProviderAPI: PortalProviderAPI });
  // (undocumented)
  handleUpdate: (portals: Portals) => void;
  // (undocumented)
  render(): JSX.Element;
}

// @public (undocumented)
type PortalRendererState = {
  portals: Portals;
};

// @public (undocumented)
type Portals = Map<HTMLElement, React_2.ReactChild>;

// @public (undocumented)
type Predicate = (state: EditorState, view?: EditorView) => boolean;

export { PresenceProvider };

export { PresenceResource };

// @public (undocumented)
type PrimaryToolbarComponents =
  | BeforeAndAfterToolbarComponents
  | ReactComponents;

// @public (undocumented)
const processItems: (
  items: Array<QuickInsertHandler>,
  intl: IntlShape,
  extendedActions?: Record<string, Function> | undefined,
) => QuickInsertItem[];

// @public (undocumented)
export const processQuickInsertItems: typeof processItems;

// @public (undocumented)
interface Props {
  // (undocumented)
  children?: any;
  // (undocumented)
  isExpanded?: boolean;
  // (undocumented)
  onExpand?: () => void;
  // (undocumented)
  onFocus?: (e: React_2.FocusEvent<HTMLInputElement>) => void;
  // (undocumented)
  placeholder?: string;
}

// @public (undocumented)
interface Props_2 {
  // (undocumented)
  title?: string;
  // (undocumented)
  titlePosition?: PositionType;
}

// @public (undocumented)
interface Props_3 {
  // @deprecated (undocumented)
  labels?: string[];
  // @deprecated (undocumented)
  packageName?: string;
  // @deprecated (undocumented)
  packageVersion?: string;
  // (undocumented)
  popupsBoundariesElement?: HTMLElement;
  // (undocumented)
  popupsMountPoint?: HTMLElement;
  // (undocumented)
  popupsScrollableElement?: HTMLElement;
  // (undocumented)
  product?: EditorProduct;
}

// @public (undocumented)
type Props_4 = {
  visible: boolean;
  children?: React_2.ReactElement;
};

// @public (undocumented)
type Props_5 = {
  oldPluginState: TypeAheadPluginState;
  newPluginState: TypeAheadPluginState;
};

// @public (undocumented)
type ProsemirrorGetPosHandler = () => number;

// @public (undocumented)
type ProseMirrorRenderedTracking = {
  enabled?: boolean;
  trackSeverity: boolean;
  severityNormalThreshold: number;
  severityDegradedThreshold: number;
};

export { QuickInsertActionInsert };

// @public (undocumented)
type QuickInsertHandler =
  | ((intl: IntlShape) => Array<QuickInsertItem>)
  | Array<QuickInsertItem>;

export { QuickInsertItem };

export { QuickInsertItemId };

// @public (undocumented)
type QuickInsertOptions =
  | boolean
  | {
      provider: Promise<QuickInsertProvider>;
    };

// @public (undocumented)
export const quickInsertPluginKey: PluginKey<QuickInsertPluginState, any>;

// @public (undocumented)
interface QuickInsertPluginOptions {
  // (undocumented)
  disableDefaultItems?: boolean;
  // (undocumented)
  elementBrowserHelpUrl?: string;
  // (undocumented)
  emptyStateHandler?: EmptyStateHandler;
  // (undocumented)
  enableElementBrowser?: boolean;
  // (undocumented)
  headless?: boolean;
}

// @public (undocumented)
export type QuickInsertPluginState = {
  isElementBrowserModalOpen: boolean;
  lazyDefaultItems: () => QuickInsertItem[];
  providedItems?: QuickInsertItem[];
  provider?: QuickInsertProvider;
  emptyStateHandler?: EmptyStateHandler;
};

export { QuickInsertProvider };

// @public (undocumented)
type ReactComponents = ReactElement<any> | ReactElement<any>[];

// @public (undocumented)
export const ReactEditorView: React_2.FC<
  WithIntlProps<EditorViewProps & WrappedComponentProps<'intl'>>
> & {
  WrappedComponent: React_2.ComponentType<
    EditorViewProps & WrappedComponentProps<'intl'>
  >;
};

// @public (undocumented)
interface RectData {
  // (undocumented)
  left: number;
  // (undocumented)
  top: number;
}

// @public (undocumented)
export const removeStatus: (showStatusPickerAt: number) => Command;

// @public (undocumented)
type RenderTracking = {
  editor: {
    enabled: boolean;
    useShallow?: boolean;
  };
  reactEditorView: {
    enabled: boolean;
    useShallow?: boolean;
  };
};

// @public (undocumented)
type ScrollGutterPluginOptions = {
  getScrollElement?: (view: EditorView) => HTMLElement | null;
  allowCustomScrollHandler?: boolean;
  persistScrollGutter?: boolean;
  gutterSize?: number;
};

// @public (undocumented)
export type SelectionData =
  | AllSelectionData
  | CellSelectionData
  | GapSelectionData
  | NodeSelectionData
  | TextSelectionData;

// @public (undocumented)
export interface SelectionDataState {
  // (undocumented)
  markTypes: string[];
  // (undocumented)
  nodeTypes: string[];
  // (undocumented)
  rect: RectData;
  // (undocumented)
  selection: SelectionData;
}

// @public (undocumented)
export const selectionPluginKey: PluginKey<any, any>;

// @public (undocumented)
interface SelectionPluginOptions extends LongPressSelectionPluginOptions {}

export { SelectOption };

// @public (undocumented)
export function setBlockType(name: string): Command;

// @public (undocumented)
export function setBlockTypeWithAnalytics(
  name: string,
  inputMethod: BlockTypeInputMethod,
): Command;

// @public (undocumented)
export const setIsExpanded: (isExpanded: boolean) => Command_2;

// @public (undocumented)
export const setKeyboardHeight: (keyboardHeight: number) => Command_2;

// @public (undocumented)
export const setMobilePaddingTop: (paddingTop: number) => Command_2;

// @public (undocumented)
export const setStatusPickerAt: (
  showStatusPickerAt: null | number,
) => (state: EditorState, dispatch: (tr: Transaction) => void) => boolean;

export { setTextSelection };

// @public (undocumented)
interface SimpleEntry {
  // (undocumented)
  duration: number;
  // (undocumented)
  name: string;
  // (undocumented)
  startTime: number;
}

// @public (undocumented)
type State = {
  extensionProvider?: ExtensionProvider;
  quickInsertProvider?: Promise<QuickInsertProvider>;
};

// @public (undocumented)
interface State_2 {}

// @public (undocumented)
interface State_3 {
  // (undocumented)
  jiraIssueCollectorScriptLoading: boolean;
  // (undocumented)
  showOptOutOption?: boolean;
  // (undocumented)
  target?: HTMLElement;
}

// @public (undocumented)
export const statusMessages: {
  placeholder: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  editText: {
    id: string;
    defaultMessage: string;
    description: string;
  };
  editColor: {
    id: string;
    defaultMessage: string;
    description: string;
  };
};

// @public (undocumented)
export const statusPluginKey: PluginKey<StatusState, any>;

// @public (undocumented)
export type StatusState = {
  isNew: boolean;
  showStatusPickerAt: null | number;
};

// @public (undocumented)
export type StatusType = {
  color: Color;
  text: string;
  localId?: string;
};

// @public (undocumented)
type SubscribeToToolbarAndPickerUpdates = (
  editorView: EditorView,
  cb: (args: SubscribeToToolbarAndPickerUpdatesCallbackArgs) => void,
) => () => void;

// @public (undocumented)
export const subscribeToToolbarAndPickerUpdates: SubscribeToToolbarAndPickerUpdates;

// @public (undocumented)
type SubscribeToToolbarAndPickerUpdatesCallbackArgs = {
  dateState: DatePluginState;
  statusState: StatusState;
  toolbarConfig: ConfigWithNodeInfo | null | undefined;
};

// @public (undocumented)
type SubscribeTypeAheadUpdates = (
  editorView: EditorView,
  cb: (props: Props_5) => void,
) => () => void;

// @public (undocumented)
export const subscribeTypeAheadUpdates: SubscribeTypeAheadUpdates;

// @public (undocumented)
export type TaskDecisionInputMethod =
  | INPUT_METHOD.FORMATTING
  | INPUT_METHOD.INSERT_MENU
  | INPUT_METHOD.KEYBOARD
  | INPUT_METHOD.QUICK_INSERT
  | INPUT_METHOD.TOOLBAR;

// @public (undocumented)
type TaskDecisionListType = 'decisionList' | 'taskList';

export { TeamMentionResource };

// @public (undocumented)
type TextColorDefaultColor = {
  color: string;
  label: string;
};

// @public (undocumented)
interface TextColorPluginConfig {
  // @deprecated (undocumented)
  allowMoreTextColors?: boolean;
  // (undocumented)
  defaultColor?: TextColorDefaultColor;
}

// @public (undocumented)
export const textColorPluginKey: PluginKey<TextColorPluginState, any>;

// @public (undocumented)
export type TextColorPluginState = {
  palette: Array<PaletteColor>;
  defaultColor: string;
  disabled?: boolean;
  color: null | string;
};

// @public (undocumented)
export type TextFormattingInputMethodBasic =
  | INPUT_METHOD.FORMATTING
  | INPUT_METHOD.SHORTCUT
  | TextFormattingInputMethodToolbar;

// @public (undocumented)
export type TextFormattingInputMethodToolbar = INPUT_METHOD.TOOLBAR;

// @public (undocumented)
interface TextFormattingOptions {
  // (undocumented)
  disableCode?: boolean;
  // (undocumented)
  disableSmartTextCompletion?: boolean;
  // (undocumented)
  disableSuperscriptAndSubscript?: boolean;
  // (undocumented)
  disableUnderline?: boolean;
  // (undocumented)
  responsiveToolbarMenu?: boolean;
}

// @public (undocumented)
export interface TextFormattingState {
  // (undocumented)
  codeActive?: boolean;
  // (undocumented)
  codeDisabled?: boolean;
  // (undocumented)
  codeHidden?: boolean;
  // (undocumented)
  emActive?: boolean;
  // (undocumented)
  emDisabled?: boolean;
  // (undocumented)
  emHidden?: boolean;
  // (undocumented)
  strikeActive?: boolean;
  // (undocumented)
  strikeDisabled?: boolean;
  // (undocumented)
  strikeHidden?: boolean;
  // (undocumented)
  strongActive?: boolean;
  // (undocumented)
  strongDisabled?: boolean;
  // (undocumented)
  strongHidden?: boolean;
  // (undocumented)
  subscriptActive?: boolean;
  // (undocumented)
  subscriptDisabled?: boolean;
  // (undocumented)
  subscriptHidden?: boolean;
  // (undocumented)
  superscriptActive?: boolean;
  // (undocumented)
  superscriptDisabled?: boolean;
  // (undocumented)
  superscriptHidden?: boolean;
  // (undocumented)
  underlineActive?: boolean;
  // (undocumented)
  underlineDisabled?: boolean;
  // (undocumented)
  underlineHidden?: boolean;
}

// @public (undocumented)
export const textFormattingStateKey: PluginKey<TextFormattingState, any>;

// @public (undocumented)
interface TextSelectionData {
  // (undocumented)
  anchor: number;
  // (undocumented)
  head: number;
  // (undocumented)
  type: 'text';
}

// @public (undocumented)
function toggleBulletList(
  view: EditorView,
  inputMethod?: ListInputMethod,
): boolean;

// @public (undocumented)
export const toggleCode: () => Command;

// @public (undocumented)
export const toggleCodeWithAnalytics: ({
  inputMethod,
}: {
  inputMethod: TextFormattingInputMethodBasic;
}) => Command;

// @public (undocumented)
export const toggleEm: () => Command;

// @public (undocumented)
export const toggleEmWithAnalytics: ({
  inputMethod,
}: {
  inputMethod: TextFormattingInputMethodBasic;
}) => Command;

// @public (undocumented)
function toggleOrderedList(
  view: EditorView,
  inputMethod?: ListInputMethod,
): boolean;

// @public (undocumented)
export const toggleStrike: () => Command;

// @public (undocumented)
export const toggleStrikeWithAnalytics: ({
  inputMethod,
}: {
  inputMethod: TextFormattingInputMethodBasic;
}) => Command;

// @public (undocumented)
export const toggleStrong: () => Command;

// @public (undocumented)
export const toggleStrongWithAnalytics: ({
  inputMethod,
}: {
  inputMethod: TextFormattingInputMethodBasic;
}) => Command;

// @public (undocumented)
export const toggleSubscript: () => Command;

// @public (undocumented)
export const toggleSubscriptWithAnalytics: ({
  inputMethod,
}: {
  inputMethod: TextFormattingInputMethodBasic;
}) => Command;

// @public (undocumented)
export const toggleSuperscript: () => Command;

// @public (undocumented)
export const toggleSuperscriptWithAnalytics: ({
  inputMethod,
}: {
  inputMethod: TextFormattingInputMethodBasic;
}) => Command;

// @public (undocumented)
export const toggleUnderline: () => Command;

// @public (undocumented)
export const toggleUnderlineWithAnalytics: ({
  inputMethod,
}: {
  inputMethod: TextFormattingInputMethodBasic;
}) => Command;

// @public (undocumented)
export class ToolbarFeedback extends PureComponent<Props_3, State_3> {
  constructor(props: Props_3);
  // (undocumented)
  static contextTypes: {
    editorActions: PropTypes.Validator<object>;
  };
  // (undocumented)
  render(): jsx.JSX.Element | null;
  // (undocumented)
  showJiraCollectorDialogCallback?: () => void;
  // (undocumented)
  state: State_3;
}

// @public (undocumented)
export const ToolbarHelp: React_2.FC<
  WithIntlProps<Props_2 & WrappedComponentProps<'intl'>>
> & {
  WrappedComponent: React_2.ComponentType<
    Props_2 & WrappedComponentProps<'intl'>
  >;
};

// @public (undocumented)
class TransactionTracker {
  // (undocumented)
  addMeasureListener(listener: MeasureListener): void;
  // (undocumented)
  bumpDispatchCounter: (options: TransactionTracking) => number;
  // (undocumented)
  getMeasureHelpers: (options: TransactionTracking) => MeasureHelpers;
  // (undocumented)
  removeMeasureListener(listener: MeasureListener): void;
  // (undocumented)
  shouldTrackTransaction(options: TransactionTracking): boolean;
}

// @public (undocumented)
type TransactionTracking = {
  enabled: boolean;
  usePerformanceMarks?: boolean;
  samplingRate?: number;
  slowThreshold?: number;
  outlierThreshold?: number;
  outlierFactor?: number;
};

// @public (undocumented)
type TTITracking = {
  enabled: boolean;
  ttiIdleThreshold?: number;
  ttiCancelTimeout?: number;
  trackSeverity?: boolean;
  ttiSeverityNormalThreshold?: number;
  ttiSeverityDegradedThreshold?: number;
  ttiFromInvocationSeverityNormalThreshold?: number;
  ttiFromInvocationSeverityDegradedThreshold?: number;
};

// @public (undocumented)
type TypeAheadInputMethod =
  | INPUT_METHOD.INSERT_MENU
  | INPUT_METHOD.KEYBOARD
  | INPUT_METHOD.QUICK_INSERT
  | INPUT_METHOD.TOOLBAR;

export { TypeAheadItem };

// @public (undocumented)
export const typeAheadPluginKey: PluginKey<TypeAheadPluginState, any>;

// @public (undocumented)
type TypeAheadPluginOptions = {
  isMobile?: boolean;
  createAnalyticsEvent?: CreateUIAnalyticsEvent_2;
};

// @public (undocumented)
export type TypeAheadPluginState = {
  decorationSet: DecorationSet;
  decorationElement: HTMLElement | null;
  typeAheadHandlers: Array<TypeAheadHandler>;
  query: string;
  items: Array<TypeAheadItem>;
  triggerHandler?: TypeAheadHandler;
  selectedIndex: number;
  stats: TypeAheadStatsSerializable | null;
  inputMethod: TypeAheadInputMethod | null;
};

// @public (undocumented)
interface TypeAheadStatsSerializable extends TypeAheadStats {
  // (undocumented)
  serialize: () => TypeAheadStats;
}

// @public (undocumented)
type UITracking = {
  enabled: boolean;
  samplingRate?: number;
  slowThreshold?: number;
};

// @public (undocumented)
export type UpdateEvent = 'create' | 'delete' | 'resolve' | 'unresolve';

// @public (undocumented)
export function updateLink(
  href: string,
  text: string,
  pos: number,
  to?: number,
): Command;

// @public (undocumented)
export const updateStatus: (status?: StatusType | undefined) => Command;

// @public (undocumented)
export const updateStatusWithAnalytics: (
  inputMethod: InsertBlockInputMethodToolbar,
  status?: StatusType | undefined,
) => Command;

// @public (undocumented)
export const version: string;

// @public (undocumented)
type VisibilityEvent = 'setvisibility';

// @public (undocumented)
export class WithEditorActions extends React_2.Component<
  WithEditorActionsProps,
  any
> {
  // (undocumented)
  componentDidMount(): void;
  // (undocumented)
  componentWillUnmount(): void;
  // (undocumented)
  context: {
    editorActions: EditorActions;
  };
  // (undocumented)
  static contextTypes: {
    editorActions: PropTypes.Validator<object>;
  };
  // (undocumented)
  render(): React_2.ReactElement<
    any,
    React_2.JSXElementConstructor<any> | string
  > | null;
}

// @public (undocumented)
interface WithEditorActionsProps {
  // (undocumented)
  render(actions: EditorActions): React_2.ReactElement<any> | null;
}

// @public (undocumented)
export class WithHelpTrigger extends React_2.Component<
  {
    render: (openHelp: () => void) => React_2.ReactNode;
  },
  any
> {
  // (undocumented)
  static contextTypes: {
    editorActions: PropTypes.Validator<object>;
  };
  // (undocumented)
  openHelp: () => void;
  // (undocumented)
  render(): React_2.ReactNode;
}

export { WithPluginState };

// (No @packageDocumentation comment for this package)
```

<!--SECTION END: Main Entry Types-->

### Peer Dependencies

<!--SECTION START: Peer Dependencies-->

```json
{
  "@atlaskit/link-provider": "^1.3.8",
  "@atlaskit/media-core": "^34.0.1",
  "react": "^16.8.0",
  "react-dom": "^16.8.0",
  "react-intl-next": "npm:react-intl@^5.18.1"
}
```

<!--SECTION END: Peer Dependencies-->
