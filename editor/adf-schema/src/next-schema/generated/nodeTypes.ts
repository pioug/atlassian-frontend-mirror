/**
 * This file was automatically generated by @atlaskit/adf-schema-generator
 * DO NOT MODIFY IT BY HAND. Instead, modify the source files in "packages/adf-schema/src/next-schema" ,
 * and run "yarn workspace @atlaskit/adf-schema build:schema:all" to regenerate this file.
 */

import { createPMNodeSpecFactory } from '../../schema/createPMSpecFactory';

import type { Node as PMNode } from '@atlaskit/editor-prosemirror/model';

import type {
  InlineDefinition,
  BlockDefinition,
  BlockRootOnlyDefinition,
} from './nodeGroupTypes';

import type {
  AlignmentMark,
  AnnotationMark,
  BackgroundColorMark,
  BorderMark,
  BreakoutMark,
  CodeMark,
  ConfluenceInlineCommentMark,
  DataConsumerMark,
  EmMark,
  FragmentMark,
  IndentationMark,
  LinkMark,
  StrikeMark,
  StrongMark,
  SubsupMark,
  TextColorMark,
  TypeAheadQueryMark,
  UnderlineMark,
  UnsupportedMarkMark,
  UnsupportedNodeAttributeMark,
} from './markTypes';

export interface BlockCardNodeAttributes0 {
  localId?: string;
  url?: string;
  datasource: Record<string, unknown>;
  width?: number;
  layout?:
    | 'wide'
    | 'full-width'
    | 'center'
    | 'wrap-right'
    | 'wrap-left'
    | 'align-end'
    | 'align-start';
}

export interface BlockCardNodeAttributes1 {
  url: string;
  localId?: string;
}

export interface BlockCardNodeAttributes2 {
  data: Record<string, unknown>;
  localId?: string;
}

export interface BlockCardDefinition {
  type: 'blockCard';
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs:
    | BlockCardNodeAttributes0
    | BlockCardNodeAttributes1
    | BlockCardNodeAttributes2;
}

export type BlockCardNode = PMNode & BlockCardDefinition;

export const blockCard = createPMNodeSpecFactory<BlockCardNode>({
  group: 'block',
  attrs: {
    localId: { default: null },
    url: { default: null },
    datasource: { default: null },
    width: { default: null },
    layout: { default: null },
    data: { default: null },
  },
  selectable: true,
  draggable: true,
});

export interface BlockquoteDefinition {
  type: 'blockquote';
  content: Array<
    | BulletListDefinition
    | CodeBlockDefinition
    | ExtensionWithMarksDefinition
    | MediaGroupDefinition
    | MediaSingleCaptionDefinition
    | MediaSingleFullDefinition
    | OrderedListDefinition
    | ParagraphWithNoMarksDefinition
    | UnsupportedBlockDefinition
  >;
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: { localId?: string };
}

export type BlockquoteNode = PMNode & BlockquoteDefinition;

export const blockquote = createPMNodeSpecFactory<BlockquoteNode>({
  content:
    '(paragraph | orderedList | bulletList | unsupportedBlock | codeBlock | mediaSingle | mediaGroup | extension)+',
  marks: 'unsupportedMark unsupportedNodeAttribute dataConsumer fragment',
  group: 'block',
  attrs: { localId: { default: null } },
  selectable: true,
  defining: true,
});

export interface BlockquoteLegacyDefinition {
  type: 'blockquote';
  content: Array<ParagraphDefinition | UnsupportedBlockDefinition>;
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: { localId?: string };
}

export type BlockquoteLegacyNode = PMNode & BlockquoteLegacyDefinition;

export const blockquoteLegacy = createPMNodeSpecFactory<BlockquoteLegacyNode>({
  content: '(paragraph | unsupportedBlock)+',
  marks: 'unsupportedMark unsupportedNodeAttribute',
  group: 'block',
  attrs: { localId: { default: null } },
  selectable: true,
  defining: true,
});

export interface BlockTaskItemDefinition {
  type: 'blockTaskItem';
  content: Array<
    | ExtensionWithMarksDefinition
    | ExtensionWithMarksDefinition
    | ParagraphWithNoMarksDefinition
    | ParagraphWithNoMarksDefinition
  >;
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: { localId: string; state: 'TODO' | 'DONE' };
}

export type BlockTaskItemNode = PMNode & BlockTaskItemDefinition;

export const blockTaskItem = createPMNodeSpecFactory<BlockTaskItemNode>({
  content: '(paragraph | extension) (paragraph | extension)*',
  marks: 'dataConsumer fragment unsupportedMark unsupportedNodeAttribute',
  attrs: { localId: { default: '' }, state: { default: 'TODO' } },
  selectable: false,
  defining: true,
});

export interface BodiedExtensionDefinition {
  type: 'bodiedExtension';
  content: Array<
    | BlockCardDefinition
    | BlockquoteDefinition
    | BulletListDefinition
    | CodeBlockDefinition
    | DecisionListDefinition
    | EmbedCardDefinition
    | ExtensionWithMarksDefinition
    | HeadingWithNoMarksDefinition
    | MediaGroupDefinition
    | MediaSingleCaptionDefinition
    | MediaSingleFullDefinition
    | OrderedListDefinition
    | PanelDefinition
    | ParagraphWithNoMarksDefinition
    | RuleDefinition
    | TableDefinition
    | TableWithNestedTableDefinition
    | TaskListDefinition
    | UnsupportedBlockDefinition
  >;
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: {
    extensionKey: string;
    extensionType: string;
    parameters?: Record<string, unknown>;
    text?: string;
    layout?: 'wide' | 'full-width' | 'default';
    localId?: string;
  };
}

export type BodiedExtensionNode = PMNode & BodiedExtensionDefinition;

export const bodiedExtension = createPMNodeSpecFactory<BodiedExtensionNode>({
  content:
    '(paragraph | panel | blockquote | orderedList | bulletList | rule | heading | codeBlock | mediaGroup | mediaSingle | decisionList | taskList | table | blockCard | embedCard | extension | unsupportedBlock)+',
  marks: 'dataConsumer fragment unsupportedMark unsupportedNodeAttribute',
  group: 'block',
  attrs: {
    extensionKey: { default: '' },
    extensionType: { default: '' },
    parameters: { default: null },
    text: { default: null },
    layout: { default: 'default' },
    localId: { default: null },
  },
  selectable: true,
  defining: true,
  isolating: true,
});

export interface BodiedExtensionWithMarksDefinition {
  type: 'bodiedExtension';
  marks: Array<
    | DataConsumerMark
    | FragmentMark
    | UnsupportedMarkMark
    | UnsupportedNodeAttributeMark
  >;
  attrs: {
    extensionKey: string;
    extensionType: string;
    parameters?: Record<string, unknown>;
    text?: string;
    layout?: 'wide' | 'full-width' | 'default';
    localId?: string;
  };
}

export type BodiedExtensionWithMarksNode = PMNode &
  BodiedExtensionWithMarksDefinition;

export const bodiedExtensionWithMarks =
  createPMNodeSpecFactory<BodiedExtensionWithMarksNode>({
    marks: 'dataConsumer fragment unsupportedMark unsupportedNodeAttribute',
    group: 'block',
    attrs: {
      extensionKey: { default: '' },
      extensionType: { default: '' },
      parameters: { default: null },
      text: { default: null },
      layout: { default: 'default' },
      localId: { default: null },
    },
    selectable: true,
    defining: true,
    isolating: true,
  });

export interface BodiedSyncBlockDefinition {
  type: 'bodiedSyncBlock';
  content: Array<
    | BlockCardDefinition
    | BlockquoteDefinition
    | BlockquoteLegacyDefinition
    | BulletListDefinition
    | CodeBlockDefinition
    | ConfluenceUnsupportedBlockDefinition
    | DecisionListDefinition
    | EmbedCardDefinition
    | ExpandDefinition
    | HeadingDefinition
    | HeadingWithAlignmentDefinition
    | HeadingWithIndentationDefinition
    | HeadingWithNoMarksDefinition
    | LayoutSectionDefinition
    | LayoutSectionFullDefinition
    | LayoutSectionWithSingleColumnStage0Definition
    | MediaGroupDefinition
    | MediaSingleCaptionDefinition
    | MediaSingleDefinition
    | MediaSingleFullDefinition
    | MediaSingleWidthTypeDefinition
    | OrderedListDefinition
    | PanelDefinition
    | ParagraphDefinition
    | ParagraphWithAlignmentDefinition
    | ParagraphWithIndentationDefinition
    | ParagraphWithNoMarksDefinition
    | RuleDefinition
    | TableDefinition
    | TableWithNestedTableDefinition
    | TaskListDefinition
    | UnsupportedBlockDefinition
  >;
  marks: Array<
    BreakoutMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark
  >;
  attrs: { resourceId: string; localId: string };
}

export type BodiedSyncBlockNode = PMNode & BodiedSyncBlockDefinition;

export const bodiedSyncBlock = createPMNodeSpecFactory<BodiedSyncBlockNode>({
  content:
    '(paragraph | blockCard | blockquote | bulletList | codeBlock | confluenceUnsupportedBlock | decisionList | embedCard | expand | heading | layoutSection | mediaGroup | mediaSingle | orderedList | panel | rule | table | taskList | unsupportedBlock)+',
  marks:
    'unsupportedMark unsupportedNodeAttribute alignment indentation breakout link fragment',
  attrs: { resourceId: { default: '' }, localId: { default: '' } },
  selectable: true,
  isolating: true,
});

export interface BulletListDefinition {
  type: 'bulletList';
  content: Array<
    ListItemDefinition | ListItemWithNestedDecisionStage0Definition
  >;
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: { localId?: string };
}

export type BulletListNode = PMNode & BulletListDefinition;

export const bulletList = createPMNodeSpecFactory<BulletListNode>({
  content: 'listItem+',
  marks: 'unsupportedMark unsupportedNodeAttribute',
  group: 'block',
  attrs: { localId: { default: null } },
  selectable: false,
});

export interface CaptionDefinition {
  type: 'caption';
  content: Array<
    | DateDefinition
    | DateStage0Definition
    | EmojiDefinition
    | EmojiStage0Definition
    | HardBreakDefinition
    | InlineCardDefinition
    | InlineCardStage0Definition
    | MentionDefinition
    | MentionStage0Definition
    | PlaceholderDefinition
    | StatusDefinition
    | StatusStage0Definition
    | TextCodeInlineDefinition
    | TextFormattedDefinition
    | UnsupportedInlineDefinition
  >;
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: { localId?: string };
}

export type CaptionNode = PMNode & CaptionDefinition;

export const caption = createPMNodeSpecFactory<CaptionNode>({
  content:
    '(hardBreak | mention | emoji | date | placeholder | inlineCard | status | text | unsupportedInline)*',
  marks: '_',
  attrs: { localId: { default: null } },
  selectable: false,
  isolating: true,
});

export interface CodeBlockDefinition {
  type: 'codeBlock';
  content: Array<TextWithNoMarksDefinition | UnsupportedInlineDefinition>;
  attrs: { language?: string; uniqueId?: string; localId?: string };
}

export type CodeBlockNode = PMNode & CodeBlockDefinition;

export const codeBlock = createPMNodeSpecFactory<CodeBlockNode>({
  content: '(text | unsupportedInline)*',
  marks: 'unsupportedMark unsupportedNodeAttribute',
  group: 'block',
  attrs: {
    language: { default: null },
    uniqueId: { default: null },
    localId: { default: null },
  },
  code: true,
  defining: true,
});

export interface CodeBlockRootOnlyDefinition {
  type: 'codeBlock';
  content: Array<TextWithNoMarksDefinition | UnsupportedInlineDefinition>;
  marks: Array<
    BreakoutMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark
  >;
  attrs: { language?: string; uniqueId?: string; localId?: string };
}

export type CodeBlockRootOnlyNode = PMNode & CodeBlockRootOnlyDefinition;

export const codeBlockRootOnly = createPMNodeSpecFactory<CodeBlockRootOnlyNode>(
  {
    content: '(text | unsupportedInline)*',
    marks: 'unsupportedMark unsupportedNodeAttribute',
    attrs: {
      language: { default: null },
      uniqueId: { default: null },
      localId: { default: null },
    },
    code: true,
    defining: true,
  },
);

export interface ConfluenceJiraIssueDefinition {
  type: 'confluenceJiraIssue';
  attrs: {
    issueKey: string;
    macroId?: string;
    schemaVersion?: string;
    server?: string;
    serverId?: string;
  };
}

export type ConfluenceJiraIssueNode = PMNode & ConfluenceJiraIssueDefinition;

export const confluenceJiraIssue =
  createPMNodeSpecFactory<ConfluenceJiraIssueNode>({
    group: 'inline',
    inline: true,
    atom: true,
    attrs: {
      issueKey: { default: '' },
      macroId: { default: null },
      schemaVersion: { default: null },
      server: { default: null },
      serverId: { default: null },
    },
  });

export interface ConfluenceUnsupportedBlockDefinition {
  type: 'confluenceUnsupportedBlock';
  attrs: { cxhtml: string };
}

export type ConfluenceUnsupportedBlockNode = PMNode &
  ConfluenceUnsupportedBlockDefinition;

export const confluenceUnsupportedBlock =
  createPMNodeSpecFactory<ConfluenceUnsupportedBlockNode>({
    group: 'block',
    attrs: { cxhtml: { default: null } },
  });

export interface ConfluenceUnsupportedInlineDefinition {
  type: 'confluenceUnsupportedInline';
  attrs: { cxhtml: string };
}

export type ConfluenceUnsupportedInlineNode = PMNode &
  ConfluenceUnsupportedInlineDefinition;

export const confluenceUnsupportedInline =
  createPMNodeSpecFactory<ConfluenceUnsupportedInlineNode>({
    group: 'inline',
    inline: true,
    atom: true,
    attrs: { cxhtml: { default: null } },
  });

export interface DateDefinition {
  type: 'date';
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: { timestamp: string; localId?: string };
}

export type DateNode = PMNode & DateDefinition;

export const date = createPMNodeSpecFactory<DateNode>({
  group: 'inline',
  inline: true,
  attrs: { timestamp: { default: '' }, localId: { default: null } },
  selectable: true,
});

export interface DateStage0Definition {
  type: 'date';
  marks: Array<
    AnnotationMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark
  >;
  attrs: { timestamp: string; localId?: string };
}

export type DateStage0Node = PMNode & DateStage0Definition;

export const dateStage0 = createPMNodeSpecFactory<DateStage0Node>({
  group: 'inline',
  inline: true,
  attrs: { timestamp: { default: '' }, localId: { default: null } },
  selectable: true,
});

export interface DecisionItemDefinition {
  type: 'decisionItem';
  content: Array<InlineDefinition>;
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: { localId: string; state: string };
}

export type DecisionItemNode = PMNode & DecisionItemDefinition;

export const decisionItem = createPMNodeSpecFactory<DecisionItemNode>({
  content: 'inline*',
  marks: '_',
  attrs: { localId: { default: '' }, state: { default: 'DECIDED' } },
  defining: true,
});

export interface DecisionListDefinition {
  type: 'decisionList';
  content: Array<DecisionItemDefinition | UnsupportedBlockDefinition>;
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: { localId: string };
}

export type DecisionListNode = PMNode & DecisionListDefinition;

export const decisionList = createPMNodeSpecFactory<DecisionListNode>({
  content: '(decisionItem | unsupportedBlock)+',
  marks: 'unsupportedMark unsupportedNodeAttribute',
  group: 'block',
  attrs: { localId: { default: '' } },
  selectable: false,
  defining: true,
});

export interface DocDefinition {
  type: 'doc';
  content: Array<
    | BlockDefinition
    | BlockRootOnlyDefinition
    | BodiedSyncBlockDefinition
    | CodeBlockRootOnlyDefinition
    | ExpandRootOnlyDefinition
    | LayoutSectionDefinition
    | LayoutSectionFullDefinition
    | LayoutSectionWithSingleColumnStage0Definition
    | SyncBlockDefinition
  >;
}

export type DocNode = PMNode & DocDefinition;

export const doc = createPMNodeSpecFactory<DocNode>({
  content:
    '(block | codeBlock | layoutSection | blockRootOnly | expand | syncBlock | bodiedSyncBlock)+',
  marks:
    'unsupportedMark unsupportedNodeAttribute alignment indentation dataConsumer fragment breakout',
});

export interface EmbedCardDefinition {
  type: 'embedCard';
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: {
    url: string;
    layout:
      | 'wide'
      | 'full-width'
      | 'center'
      | 'wrap-right'
      | 'wrap-left'
      | 'align-end'
      | 'align-start';
    width?: number;
    originalHeight?: number;
    originalWidth?: number;
    localId?: string;
  };
}

export type EmbedCardNode = PMNode & EmbedCardDefinition;

export const embedCard = createPMNodeSpecFactory<EmbedCardNode>({
  group: 'block',
  attrs: {
    url: { default: '' },
    layout: { default: 'center' },
    width: { default: 100 },
    originalHeight: { default: null },
    originalWidth: { default: null },
    localId: { default: null },
  },
  selectable: true,
});

export interface EmojiDefinition {
  type: 'emoji';
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: { shortName: string; id?: string; text?: string; localId?: string };
}

export type EmojiNode = PMNode & EmojiDefinition;

export const emoji = createPMNodeSpecFactory<EmojiNode>({
  group: 'inline',
  inline: true,
  attrs: {
    shortName: { default: '' },
    id: { default: '' },
    text: { default: '' },
    localId: { default: null },
  },
  selectable: true,
});

export interface EmojiStage0Definition {
  type: 'emoji';
  marks: Array<
    AnnotationMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark
  >;
  attrs: { shortName: string; id?: string; text?: string; localId?: string };
}

export type EmojiStage0Node = PMNode & EmojiStage0Definition;

export const emojiStage0 = createPMNodeSpecFactory<EmojiStage0Node>({
  group: 'inline',
  inline: true,
  attrs: {
    shortName: { default: '' },
    id: { default: '' },
    text: { default: '' },
    localId: { default: null },
  },
  selectable: true,
});

export interface ExpandDefinition {
  type: 'expand';
  content: Array<
    | BlockCardDefinition
    | BlockquoteDefinition
    | BulletListDefinition
    | CodeBlockDefinition
    | DecisionListDefinition
    | EmbedCardDefinition
    | ExtensionWithMarksDefinition
    | HeadingWithNoMarksDefinition
    | MediaGroupDefinition
    | MediaSingleCaptionDefinition
    | MediaSingleFullDefinition
    | NestedExpandWithNoMarksDefinition
    | OrderedListDefinition
    | PanelDefinition
    | ParagraphWithNoMarksDefinition
    | RuleDefinition
    | TableDefinition
    | TableWithNestedTableDefinition
    | TaskListDefinition
    | UnsupportedBlockDefinition
  >;
  attrs: { title?: string; __expanded?: boolean; localId?: string };
}

export type ExpandNode = PMNode & ExpandDefinition;

export const expand = createPMNodeSpecFactory<ExpandNode>({
  content:
    '(paragraph | panel | blockquote | orderedList | bulletList | rule | heading | codeBlock | mediaGroup | mediaSingle | decisionList | taskList | table | blockCard | embedCard | extension | unsupportedBlock | nestedExpand)+',
  marks: 'unsupportedMark unsupportedNodeAttribute fragment dataConsumer',
  group: 'block',
  attrs: {
    title: { default: '' },
    __expanded: { default: true },
    localId: { default: null },
  },
  selectable: true,
  isolating: true,
});

export interface ExpandRootOnlyDefinition {
  type: 'expand';
  content: Array<
    | BlockCardDefinition
    | BlockquoteDefinition
    | BulletListDefinition
    | CodeBlockDefinition
    | DecisionListDefinition
    | EmbedCardDefinition
    | ExtensionWithMarksDefinition
    | HeadingWithNoMarksDefinition
    | MediaGroupDefinition
    | MediaSingleCaptionDefinition
    | MediaSingleFullDefinition
    | NestedExpandWithNoMarksDefinition
    | OrderedListDefinition
    | PanelDefinition
    | ParagraphWithNoMarksDefinition
    | RuleDefinition
    | TableDefinition
    | TableWithNestedTableDefinition
    | TaskListDefinition
    | UnsupportedBlockDefinition
  >;
  marks: Array<
    BreakoutMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark
  >;
  attrs: { title?: string; __expanded?: boolean; localId?: string };
}

export type ExpandRootOnlyNode = PMNode & ExpandRootOnlyDefinition;

export const expandRootOnly = createPMNodeSpecFactory<ExpandRootOnlyNode>({
  content:
    '(paragraph | panel | blockquote | orderedList | bulletList | rule | heading | codeBlock | mediaGroup | mediaSingle | decisionList | taskList | table | blockCard | embedCard | extension | unsupportedBlock | nestedExpand)+',
  marks: 'unsupportedMark unsupportedNodeAttribute fragment dataConsumer',
  attrs: {
    title: { default: '' },
    __expanded: { default: true },
    localId: { default: null },
  },
  selectable: true,
  isolating: true,
});

export interface ExtensionDefinition {
  type: 'extension';
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: {
    extensionKey: string;
    extensionType: string;
    parameters?: Record<string, unknown>;
    text?: string;
    layout?: 'wide' | 'full-width' | 'default';
    localId?: string;
  };
}

export type ExtensionNode = PMNode & ExtensionDefinition;

export const extension = createPMNodeSpecFactory<ExtensionNode>({
  group: 'block',
  atom: true,
  attrs: {
    extensionKey: { default: '' },
    extensionType: { default: '' },
    parameters: { default: null },
    text: { default: null },
    layout: { default: 'default' },
    localId: { default: null },
  },
  selectable: true,
});

export interface ExtensionWithMarksDefinition {
  type: 'extension';
  marks: Array<
    | DataConsumerMark
    | FragmentMark
    | UnsupportedMarkMark
    | UnsupportedNodeAttributeMark
  >;
  attrs: {
    extensionKey: string;
    extensionType: string;
    parameters?: Record<string, unknown>;
    text?: string;
    layout?: 'wide' | 'full-width' | 'default';
    localId?: string;
  };
}

export type ExtensionWithMarksNode = PMNode & ExtensionWithMarksDefinition;

export const extensionWithMarks =
  createPMNodeSpecFactory<ExtensionWithMarksNode>({
    group: 'block',
    atom: true,
    attrs: {
      extensionKey: { default: '' },
      extensionType: { default: '' },
      parameters: { default: null },
      text: { default: null },
      layout: { default: 'default' },
      localId: { default: null },
    },
    selectable: true,
  });

export interface ExtensionFrameStage0Definition {
  type: 'extensionFrame';
  content: Array<
    | BlockCardDefinition
    | BlockquoteDefinition
    | BodiedExtensionWithMarksDefinition
    | BulletListDefinition
    | CodeBlockDefinition
    | DecisionListDefinition
    | EmbedCardDefinition
    | ExtensionWithMarksDefinition
    | HeadingWithNoMarksDefinition
    | MediaGroupDefinition
    | MediaSingleCaptionDefinition
    | MediaSingleFullDefinition
    | OrderedListDefinition
    | PanelDefinition
    | ParagraphWithNoMarksDefinition
    | RuleDefinition
    | TableDefinition
    | TableWithNestedTableDefinition
    | TaskListDefinition
    | UnsupportedBlockDefinition
  >;
  marks: Array<
    | DataConsumerMark
    | FragmentMark
    | UnsupportedMarkMark
    | UnsupportedNodeAttributeMark
  >;
}

export type ExtensionFrameStage0Node = PMNode & ExtensionFrameStage0Definition;

export const extensionFrameStage0 =
  createPMNodeSpecFactory<ExtensionFrameStage0Node>({
    content:
      '(paragraph | panel | blockquote | orderedList | bulletList | rule | heading | codeBlock | mediaGroup | mediaSingle | decisionList | taskList | table | extension | bodiedExtension | unsupportedBlock | blockCard | embedCard)+',
    marks: 'dataConsumer fragment unsupportedMark unsupportedNodeAttribute',
    attrs: {},
    selectable: false,
    definingAsContext: false,
    definingForContent: true,
    isolating: true,
  });

export interface HardBreakDefinition {
  type: 'hardBreak';
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: { text?: '\n'; localId?: string };
}

export type HardBreakNode = PMNode & HardBreakDefinition;

export const hardBreak = createPMNodeSpecFactory<HardBreakNode>({
  group: 'inline',
  inline: true,
  attrs: { text: { default: '\n' }, localId: { default: null } },
  selectable: false,
  linebreakReplacement: true,
});

export interface HeadingDefinition {
  type: 'heading';
  content: Array<InlineDefinition>;
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: { level: number; localId?: string };
}

export type HeadingNode = PMNode & HeadingDefinition;

export const heading = createPMNodeSpecFactory<HeadingNode>({
  content: 'inline*',
  marks:
    'link em strong strike subsup underline textColor annotation backgroundColor typeAheadQuery confluenceInlineComment unsupportedNodeAttribute unsupportedMark code dataConsumer fragment border',
  group: 'block',
  attrs: { level: { default: 1 }, localId: { default: null } },
  selectable: false,
  defining: true,
});

export interface HeadingWithAlignmentDefinition {
  type: 'heading';
  marks: Array<
    AlignmentMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark
  >;
  attrs: { level: number; localId?: string };
}

export type HeadingWithAlignmentNode = PMNode & HeadingWithAlignmentDefinition;

export const headingWithAlignment =
  createPMNodeSpecFactory<HeadingWithAlignmentNode>({
    group: 'block',
    attrs: { level: { default: 1 }, localId: { default: null } },
    selectable: false,
    defining: true,
  });

export interface HeadingWithIndentationDefinition {
  type: 'heading';
  marks: Array<
    IndentationMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark
  >;
  attrs: { level: number; localId?: string };
}

export type HeadingWithIndentationNode = PMNode &
  HeadingWithIndentationDefinition;

export const headingWithIndentation =
  createPMNodeSpecFactory<HeadingWithIndentationNode>({
    group: 'block',
    attrs: { level: { default: 1 }, localId: { default: null } },
    selectable: false,
    defining: true,
  });

export interface HeadingWithNoMarksDefinition {
  type: 'heading';
  attrs: { level: number; localId?: string };
}

export type HeadingWithNoMarksNode = PMNode & HeadingWithNoMarksDefinition;

export const headingWithNoMarks =
  createPMNodeSpecFactory<HeadingWithNoMarksNode>({
    group: 'block',
    attrs: { level: { default: 1 }, localId: { default: null } },
    selectable: false,
    defining: true,
  });

export interface ImageDefinition {
  type: 'image';
  attrs: { src: string; alt?: string; title?: string };
}

export type ImageNode = PMNode & ImageDefinition;

export const image = createPMNodeSpecFactory<ImageNode>({
  group: 'inline',
  inline: true,
  attrs: {
    src: { default: '' },
    alt: { default: '' },
    title: { default: null },
  },
  draggable: true,
});

export interface InlineCardNodeAttributes0 {
  url: string;
  localId?: string;
}

export interface InlineCardNodeAttributes1 {
  data: Record<string, unknown>;
  localId?: string;
}

export interface InlineCardDefinition {
  type: 'inlineCard';
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: InlineCardNodeAttributes0 | InlineCardNodeAttributes1;
}

export type InlineCardNode = PMNode & InlineCardDefinition;

export const inlineCard = createPMNodeSpecFactory<InlineCardNode>({
  group: 'inline',
  inline: true,
  attrs: {
    url: { default: null },
    localId: { default: null },
    data: { default: null },
  },
  selectable: true,
  draggable: true,
});

export interface InlineCardStage0NodeAttributes0 {
  url: string;
  localId?: string;
}

export interface InlineCardStage0NodeAttributes1 {
  data: Record<string, unknown>;
  localId?: string;
}

export interface InlineCardStage0Definition {
  type: 'inlineCard';
  marks: Array<
    AnnotationMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark
  >;
  attrs: InlineCardStage0NodeAttributes0 | InlineCardStage0NodeAttributes1;
}

export type InlineCardStage0Node = PMNode & InlineCardStage0Definition;

export const inlineCardStage0 = createPMNodeSpecFactory<InlineCardStage0Node>({
  group: 'inline',
  inline: true,
  attrs: {
    url: { default: null },
    localId: { default: null },
    data: { default: null },
  },
  selectable: true,
  draggable: true,
});

export interface InlineExtensionDefinition {
  type: 'inlineExtension';
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: {
    extensionKey: string;
    extensionType: string;
    parameters?: Record<string, unknown>;
    text?: string;
    localId?: string;
  };
}

export type InlineExtensionNode = PMNode & InlineExtensionDefinition;

export const inlineExtension = createPMNodeSpecFactory<InlineExtensionNode>({
  group: 'inline',
  inline: true,
  attrs: {
    extensionKey: { default: '' },
    extensionType: { default: '' },
    parameters: { default: null },
    text: { default: null },
    localId: { default: null },
  },
  selectable: true,
});

export interface InlineExtensionWithMarksDefinition {
  type: 'inlineExtension';
  marks: Array<
    | DataConsumerMark
    | FragmentMark
    | UnsupportedMarkMark
    | UnsupportedNodeAttributeMark
  >;
  attrs: {
    extensionKey: string;
    extensionType: string;
    parameters?: Record<string, unknown>;
    text?: string;
    localId?: string;
  };
}

export type InlineExtensionWithMarksNode = PMNode &
  InlineExtensionWithMarksDefinition;

export const inlineExtensionWithMarks =
  createPMNodeSpecFactory<InlineExtensionWithMarksNode>({
    group: 'inline',
    inline: true,
    attrs: {
      extensionKey: { default: '' },
      extensionType: { default: '' },
      parameters: { default: null },
      text: { default: null },
      localId: { default: null },
    },
    selectable: true,
  });

export interface LayoutColumnDefinition {
  type: 'layoutColumn';
  content: Array<BlockDefinition | UnsupportedBlockDefinition>;
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: { width: number; localId?: string };
}

export type LayoutColumnNode = PMNode & LayoutColumnDefinition;

export const layoutColumn = createPMNodeSpecFactory<LayoutColumnNode>({
  content: '(block | unsupportedBlock)+',
  marks:
    'unsupportedMark unsupportedNodeAttribute alignment indentation dataConsumer fragment',
  attrs: { width: { default: undefined }, localId: { default: null } },
  selectable: false,
  isolating: true,
});

export interface LayoutSectionDefinition {
  type: 'layoutSection';
  content: Array<
    | LayoutColumnDefinition
    | UnsupportedBlockDefinition
    | UnsupportedBlockDefinition
  >;
  marks: Array<
    BreakoutMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark
  >;
  attrs: { localId?: string };
}

export type LayoutSectionNode = PMNode & LayoutSectionDefinition;

export const layoutSection = createPMNodeSpecFactory<LayoutSectionNode>({
  content: '(layoutColumn | unsupportedBlock){1,3} unsupportedBlock*',
  marks: 'unsupportedMark unsupportedNodeAttribute',
  attrs: { localId: { default: null } },
  isolating: true,
});

export interface LayoutSectionFullDefinition {
  type: 'layoutSection';
  content: Array<LayoutColumnDefinition | UnsupportedBlockDefinition>;
  marks: Array<
    BreakoutMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark
  >;
  attrs: { localId?: string };
}

export type LayoutSectionFullNode = PMNode & LayoutSectionFullDefinition;

export const layoutSectionFull = createPMNodeSpecFactory<LayoutSectionFullNode>(
  {
    content: '(layoutColumn | unsupportedBlock){2,3}',
    marks: 'unsupportedMark unsupportedNodeAttribute',
    attrs: { localId: { default: null } },
    isolating: true,
  },
);

export interface LayoutSectionWithSingleColumnStage0Definition {
  type: 'layoutSection';
  content: Array<
    | LayoutColumnDefinition
    | UnsupportedBlockDefinition
    | UnsupportedBlockDefinition
  >;
  marks: Array<
    BreakoutMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark
  >;
  attrs: { columnRuleStyle?: 'solid'; localId?: string };
}

export type LayoutSectionWithSingleColumnStage0Node = PMNode &
  LayoutSectionWithSingleColumnStage0Definition;

export const layoutSectionWithSingleColumnStage0 =
  createPMNodeSpecFactory<LayoutSectionWithSingleColumnStage0Node>({
    content: '(layoutColumn | unsupportedBlock){1,5} unsupportedBlock*',
    marks: 'unsupportedMark unsupportedNodeAttribute',
    attrs: { columnRuleStyle: { default: null }, localId: { default: null } },
    isolating: true,
  });

export interface ListItemDefinition {
  type: 'listItem';
  content: Array<
    | BulletListDefinition
    | CodeBlockDefinition
    | CodeBlockDefinition
    | ExtensionWithMarksDefinition
    | ExtensionWithMarksDefinition
    | MediaSingleCaptionDefinition
    | MediaSingleCaptionDefinition
    | MediaSingleFullDefinition
    | MediaSingleFullDefinition
    | OrderedListDefinition
    | ParagraphWithNoMarksDefinition
    | ParagraphWithNoMarksDefinition
    | TaskListDefinition
    | UnsupportedBlockDefinition
    | UnsupportedBlockDefinition
  >;
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: { localId?: string };
}

export type ListItemNode = PMNode & ListItemDefinition;

export const listItem = createPMNodeSpecFactory<ListItemNode>({
  content:
    '(paragraph | mediaSingle | codeBlock | unsupportedBlock | extension) (paragraph | bulletList | orderedList | taskList | mediaSingle | codeBlock | unsupportedBlock | extension)*',
  marks: 'dataConsumer fragment unsupportedMark unsupportedNodeAttribute',
  attrs: { localId: { default: null } },
  selectable: false,
  defining: true,
});

export interface ListItemWithNestedDecisionStage0Definition {
  type: 'listItem';
  content: Array<
    | BulletListDefinition
    | CodeBlockDefinition
    | CodeBlockDefinition
    | DecisionListDefinition
    | DecisionListDefinition
    | ExtensionWithMarksDefinition
    | ExtensionWithMarksDefinition
    | MediaSingleCaptionDefinition
    | MediaSingleCaptionDefinition
    | MediaSingleFullDefinition
    | MediaSingleFullDefinition
    | OrderedListDefinition
    | ParagraphWithNoMarksDefinition
    | ParagraphWithNoMarksDefinition
    | TaskListDefinition
    | UnsupportedBlockDefinition
    | UnsupportedBlockDefinition
  >;
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: { localId?: string };
}

export type ListItemWithNestedDecisionStage0Node = PMNode &
  ListItemWithNestedDecisionStage0Definition;

export const listItemWithNestedDecisionStage0 =
  createPMNodeSpecFactory<ListItemWithNestedDecisionStage0Node>({
    content:
      '(paragraph | mediaSingle | codeBlock | unsupportedBlock | decisionList | extension) (paragraph | bulletList | orderedList | taskList | mediaSingle | codeBlock | unsupportedBlock | decisionList | extension)*',
    marks: 'unsupportedMark unsupportedNodeAttribute dataConsumer fragment',
    attrs: { localId: { default: null } },
    selectable: false,
    defining: true,
  });

export interface MediaNodeAttributes0 {
  type: 'link' | 'file';
  localId?: string;
  id: string;
  alt?: string;
  collection: string;
  height?: number;
  occurrenceKey?: string;
  width?: number;
  __contextId?: string;
  __displayType?: 'file' | 'thumbnail';
  __external?: boolean;
  __fileMimeType?: string;
  __fileName?: number;
  __fileSize?: string;
  __mediaTraceId?: string;
}

export interface MediaNodeAttributes1 {
  type: 'external';
  localId?: string;
  alt?: string;
  height?: number;
  width?: number;
  url: string;
  __external?: boolean;
}

export interface MediaDefinition {
  type: 'media';
  marks: Array<
    | AnnotationMark
    | BorderMark
    | LinkMark
    | UnsupportedMarkMark
    | UnsupportedNodeAttributeMark
  >;
  attrs: MediaNodeAttributes0 | MediaNodeAttributes1;
}

export type MediaNode = PMNode & MediaDefinition;

export const media = createPMNodeSpecFactory<MediaNode>({
  attrs: {
    type: { default: 'file' },
    localId: { default: null },
    id: { default: '' },
    alt: { default: '' },
    collection: { default: '' },
    height: { default: null },
    occurrenceKey: { default: null },
    width: { default: null },
    __contextId: { default: null },
    __displayType: { default: null },
    __external: { default: false },
    __fileMimeType: { default: null },
    __fileName: { default: null },
    __fileSize: { default: null },
    __mediaTraceId: { default: null },
    url: { default: null },
  },
  selectable: true,
});

export interface MediaGroupDefinition {
  type: 'mediaGroup';
  content: Array<MediaDefinition | UnsupportedBlockDefinition>;
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
}

export type MediaGroupNode = PMNode & MediaGroupDefinition;

export const mediaGroup = createPMNodeSpecFactory<MediaGroupNode>({
  content: '(media | unsupportedBlock)+',
  marks: 'link annotation border unsupportedMark unsupportedNodeAttribute',
  group: 'block',
  attrs: {},
  selectable: false,
});

export interface MediaInlineDefinition {
  type: 'mediaInline';
  marks: Array<
    | AnnotationMark
    | BorderMark
    | LinkMark
    | UnsupportedMarkMark
    | UnsupportedNodeAttributeMark
  >;
  attrs: {
    type?: 'link' | 'file' | 'image';
    localId?: string;
    url?: string;
    id: string;
    alt?: string;
    collection: string;
    occurrenceKey?: string;
    width?: number;
    height?: number;
    __fileName?: string;
    __fileSize?: number;
    __fileMimeType?: string;
    __displayType?: 'file' | 'thumbnail';
    __contextId?: string;
    __mediaTraceId?: string;
    __external?: boolean;
    data?: Record<string, unknown>;
  };
}

export type MediaInlineNode = PMNode & MediaInlineDefinition;

export const mediaInline = createPMNodeSpecFactory<MediaInlineNode>({
  group: 'inline',
  inline: true,
  attrs: {
    type: { default: 'file' },
    localId: { default: null },
    url: { default: null },
    id: { default: '' },
    alt: { default: '' },
    collection: { default: '' },
    occurrenceKey: { default: null },
    width: { default: null },
    height: { default: null },
    __fileName: { default: null },
    __fileSize: { default: null },
    __fileMimeType: { default: null },
    __displayType: { default: null },
    __contextId: { default: null },
    __mediaTraceId: { default: null },
    __external: { default: false },
  },
  selectable: true,
});

export interface MediaSingleNodeAttributes0 {
  localId?: string;
  width?: number;
  layout:
    | 'wide'
    | 'full-width'
    | 'center'
    | 'wrap-right'
    | 'wrap-left'
    | 'align-end'
    | 'align-start';
  widthType?: 'percentage';
}

export interface MediaSingleNodeAttributes1 {
  localId?: string;
  width: number;
  widthType: 'pixel';
  layout:
    | 'wide'
    | 'full-width'
    | 'center'
    | 'wrap-right'
    | 'wrap-left'
    | 'align-end'
    | 'align-start';
}

export interface MediaSingleDefinition {
  type: 'mediaSingle';
  marks: Array<LinkMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: MediaSingleNodeAttributes0 | MediaSingleNodeAttributes1;
}

export type MediaSingleNode = PMNode & MediaSingleDefinition;

export const mediaSingle = createPMNodeSpecFactory<MediaSingleNode>({
  group: 'block',
  atom: true,
  attrs: { layout: { default: 'center' }, width: { default: null } },
  selectable: true,
  content: 'media|unsupportedBlock+|media unsupportedBlock+',
  marks: 'annotation border link unsupportedMark unsupportedNodeAttribute',
});

export interface MediaSingleCaptionNodeAttributes0 {
  localId?: string;
  width?: number;
  layout:
    | 'wide'
    | 'full-width'
    | 'center'
    | 'wrap-right'
    | 'wrap-left'
    | 'align-end'
    | 'align-start';
  widthType?: 'percentage';
}

export interface MediaSingleCaptionNodeAttributes1 {
  localId?: string;
  width: number;
  widthType: 'pixel';
  layout:
    | 'wide'
    | 'full-width'
    | 'center'
    | 'wrap-right'
    | 'wrap-left'
    | 'align-end'
    | 'align-start';
}

export interface MediaSingleCaptionDefinition {
  type: 'mediaSingle';
  content: Array<
    | CaptionDefinition
    | MediaDefinition
    | UnsupportedBlockDefinition
    | UnsupportedBlockDefinition
  >;
  attrs: MediaSingleCaptionNodeAttributes0 | MediaSingleCaptionNodeAttributes1;
}

export type MediaSingleCaptionNode = PMNode & MediaSingleCaptionDefinition;

export const mediaSingleCaption =
  createPMNodeSpecFactory<MediaSingleCaptionNode>({
    content:
      'media|unsupportedBlock+|media (caption|unsupportedBlock) unsupportedBlock*',
    marks: 'link annotation border unsupportedMark unsupportedNodeAttribute',
    group: 'block',
    atom: false,
    attrs: { layout: { default: 'center' }, width: { default: null } },
    selectable: true,
  });

export interface MediaSingleFullNodeAttributes0 {
  localId?: string;
  width?: number;
  layout:
    | 'wide'
    | 'full-width'
    | 'center'
    | 'wrap-right'
    | 'wrap-left'
    | 'align-end'
    | 'align-start';
  widthType?: 'percentage';
}

export interface MediaSingleFullNodeAttributes1 {
  localId?: string;
  width: number;
  widthType: 'pixel';
  layout:
    | 'wide'
    | 'full-width'
    | 'center'
    | 'wrap-right'
    | 'wrap-left'
    | 'align-end'
    | 'align-start';
}

export interface MediaSingleFullDefinition {
  type: 'mediaSingle';
  content: Array<MediaDefinition | UnsupportedBlockDefinition>;
  attrs: MediaSingleFullNodeAttributes0 | MediaSingleFullNodeAttributes1;
}

export type MediaSingleFullNode = PMNode & MediaSingleFullDefinition;

export const mediaSingleFull = createPMNodeSpecFactory<MediaSingleFullNode>({
  content:
    'media|unsupportedBlock+|media (caption|unsupportedBlock) unsupportedBlock*',
  marks: 'link annotation border unsupportedMark unsupportedNodeAttribute',
  group: 'block',
  atom: false,
  attrs: {
    localId: { default: null },
    width: { default: null },
    layout: { default: 'center' },
    widthType: { default: null },
  },
  selectable: true,
});

export interface MediaSingleWidthTypeNodeAttributes0 {
  localId?: string;
  width?: number;
  layout:
    | 'wide'
    | 'full-width'
    | 'center'
    | 'wrap-right'
    | 'wrap-left'
    | 'align-end'
    | 'align-start';
  widthType?: 'percentage';
}

export interface MediaSingleWidthTypeNodeAttributes1 {
  localId?: string;
  width: number;
  widthType: 'pixel';
  layout:
    | 'wide'
    | 'full-width'
    | 'center'
    | 'wrap-right'
    | 'wrap-left'
    | 'align-end'
    | 'align-start';
}

export interface MediaSingleWidthTypeDefinition {
  type: 'mediaSingle';
  content: Array<MediaDefinition | UnsupportedBlockDefinition>;
  attrs:
    | MediaSingleWidthTypeNodeAttributes0
    | MediaSingleWidthTypeNodeAttributes1;
}

export type MediaSingleWidthTypeNode = PMNode & MediaSingleWidthTypeDefinition;

export const mediaSingleWidthType =
  createPMNodeSpecFactory<MediaSingleWidthTypeNode>({
    content: 'media|unsupportedBlock+|media unsupportedBlock+',
    marks: 'link annotation border unsupportedMark unsupportedNodeAttribute',
    group: 'block',
    atom: true,
    attrs: {
      localId: { default: null },
      width: { default: null },
      layout: { default: 'center' },
      widthType: { default: null },
    },
    selectable: true,
  });

export interface MentionDefinition {
  type: 'mention';
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: {
    id: string;
    localId?: string;
    text?: string;
    accessLevel?: string;
    userType?: 'DEFAULT' | 'SPECIAL' | 'APP';
  };
}

export type MentionNode = PMNode & MentionDefinition;

export const mention = createPMNodeSpecFactory<MentionNode>({
  group: 'inline',
  inline: true,
  attrs: {
    id: { default: '' },
    localId: { default: null },
    text: { default: '' },
    accessLevel: { default: '' },
    userType: { default: null },
  },
  selectable: true,
});

export interface MentionStage0Definition {
  type: 'mention';
  marks: Array<
    AnnotationMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark
  >;
  attrs: {
    id: string;
    localId?: string;
    text?: string;
    accessLevel?: string;
    userType?: 'DEFAULT' | 'SPECIAL' | 'APP';
  };
}

export type MentionStage0Node = PMNode & MentionStage0Definition;

export const mentionStage0 = createPMNodeSpecFactory<MentionStage0Node>({
  group: 'inline',
  inline: true,
  attrs: {
    id: { default: '' },
    localId: { default: null },
    text: { default: '' },
    accessLevel: { default: '' },
    userType: { default: null },
  },
  selectable: true,
});

export interface MultiBodiedExtensionStage0Definition {
  type: 'multiBodiedExtension';
  content: Array<ExtensionFrameStage0Definition>;
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: {
    extensionKey: string;
    extensionType: string;
    parameters?: Record<string, unknown>;
    text?: string;
    layout?: 'default' | 'wide' | 'full-width';
    localId?: string;
  };
}

export type MultiBodiedExtensionStage0Node = PMNode &
  MultiBodiedExtensionStage0Definition;

export const multiBodiedExtensionStage0 =
  createPMNodeSpecFactory<MultiBodiedExtensionStage0Node>({
    content: 'extensionFrame+',
    marks: 'unsupportedNodeAttribute unsupportedMark',
    group: 'blockRootOnly',
    attrs: {
      extensionKey: { default: '' },
      extensionType: { default: '' },
      parameters: { default: null },
      text: { default: null },
      layout: { default: 'default' },
      localId: { default: null },
    },
    selectable: true,
    definingAsContext: true,
  });

export interface NestedExpandDefinition {
  type: 'nestedExpand';
  content: Array<
    | BlockquoteDefinition
    | BulletListDefinition
    | CodeBlockDefinition
    | DecisionListDefinition
    | ExtensionWithMarksDefinition
    | HeadingWithNoMarksDefinition
    | MediaGroupDefinition
    | MediaSingleCaptionDefinition
    | MediaSingleFullDefinition
    | OrderedListDefinition
    | PanelDefinition
    | ParagraphWithNoMarksDefinition
    | RuleDefinition
    | TaskListDefinition
    | UnsupportedBlockDefinition
  >;
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: { title?: string; __expanded?: boolean; localId?: string };
}

export type NestedExpandNode = PMNode & NestedExpandDefinition;

export const nestedExpand = createPMNodeSpecFactory<NestedExpandNode>({
  content:
    '(paragraph | heading | mediaSingle | mediaGroup | codeBlock | bulletList | orderedList | taskList | decisionList | rule | panel | blockquote | unsupportedBlock | extension)+',
  marks: 'unsupportedMark unsupportedNodeAttribute dataConsumer fragment',
  attrs: {
    title: { default: '' },
    __expanded: { default: true },
    localId: { default: null },
  },
  selectable: true,
  isolating: true,
});

export interface NestedExpandWithNoMarksDefinition {
  type: 'nestedExpand';
  attrs: { title?: string; __expanded?: boolean; localId?: string };
}

export type NestedExpandWithNoMarksNode = PMNode &
  NestedExpandWithNoMarksDefinition;

export const nestedExpandWithNoMarks =
  createPMNodeSpecFactory<NestedExpandWithNoMarksNode>({
    attrs: {
      title: { default: '' },
      __expanded: { default: true },
      localId: { default: null },
    },
    selectable: true,
    isolating: true,
  });

export interface OrderedListDefinition {
  type: 'orderedList';
  content: Array<
    ListItemDefinition | ListItemWithNestedDecisionStage0Definition
  >;
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: { order?: number; localId?: string };
}

export type OrderedListNode = PMNode & OrderedListDefinition;

export const orderedList = createPMNodeSpecFactory<OrderedListNode>({
  content: 'listItem+',
  marks: 'unsupportedMark unsupportedNodeAttribute',
  group: 'block',
  attrs: { order: { default: 1 }, localId: { default: null } },
  selectable: false,
});

export interface PanelDefinition {
  type: 'panel';
  content: Array<
    | BlockCardDefinition
    | BulletListDefinition
    | CodeBlockDefinition
    | DecisionListDefinition
    | ExtensionWithMarksDefinition
    | HeadingWithNoMarksDefinition
    | MediaGroupDefinition
    | MediaSingleCaptionDefinition
    | MediaSingleFullDefinition
    | OrderedListDefinition
    | ParagraphWithNoMarksDefinition
    | RuleDefinition
    | TaskListDefinition
    | UnsupportedBlockDefinition
  >;
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: {
    panelType:
      | 'info'
      | 'note'
      | 'tip'
      | 'warning'
      | 'error'
      | 'success'
      | 'custom';
    panelIcon?: string;
    panelIconId?: string;
    panelIconText?: string;
    panelColor?: string;
    localId?: string;
  };
}

export type PanelNode = PMNode & PanelDefinition;

export const panel = createPMNodeSpecFactory<PanelNode>({
  content:
    '(paragraph | heading | bulletList | orderedList | blockCard | mediaGroup | mediaSingle | codeBlock | taskList | rule | decisionList | unsupportedBlock | extension)+',
  marks: 'unsupportedMark unsupportedNodeAttribute dataConsumer fragment',
  group: 'block',
  attrs: {
    panelType: { default: 'info' },
    panelIcon: { default: null },
    panelIconId: { default: null },
    panelIconText: { default: null },
    panelColor: { default: null },
    localId: { default: null },
  },
  selectable: true,
});

export interface ParagraphDefinition {
  type: 'paragraph';
  content: Array<InlineDefinition>;
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: { localId?: string };
}

export type ParagraphNode = PMNode & ParagraphDefinition;

export const paragraph = createPMNodeSpecFactory<ParagraphNode>({
  content: 'inline*',
  marks:
    'link em strong strike subsup underline textColor annotation backgroundColor typeAheadQuery confluenceInlineComment unsupportedNodeAttribute unsupportedMark code dataConsumer fragment border',
  group: 'block',
  attrs: { localId: { default: null } },
  selectable: false,
});

export interface ParagraphWithAlignmentDefinition {
  type: 'paragraph';
  marks: Array<
    AlignmentMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark
  >;
  attrs: { localId?: string };
}

export type ParagraphWithAlignmentNode = PMNode &
  ParagraphWithAlignmentDefinition;

export const paragraphWithAlignment =
  createPMNodeSpecFactory<ParagraphWithAlignmentNode>({
    group: 'block',
    attrs: { localId: { default: null } },
    selectable: false,
  });

export interface ParagraphWithIndentationDefinition {
  type: 'paragraph';
  marks: Array<
    IndentationMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark
  >;
  attrs: { localId?: string };
}

export type ParagraphWithIndentationNode = PMNode &
  ParagraphWithIndentationDefinition;

export const paragraphWithIndentation =
  createPMNodeSpecFactory<ParagraphWithIndentationNode>({
    group: 'block',
    attrs: { localId: { default: null } },
    selectable: false,
  });

export interface ParagraphWithNoMarksDefinition {
  type: 'paragraph';
  attrs: { localId?: string };
}

export type ParagraphWithNoMarksNode = PMNode & ParagraphWithNoMarksDefinition;

export const paragraphWithNoMarks =
  createPMNodeSpecFactory<ParagraphWithNoMarksNode>({
    group: 'block',
    attrs: { localId: { default: null } },
    selectable: false,
  });

export interface PlaceholderDefinition {
  type: 'placeholder';
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: { text: string; localId?: string };
}

export type PlaceholderNode = PMNode & PlaceholderDefinition;

export const placeholder = createPMNodeSpecFactory<PlaceholderNode>({
  marks: '',
  group: 'inline',
  inline: true,
  attrs: { text: { default: '' }, localId: { default: null } },
  selectable: false,
});

export interface RuleDefinition {
  type: 'rule';
  attrs: { localId?: string };
}

export type RuleNode = PMNode & RuleDefinition;

export const rule = createPMNodeSpecFactory<RuleNode>({
  group: 'block',
  attrs: { localId: { default: null } },
});

export interface StatusDefinition {
  type: 'status';
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: {
    text: string;
    color: 'neutral' | 'purple' | 'blue' | 'red' | 'yellow' | 'green';
    localId?: string;
    style?: string;
  };
}

export type StatusNode = PMNode & StatusDefinition;

export const status = createPMNodeSpecFactory<StatusNode>({
  group: 'inline',
  inline: true,
  attrs: {
    text: { default: '' },
    color: { default: '' },
    localId: { default: '' },
    style: { default: '' },
  },
  selectable: true,
});

export interface StatusStage0Definition {
  type: 'status';
  marks: Array<
    AnnotationMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark
  >;
  attrs: {
    text: string;
    color: 'neutral' | 'purple' | 'blue' | 'red' | 'yellow' | 'green';
    localId?: string;
    style?: string;
  };
}

export type StatusStage0Node = PMNode & StatusStage0Definition;

export const statusStage0 = createPMNodeSpecFactory<StatusStage0Node>({
  group: 'inline',
  inline: true,
  attrs: {
    text: { default: '' },
    color: { default: '' },
    localId: { default: '' },
    style: { default: '' },
  },
  selectable: true,
});

export interface SyncBlockDefinition {
  type: 'syncBlock';
  marks: Array<
    BreakoutMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark
  >;
  attrs: { resourceId: string; localId: string };
}

export type SyncBlockNode = PMNode & SyncBlockDefinition;

export const syncBlock = createPMNodeSpecFactory<SyncBlockNode>({
  attrs: { resourceId: { default: '' }, localId: { default: '' } },
  selectable: true,
});

export interface TableDefinition {
  type: 'table';
  content: Array<TableRowDefinition>;
  marks: Array<
    FragmentMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark
  >;
  attrs: {
    displayMode?: 'default' | 'fixed';
    isNumberColumnEnabled?: boolean;
    layout?:
      | 'wide'
      | 'full-width'
      | 'center'
      | 'align-end'
      | 'align-start'
      | 'default';
    localId?: string;
    width?: number;
    __autoSize?: boolean;
  };
}

export type TableNode = PMNode & TableDefinition;

export const table = createPMNodeSpecFactory<TableNode>({
  content: 'tableRow+',
  marks: 'unsupportedMark unsupportedNodeAttribute',
  group: 'block',
  attrs: {
    displayMode: { default: null },
    isNumberColumnEnabled: { default: false },
    layout: { default: 'default' },
    localId: { default: '' },
    width: { default: null },
    __autoSize: { default: false },
  },
  selectable: true,
  isolating: true,
  tableRole: 'table',
});

export interface TableWithNestedTableDefinition {
  type: 'table';
  content: Array<TableRowWithNestedTableDefinition>;
  marks: Array<
    FragmentMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark
  >;
  attrs: {
    displayMode?: 'default' | 'fixed';
    isNumberColumnEnabled?: boolean;
    layout?:
      | 'wide'
      | 'full-width'
      | 'center'
      | 'align-end'
      | 'align-start'
      | 'default';
    localId?: string;
    width?: number;
    __autoSize?: boolean;
  };
}

export type TableWithNestedTableNode = PMNode & TableWithNestedTableDefinition;

export const tableWithNestedTable =
  createPMNodeSpecFactory<TableWithNestedTableNode>({
    content: 'tableRow+',
    marks: 'unsupportedMark unsupportedNodeAttribute',
    group: 'block',
    attrs: {
      displayMode: { default: null },
      isNumberColumnEnabled: { default: false },
      layout: { default: 'default' },
      localId: { default: '' },
      width: { default: null },
      __autoSize: { default: false },
    },
    selectable: true,
    isolating: true,
    tableRole: 'table',
  });

export interface TableCellDefinition {
  type: 'tableCell';
  content: Array<
    | BlockCardDefinition
    | BlockquoteDefinition
    | BulletListDefinition
    | CodeBlockDefinition
    | DecisionListDefinition
    | EmbedCardDefinition
    | ExtensionWithMarksDefinition
    | HeadingWithAlignmentDefinition
    | HeadingWithIndentationDefinition
    | HeadingWithNoMarksDefinition
    | MediaGroupDefinition
    | MediaSingleCaptionDefinition
    | MediaSingleFullDefinition
    | NestedExpandWithNoMarksDefinition
    | OrderedListDefinition
    | PanelDefinition
    | ParagraphWithAlignmentDefinition
    | ParagraphWithNoMarksDefinition
    | RuleDefinition
    | TaskListDefinition
    | UnsupportedBlockDefinition
  >;
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: {
    colspan?: number;
    rowspan?: number;
    colwidth?: Array<number>;
    background?: string;
    localId?: string;
  };
}

export type TableCellNode = PMNode & TableCellDefinition;

export const tableCell = createPMNodeSpecFactory<TableCellNode>({
  content:
    '(paragraph | panel | blockquote | orderedList | bulletList | rule | heading | codeBlock | mediaSingle | mediaGroup | decisionList | taskList | blockCard | embedCard | extension | nestedExpand | unsupportedBlock)+',
  marks:
    'alignment unsupportedMark unsupportedNodeAttribute dataConsumer fragment',
  attrs: {
    colspan: { default: 1 },
    rowspan: { default: 1 },
    colwidth: { default: null },
    background: { default: null },
    localId: { default: null },
  },
  selectable: false,
  isolating: true,
  tableRole: 'cell',
});

export interface TableCellWithNestedTableDefinition {
  type: 'tableCell';
  content: Array<
    | BlockCardDefinition
    | BlockquoteDefinition
    | BulletListDefinition
    | CodeBlockDefinition
    | DecisionListDefinition
    | EmbedCardDefinition
    | ExtensionWithMarksDefinition
    | HeadingWithAlignmentDefinition
    | HeadingWithIndentationDefinition
    | HeadingWithNoMarksDefinition
    | MediaGroupDefinition
    | MediaSingleCaptionDefinition
    | MediaSingleFullDefinition
    | NestedExpandWithNoMarksDefinition
    | OrderedListDefinition
    | PanelDefinition
    | ParagraphWithAlignmentDefinition
    | ParagraphWithNoMarksDefinition
    | RuleDefinition
    | TableDefinition
    | TaskListDefinition
    | UnsupportedBlockDefinition
  >;
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: {
    colspan?: number;
    rowspan?: number;
    colwidth?: Array<number>;
    background?: string;
    localId?: string;
  };
}

export type TableCellWithNestedTableNode = PMNode &
  TableCellWithNestedTableDefinition;

export const tableCellWithNestedTable =
  createPMNodeSpecFactory<TableCellWithNestedTableNode>({
    content:
      '(paragraph | panel | blockquote | orderedList | bulletList | rule | heading | codeBlock | mediaSingle | mediaGroup | decisionList | taskList | blockCard | embedCard | extension | nestedExpand | unsupportedBlock | table)+',
    marks:
      'alignment unsupportedMark unsupportedNodeAttribute dataConsumer fragment',
    attrs: {
      colspan: { default: 1 },
      rowspan: { default: 1 },
      colwidth: { default: null },
      background: { default: null },
      localId: { default: null },
    },
    selectable: false,
    isolating: true,
    tableRole: 'cell',
  });

export interface TableHeaderDefinition {
  type: 'tableHeader';
  content: Array<
    | BlockCardDefinition
    | BlockquoteDefinition
    | BulletListDefinition
    | CodeBlockDefinition
    | DecisionListDefinition
    | EmbedCardDefinition
    | ExtensionWithMarksDefinition
    | HeadingWithAlignmentDefinition
    | HeadingWithIndentationDefinition
    | HeadingWithNoMarksDefinition
    | MediaGroupDefinition
    | MediaSingleCaptionDefinition
    | MediaSingleFullDefinition
    | NestedExpandDefinition
    | NestedExpandWithNoMarksDefinition
    | OrderedListDefinition
    | PanelDefinition
    | ParagraphWithAlignmentDefinition
    | ParagraphWithNoMarksDefinition
    | RuleDefinition
    | TaskListDefinition
  >;
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: {
    colspan?: number;
    rowspan?: number;
    colwidth?: Array<number>;
    background?: string;
    localId?: string;
  };
}

export type TableHeaderNode = PMNode & TableHeaderDefinition;

export const tableHeader = createPMNodeSpecFactory<TableHeaderNode>({
  content:
    '(paragraph | panel | blockquote | orderedList | bulletList | rule | heading | codeBlock | mediaSingle | mediaGroup | decisionList | taskList | blockCard | embedCard | extension | nestedExpand)+',
  marks:
    'alignment unsupportedMark unsupportedNodeAttribute dataConsumer fragment',
  attrs: {
    colspan: { default: 1 },
    rowspan: { default: 1 },
    colwidth: { default: null },
    background: { default: null },
    localId: { default: null },
  },
  selectable: false,
  isolating: true,
  tableRole: 'header_cell',
});

export interface TableHeaderWithNestedTableDefinition {
  type: 'tableHeader';
  content: Array<
    | BlockCardDefinition
    | BlockquoteDefinition
    | BulletListDefinition
    | CodeBlockDefinition
    | DecisionListDefinition
    | EmbedCardDefinition
    | ExtensionWithMarksDefinition
    | HeadingWithAlignmentDefinition
    | HeadingWithIndentationDefinition
    | HeadingWithNoMarksDefinition
    | MediaGroupDefinition
    | MediaSingleCaptionDefinition
    | MediaSingleFullDefinition
    | NestedExpandDefinition
    | NestedExpandWithNoMarksDefinition
    | OrderedListDefinition
    | PanelDefinition
    | ParagraphWithAlignmentDefinition
    | ParagraphWithNoMarksDefinition
    | RuleDefinition
    | TableDefinition
    | TaskListDefinition
  >;
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: {
    colspan?: number;
    rowspan?: number;
    colwidth?: Array<number>;
    background?: string;
    localId?: string;
  };
}

export type TableHeaderWithNestedTableNode = PMNode &
  TableHeaderWithNestedTableDefinition;

export const tableHeaderWithNestedTable =
  createPMNodeSpecFactory<TableHeaderWithNestedTableNode>({
    content:
      '(paragraph | panel | blockquote | orderedList | bulletList | rule | heading | codeBlock | mediaSingle | mediaGroup | decisionList | taskList | blockCard | embedCard | extension | nestedExpand | table)+',
    marks:
      'alignment unsupportedMark unsupportedNodeAttribute dataConsumer fragment',
    attrs: {
      colspan: { default: 1 },
      rowspan: { default: 1 },
      colwidth: { default: null },
      background: { default: null },
      localId: { default: null },
    },
    selectable: false,
    isolating: true,
    tableRole: 'header_cell',
  });

export interface TableRowDefinition {
  type: 'tableRow';
  content: Array<TableCellDefinition | TableHeaderDefinition>;
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: { localId?: string };
}

export type TableRowNode = PMNode & TableRowDefinition;

export const tableRow = createPMNodeSpecFactory<TableRowNode>({
  content: '(tableCell | tableHeader)+',
  marks: 'unsupportedMark unsupportedNodeAttribute',
  attrs: { localId: { default: null } },
  selectable: false,
  tableRole: 'row',
});

export interface TableRowWithNestedTableDefinition {
  type: 'tableRow';
  content: Array<
    TableCellWithNestedTableDefinition | TableHeaderWithNestedTableDefinition
  >;
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: { localId?: string };
}

export type TableRowWithNestedTableNode = PMNode &
  TableRowWithNestedTableDefinition;

export const tableRowWithNestedTable =
  createPMNodeSpecFactory<TableRowWithNestedTableNode>({
    content: '(tableCell | tableHeader)+',
    marks: 'unsupportedMark unsupportedNodeAttribute',
    attrs: { localId: { default: null } },
    selectable: false,
    tableRole: 'row',
  });

export interface TaskItemDefinition {
  type: 'taskItem';
  content: Array<InlineDefinition>;
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: { localId: string; state: 'TODO' | 'DONE' };
}

export type TaskItemNode = PMNode & TaskItemDefinition;

export const taskItem = createPMNodeSpecFactory<TaskItemNode>({
  content: 'inline*',
  marks: '_',
  attrs: { localId: { default: '' }, state: { default: 'TODO' } },
  selectable: false,
  defining: true,
});

export interface TaskListDefinition {
  type: 'taskList';
  content: Array<
    | BlockTaskItemDefinition
    | BlockTaskItemDefinition
    | TaskItemDefinition
    | TaskItemDefinition
    | TaskListDefinition
    | UnsupportedBlockDefinition
    | UnsupportedBlockDefinition
  >;
  marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
  attrs: { localId: string };
}

export type TaskListNode = PMNode & TaskListDefinition;

export const taskList = createPMNodeSpecFactory<TaskListNode>({
  content:
    '(taskItem | unsupportedBlock | blockTaskItem)+ (taskItem | taskList | unsupportedBlock | blockTaskItem)*',
  marks: 'unsupportedMark unsupportedNodeAttribute',
  group: 'block',
  attrs: { localId: { default: '' } },
  selectable: false,
  defining: true,
});

export interface TextDefinition {
  type: 'text';
}

export type TextNode = PMNode & TextDefinition;

export const text = createPMNodeSpecFactory<TextNode>({ group: 'inline' });

export interface TextCodeInlineDefinition {
  type: 'text';
  marks: Array<
    | AnnotationMark
    | CodeMark
    | LinkMark
    | UnsupportedMarkMark
    | UnsupportedNodeAttributeMark
  >;
}

export type TextCodeInlineNode = PMNode & TextCodeInlineDefinition;

export const textCodeInline = createPMNodeSpecFactory<TextCodeInlineNode>({
  group: 'inline',
});

export interface TextFormattedDefinition {
  type: 'text';
  marks: Array<
    | AnnotationMark
    | BackgroundColorMark
    | ConfluenceInlineCommentMark
    | EmMark
    | LinkMark
    | StrikeMark
    | StrongMark
    | SubsupMark
    | TextColorMark
    | TypeAheadQueryMark
    | UnderlineMark
    | UnsupportedMarkMark
    | UnsupportedNodeAttributeMark
  >;
}

export type TextFormattedNode = PMNode & TextFormattedDefinition;

export const textFormatted = createPMNodeSpecFactory<TextFormattedNode>({
  group: 'inline',
});

export interface TextWithNoMarksDefinition {
  type: 'text';
}

export type TextWithNoMarksNode = PMNode & TextWithNoMarksDefinition;

export const textWithNoMarks = createPMNodeSpecFactory<TextWithNoMarksNode>({});

export interface UnsupportedBlockDefinition {
  type: 'unsupportedBlock';
  attrs: { originalValue: Record<string, unknown> };
}

export type UnsupportedBlockNode = PMNode & UnsupportedBlockDefinition;

export const unsupportedBlock = createPMNodeSpecFactory<UnsupportedBlockNode>({
  group: 'block',
  atom: true,
  attrs: { originalValue: { default: {} } },
  selectable: true,
});

export interface UnsupportedInlineDefinition {
  type: 'unsupportedInline';
  attrs: { originalValue: Record<string, unknown> };
}

export type UnsupportedInlineNode = PMNode & UnsupportedInlineDefinition;

export const unsupportedInline = createPMNodeSpecFactory<UnsupportedInlineNode>(
  {
    group: 'inline',
    inline: true,
    attrs: { originalValue: { default: {} } },
    selectable: true,
  },
);
